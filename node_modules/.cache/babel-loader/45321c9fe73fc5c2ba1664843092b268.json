{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { stringify, possiblyAsyncStringify } from '../../../utils/stringify.js';\nimport { VerbosityLevel } from '../configuration/VerbosityLevel.js';\nimport { ExecutionStatus } from '../reporter/ExecutionStatus.js';\n\nfunction formatHints(hints) {\n  if (hints.length === 1) {\n    return \"Hint: \".concat(hints[0]);\n  }\n\n  return hints.map(function (h, idx) {\n    return \"Hint (\".concat(idx + 1, \"): \").concat(h);\n  }).join('\\n');\n}\n\nfunction formatFailures(failures, stringifyOne) {\n  return \"Encountered failures were:\\n- \".concat(failures.map(stringifyOne).join('\\n- '));\n}\n\nfunction formatExecutionSummary(executionTrees, stringifyOne) {\n  var summaryLines = [];\n  var remainingTreesAndDepth = [];\n\n  var _iterator = _createForOfIteratorHelper(executionTrees.slice().reverse()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _tree = _step.value;\n      remainingTreesAndDepth.push({\n        depth: 1,\n        tree: _tree\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  while (remainingTreesAndDepth.length !== 0) {\n    var currentTreeAndDepth = remainingTreesAndDepth.pop();\n    var currentTree = currentTreeAndDepth.tree;\n    var currentDepth = currentTreeAndDepth.depth;\n    var statusIcon = currentTree.status === ExecutionStatus.Success ? \"\\x1B[32m\\u221A\\x1B[0m\" : currentTree.status === ExecutionStatus.Failure ? '\\x1b[31m\\xD7\\x1b[0m' : '\\x1b[33m!\\x1b[0m';\n    var leftPadding = Array(currentDepth).join('. ');\n    summaryLines.push(\"\".concat(leftPadding).concat(statusIcon, \" \").concat(stringifyOne(currentTree.value)));\n\n    var _iterator2 = _createForOfIteratorHelper(currentTree.children.slice().reverse()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var tree = _step2.value;\n        remainingTreesAndDepth.push({\n          depth: currentDepth + 1,\n          tree: tree\n        });\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return \"Execution summary:\\n\".concat(summaryLines.join('\\n'));\n}\n\nfunction preFormatTooManySkipped(out, stringifyOne) {\n  var message = \"Failed to run property, too many pre-condition failures encountered\\n{ seed: \".concat(out.seed, \" }\\n\\nRan \").concat(out.numRuns, \" time(s)\\nSkipped \").concat(out.numSkips, \" time(s)\");\n  var details = null;\n  var hints = ['Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries', 'Increase failure tolerance by setting maxSkipsPerRun to an higher value'];\n\n  if (out.verbose >= VerbosityLevel.VeryVerbose) {\n    details = formatExecutionSummary(out.executionSummary, stringifyOne);\n  } else {\n    hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');\n  }\n\n  return {\n    message: message,\n    details: details,\n    hints: hints\n  };\n}\n\nfunction preFormatFailure(out, stringifyOne) {\n  var message = \"Property failed after \".concat(out.numRuns, \" tests\\n{ seed: \").concat(out.seed, \", path: \\\"\").concat(out.counterexamplePath, \"\\\", endOnFailure: true }\\nCounterexample: \").concat(stringifyOne(out.counterexample), \"\\nShrunk \").concat(out.numShrinks, \" time(s)\\nGot error: \").concat(out.error);\n  var details = null;\n  var hints = [];\n\n  if (out.verbose >= VerbosityLevel.VeryVerbose) {\n    details = formatExecutionSummary(out.executionSummary, stringifyOne);\n  } else if (out.verbose === VerbosityLevel.Verbose) {\n    details = formatFailures(out.failures, stringifyOne);\n  } else {\n    hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');\n  }\n\n  return {\n    message: message,\n    details: details,\n    hints: hints\n  };\n}\n\nfunction preFormatEarlyInterrupted(out, stringifyOne) {\n  var message = \"Property interrupted after \".concat(out.numRuns, \" tests\\n{ seed: \").concat(out.seed, \" }\");\n  var details = null;\n  var hints = [];\n\n  if (out.verbose >= VerbosityLevel.VeryVerbose) {\n    details = formatExecutionSummary(out.executionSummary, stringifyOne);\n  } else {\n    hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');\n  }\n\n  return {\n    message: message,\n    details: details,\n    hints: hints\n  };\n}\n\nfunction defaultReportMessageInternal(out, stringifyOne) {\n  if (!out.failed) return;\n\n  var _ref = out.counterexamplePath === null ? out.interrupted ? preFormatEarlyInterrupted(out, stringifyOne) : preFormatTooManySkipped(out, stringifyOne) : preFormatFailure(out, stringifyOne),\n      message = _ref.message,\n      details = _ref.details,\n      hints = _ref.hints;\n\n  var errorMessage = message;\n  if (details != null) errorMessage += \"\\n\\n\".concat(details);\n  if (hints.length > 0) errorMessage += \"\\n\\n\".concat(formatHints(hints));\n  return errorMessage;\n}\n\nfunction defaultReportMessage(out) {\n  return defaultReportMessageInternal(out, stringify);\n}\n\nfunction asyncDefaultReportMessage(_x) {\n  return _asyncDefaultReportMessage.apply(this, arguments);\n}\n\nfunction _asyncDefaultReportMessage() {\n  _asyncDefaultReportMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(out) {\n    var pendingStringifieds, stringifyOne, firstTryMessage, registeredValues, stringifySecond;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            stringifySecond = function _stringifySecond(value) {\n              var asyncStringifiedIfRegistered = registeredValues.get(value);\n\n              if (asyncStringifiedIfRegistered !== undefined) {\n                return asyncStringifiedIfRegistered;\n              }\n\n              return stringify(value);\n            };\n\n            stringifyOne = function _stringifyOne(value) {\n              var stringified = possiblyAsyncStringify(value);\n\n              if (typeof stringified === 'string') {\n                return stringified;\n              }\n\n              pendingStringifieds.push(Promise.all([value, stringified]));\n              return \"\\u2026\";\n            };\n\n            pendingStringifieds = [];\n            firstTryMessage = defaultReportMessageInternal(out, stringifyOne);\n\n            if (!(pendingStringifieds.length === 0)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", firstTryMessage);\n\n          case 6:\n            _context.t0 = Map;\n            _context.next = 9;\n            return Promise.all(pendingStringifieds);\n\n          case 9:\n            _context.t1 = _context.sent;\n            registeredValues = new _context.t0(_context.t1);\n            return _context.abrupt(\"return\", defaultReportMessageInternal(out, stringifySecond));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _asyncDefaultReportMessage.apply(this, arguments);\n}\n\nfunction throwIfFailed(out) {\n  if (!out.failed) return;\n  throw new Error(defaultReportMessage(out));\n}\n\nfunction asyncThrowIfFailed(_x2) {\n  return _asyncThrowIfFailed.apply(this, arguments);\n}\n\nfunction _asyncThrowIfFailed() {\n  _asyncThrowIfFailed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(out) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (out.failed) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 2:\n            _context2.t0 = Error;\n            _context2.next = 5;\n            return asyncDefaultReportMessage(out);\n\n          case 5:\n            _context2.t1 = _context2.sent;\n            throw new _context2.t0(_context2.t1);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _asyncThrowIfFailed.apply(this, arguments);\n}\n\nexport function reportRunDetails(out) {\n  if (out.runConfiguration.asyncReporter) return out.runConfiguration.asyncReporter(out);else if (out.runConfiguration.reporter) return out.runConfiguration.reporter(out);else return throwIfFailed(out);\n}\nexport function asyncReportRunDetails(_x3) {\n  return _asyncReportRunDetails.apply(this, arguments);\n}\n\nfunction _asyncReportRunDetails() {\n  _asyncReportRunDetails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(out) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!out.runConfiguration.asyncReporter) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", out.runConfiguration.asyncReporter(out));\n\n          case 4:\n            if (!out.runConfiguration.reporter) {\n              _context3.next = 8;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", out.runConfiguration.reporter(out));\n\n          case 8:\n            return _context3.abrupt(\"return\", asyncThrowIfFailed(out));\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _asyncReportRunDetails.apply(this, arguments);\n}\n\nexport { defaultReportMessage, asyncDefaultReportMessage };","map":null,"metadata":{},"sourceType":"module"}