{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeTupleAbi = exports.encodeAbi = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:encode\");\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar lodash_sum_1 = __importDefault(require(\"lodash.sum\")); //UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeAbi(input, allocations) {\n  //errors can't be encoded\n  if (input.kind === \"error\") {\n    return undefined;\n  }\n\n  var bytes; //TypeScript can at least infer in the rest of this that we're looking\n  //at a value, not an error!  But that's hardly enough...\n\n  switch (input.type.typeClass) {\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      //none of these can go in the ABI\n      return undefined;\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return Basic.Encode.encodeBasic(input);\n\n        case \"dynamic\":\n          bytes = Bytes.Encode.encodeBytes(input);\n          return padAndPrependLength(bytes);\n      }\n\n    case \"string\":\n      bytes = Bytes.Encode.encodeBytes(input);\n      return padAndPrependLength(bytes);\n\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          case \"internal\":\n            return undefined;\n          //internal functions can't go in the ABI!\n          //Yes, technically we could defer to encodeBasic here, but,\n          //c'mon, that's not how the function's supposed to be used\n\n          case \"external\":\n            return Basic.Encode.encodeBasic(input);\n        }\n      }\n    //now for the serious cases\n\n    case \"array\":\n      {\n        var coercedInput = input;\n\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        var staticEncoding = encodeTupleAbi(coercedInput.value, allocations);\n\n        switch (input.type.kind) {\n          case \"static\":\n            return staticEncoding;\n\n          case \"dynamic\":\n            var encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length\n\n            encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand\n\n            var lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);\n            encoded.set(lengthBytes); //and now we set the length\n\n            return encoded;\n        }\n      }\n\n    case \"struct\":\n      {\n        var _coercedInput = input;\n\n        if (_coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        return encodeTupleAbi(_coercedInput.value.map(function (_ref) {\n          var value = _ref.value;\n          return value;\n        }), allocations);\n      }\n\n    case \"tuple\":\n      //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n      //(That may not be apparent from this one line, but it's true)\n      //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder\n      //However it may be worth revisiting this in the future if performance turns out to be a problem\n      return encodeTupleAbi(input.value.map(function (_ref2) {\n        var value = _ref2.value;\n        return value;\n      }), allocations);\n\n    default:\n      return Basic.Encode.encodeBasic(input);\n  }\n}\n\nexports.encodeAbi = encodeAbi;\n/**\n * @Category Encoding (low-level)\n */\n\nfunction padAndPrependLength(bytes) {\n  var length = bytes.length;\n  var paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);\n  var encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);\n  encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand\n\n  var lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);\n  encoded.set(lengthBytes); //and now we set the length\n\n  return encoded;\n}\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeTupleAbi(tuple, allocations) {\n  var elementEncodings = tuple.map(function (element) {\n    return encodeAbi(element, allocations);\n  });\n\n  if (elementEncodings.some(function (element) {\n    return element === undefined;\n  })) {\n    return undefined;\n  }\n\n  var elementSizeInfo = tuple.map(function (element) {\n    return allocate_1.abiSizeInfo(element.type, allocations);\n  }); //heads and tails here are as discussed in the ABI docs;\n  //for a static type the head is the encoding and the tail is empty,\n  //for a dynamic type the head is the pointer and the tail is the encoding\n\n  var heads = [];\n  var tails = []; //but first, we need to figure out where the first tail will start,\n  //by adding up the sizes of all the heads (we can easily do this in\n  //advance via elementSizeInfo, without needing to know the particular\n  //values of the heads)\n\n  var startOfNextTail = lodash_sum_1.default(elementSizeInfo.map(function (elementInfo) {\n    return elementInfo.size;\n  }));\n\n  for (var i = 0; i < tuple.length; i++) {\n    var head = void 0;\n    var tail = void 0;\n\n    if (!elementSizeInfo[i].dynamic) {\n      //static case\n      head = elementEncodings[i];\n      tail = new Uint8Array(); //empty array\n    } else {\n      //dynamic case\n      head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);\n      tail = elementEncodings[i];\n    }\n\n    heads.push(head);\n    tails.push(tail);\n    startOfNextTail += tail.length;\n  } //finally, we need to concatenate everything together!\n  //since we're dealing with Uint8Arrays, we have to do this manually\n\n\n  var totalSize = startOfNextTail;\n  var encoded = new Uint8Array(totalSize);\n  var position = 0;\n\n  for (var _i = 0, _heads = heads; _i < _heads.length; _i++) {\n    var _head = _heads[_i];\n    encoded.set(_head, position);\n    position += _head.length;\n  }\n\n  for (var _i2 = 0, _tails = tails; _i2 < _tails.length; _i2++) {\n    var _tail = _tails[_i2];\n    encoded.set(_tail, position);\n    position += _tail.length;\n  }\n\n  return encoded;\n}\n\nexports.encodeTupleAbi = encodeTupleAbi;","map":null,"metadata":{},"sourceType":"script"}