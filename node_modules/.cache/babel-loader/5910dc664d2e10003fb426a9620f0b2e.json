{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forBytecode = exports.forContract = void 0;\n\nfunction forContract(contract) {\n  var contractName = contract.contractName,\n      sourcePath = contract.sourcePath,\n      source = contract.source,\n      sourceMap = contract.sourceMap,\n      deployedSourceMap = contract.deployedSourceMap,\n      legacyAST = contract.legacyAST,\n      ast = contract.ast,\n      abi = contract.abi,\n      metadata = contract.metadata,\n      bytecode = contract.bytecode,\n      deployedBytecode = contract.deployedBytecode,\n      compiler = contract.compiler,\n      devdoc = contract.devdoc,\n      userdoc = contract.userdoc,\n      immutableReferences = contract.immutableReferences,\n      generatedSources = contract.generatedSources,\n      deployedGeneratedSources = contract.deployedGeneratedSources,\n      db = contract.db;\n  return {\n    contract_name: contractName,\n    sourcePath: sourcePath,\n    source: source,\n    sourceMap: sourceMap,\n    deployedSourceMap: deployedSourceMap,\n    legacyAST: legacyAST,\n    ast: ast,\n    abi: abi,\n    metadata: metadata,\n    bytecode: forBytecode(bytecode),\n    deployedBytecode: forBytecode(deployedBytecode),\n    unlinked_binary: forBytecode(bytecode),\n    compiler: compiler,\n    devdoc: devdoc,\n    userdoc: userdoc,\n    immutableReferences: immutableReferences,\n    generatedSources: generatedSources,\n    deployedGeneratedSources: deployedGeneratedSources,\n    db: db\n  };\n}\n\nexports.forContract = forContract;\n\nfunction forBytecode(bytecode) {\n  if (!bytecode) {\n    return bytecode;\n  }\n\n  if (typeof bytecode === \"string\") {\n    return bytecode;\n  }\n\n  var bytes = bytecode.bytes,\n      linkReferences = bytecode.linkReferences;\n  linkReferences = linkReferences || []; // inline link references - start by flattening the offsets\n\n  var flattenedLinkReferences = linkReferences // map each link ref to array of link refs with only one offset\n  .map(function (_ref) {\n    var offsets = _ref.offsets,\n        length = _ref.length,\n        name = _ref.name;\n    return offsets.map(function (offset) {\n      return {\n        offset: offset,\n        length: length,\n        name: name\n      };\n    });\n  }) // flatten\n  .reduce(function (a, b) {\n    return [].concat(_toConsumableArray(a), _toConsumableArray(b));\n  }, []); // then overwite bytes with link reference\n\n  bytes = flattenedLinkReferences.reduce(function (bytes, _ref2) {\n    var offset = _ref2.offset,\n        name = _ref2.name,\n        length = _ref2.length;\n    // length is a byte offset\n    var characterLength = length * 2;\n    var linkId = \"__\".concat(name.slice(0, characterLength - 2));\n\n    while (linkId.length < characterLength) {\n      linkId += \"_\";\n    }\n\n    var start = offset * 2;\n    return \"\".concat(bytes.substring(0, start)).concat(linkId).concat(bytes.substring(start + characterLength));\n  }, bytes);\n  return \"0x\".concat(bytes);\n}\n\nexports.forBytecode = forBytecode;","map":null,"metadata":{},"sourceType":"script"}