{"ast":null,"code":"var _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _objectSpread = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar OS = require(\"os\");\n\nvar debug = require(\"debug\")(\"debug-utils\");\n\nvar util = require(\"util\");\n\nvar Codec = require(\"@truffle/codec\");\n\nvar BN = require(\"bn.js\");\n\nvar chromafi = require(\"@trufflesuite/chromafi\");\n\nvar hljsDefineSolidity = require(\"highlightjs-solidity\");\n\nhljsDefineSolidity(chromafi.hljs);\n\nvar chalk = require(\"chalk\");\n\nvar panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\nvar verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\nvar commandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  p: \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  l: \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  h: \"print this help\",\n  v: \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  b: \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  B: \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  c: \"continue until breakpoint\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load new transaction\",\n  T: \"unload transaction\",\n  s: \"print stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources except via `;`\",\n  y: \"(if at end) reset & continue to final error\",\n  Y: \"reset & continue to previous error\"\n};\nvar shortCommandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction\",\n  p: \"print state\",\n  l: \"print context\",\n  h: \"print help\",\n  v: \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  b: \"add breakpoint\",\n  B: \"remove breakpoint\",\n  c: \"continue\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load\",\n  T: \"unload\",\n  s: \"stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources\",\n  y: \"reset & go to final error\",\n  Y: \"reset & go to previous error\"\n};\nvar truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nvar DEFAULT_TAB_WIDTH = 8;\nvar trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  base: chalk,\n  lineNumbers: chalk,\n  trailingSpace: chalk,\n\n  /* classes hljs-solidity actually uses */\n  keyword: truffleColors.mint,\n  number: truffleColors.red,\n  string: truffleColors.green,\n  params: truffleColors.pink,\n  builtIn: truffleColors.watermelon,\n  built_in: truffleColors.watermelon,\n  //just to be sure\n  literal: truffleColors.watermelon,\n  function: truffleColors.orange,\n  title: truffleColors.orange,\n  class: truffleColors.orange,\n  comment: truffleColors.comment,\n  doctag: truffleColors.comment,\n  operator: truffleColors.blue,\n  punctuation: truffleColors.purple,\n\n  /* classes it might soon use! */\n  meta: truffleColors.pink,\n  metaString: truffleColors.green,\n  \"meta-string\": truffleColors.green,\n  //similar\n\n  /* classes it doesn't currently use but notionally could */\n  type: truffleColors.orange,\n  symbol: truffleColors.orange,\n  metaKeyword: truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint,\n  //again, to be sure\n  property: chalk,\n  //not putting any highlighting here for now\n\n  /* classes that don't make sense for Solidity */\n  regexp: chalk,\n  //solidity does not have regexps\n  subst: chalk,\n  //or string interpolation\n  name: chalk,\n  //or s-expressions\n  builtInName: chalk,\n  //or s-expressions, again\n  \"builtin-name\": chalk,\n  //just to be sure\n\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  section: chalk,\n  tag: chalk,\n  attr: chalk,\n  attribute: chalk,\n  variable: chalk,\n  bullet: chalk,\n  code: chalk,\n  emphasis: chalk,\n  strong: chalk,\n  formula: chalk,\n  link: chalk,\n  quote: chalk,\n  selectorAttr: chalk,\n  //lotta redundancy follows\n  \"selector-attr\": chalk,\n  selectorClass: chalk,\n  \"selector-class\": chalk,\n  selectorId: chalk,\n  \"selector-id\": chalk,\n  selectorPseudo: chalk,\n  \"selector-pseudo\": chalk,\n  selectorTag: chalk,\n  \"selector-tag\": chalk,\n  templateTag: chalk,\n  \"template-tag\": chalk,\n  templateVariable: chalk,\n  \"template-variable\": chalk,\n  addition: chalk,\n  deletion: chalk\n};\nvar DebugUtils = {\n  truffleColors: truffleColors,\n  //make these externally available\n  //panicCode may be either a number or a BN\n  panicString: function panicString(panicCode) {\n    var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var unknownString = \"Unknown panic\";\n    var verboseUnknownString = \"A panic occurred of unrecognized type.\";\n\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n\n    return verbose ? verbosePanicTable[panicCode] || verboseUnknownString : panicTable[panicCode] || unknownString;\n  },\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function isUsableCompilation(compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    } //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n\n\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    var lowestInternalIndex = Math.min.apply(Math, _toConsumableArray(compilation.contracts.map(function (contract) {\n      //find first defined index\n      var lowestConstructor = (contract.generatedSources || []).findIndex(function (x) {\n        return x !== undefined;\n      });\n\n      if (lowestConstructor === -1) {\n        lowestConstructor = Infinity;\n      }\n\n      var lowestDeployed = (contract.deployedGeneratedSources || []).findIndex(function (x) {\n        return x !== undefined;\n      });\n\n      if (lowestDeployed === -1) {\n        lowestDeployed = Infinity;\n      }\n\n      return Math.min(lowestConstructor, lowestDeployed);\n    })));\n\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    } //check #4: are there any AST ID collisions?\n\n\n    var astIds = new Set();\n\n    var allIDsUnseenSoFar = function allIDsUnseenSoFar(node) {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occured twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    }; //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n\n\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(function (source) {\n      return !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast);\n    });\n  },\n  formatStartMessage: function formatStartMessage(withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function formatTransactionStartMessage() {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function formatCommandDescription(commandId) {\n    return truffleColors.mint(\"(\".concat(commandId, \")\")) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function formatPrompt(network, txHash) {\n    return txHash !== undefined ? \"debug(\".concat(network, \":\").concat(txHash.substring(0, 10), \"...)> \") : \"debug(\".concat(network, \")> \");\n  },\n  formatAffectedInstances: function formatAffectedInstances(instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\"\".concat(chalk.bold(\"Warning:\"), \" The source code for one or more contracts could not be found.\"));\n    }\n\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function formatHelp() {\n    var lastCommand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"n\";\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\", \"Y\"], [\"y\"], [\";\"], [\"g\", \"G\"], [\"p\"], [\"l\"], [\"s\", \"h\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\"], [\":\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function tabsToSpaces(inputLine) {\n    var tabLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TAB_WIDTH;\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    var line = \"\";\n    var counter = 0;\n\n    for (var i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        var remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n\n    return line;\n  },\n  formatLineNumberPrefix: function formatLineNumberPrefix(line, number, cols) {\n    var prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function formatLinePointer(line, startCol, endCol, padding) {\n    var tabLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_TAB_WIDTH;\n    var prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    var output = \"\";\n    var counter = 0;\n\n    for (var i = 0; i < line.length; i++) {\n      var pointedAt = i >= startCol && i < endCol;\n      var additional = void 0;\n\n      if (line[i] === \"\\t\") {\n        var remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function formatRangeLines(source, range, uncolorizedSource) {\n    var contextBefore = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var contextAfter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n    //note: beforeLines now includes the line itself\n\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map(function (line, index) {\n      var number = startIndex + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map(function (line, index) {\n      var number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    var uncolorizedLine = uncolorizedSource[range.start.line]; // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer( //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function formatBreakpointLocation(breakpoint, here, currentSourceId, sourceNames) {\n    var baseMessage;\n\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here ? \"this point in line \".concat(breakpoint.line + 1) : \"a point in line \".concat(breakpoint.line + 1); //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = \"line \".concat(breakpoint.line + 1);\n    }\n\n    if (breakpoint.sourceId !== currentSourceId) {\n      var sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + \" in \".concat(sourceName);\n    } else {\n      return baseMessage;\n    }\n  },\n  formatCurrentInstruction: function formatCurrentInstruction(instruction) {\n    var pc = this.formatPC(instruction.pc);\n    var formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n  formatInstruction: function formatInstruction(instruction) {\n    return truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function formatPC(pc) {\n    var hex = pc.toString(16);\n\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n  formatStack: function formatStack(stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map(function (item, index) {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += \" (\".concat(stack.length - index - 1, \" from top)\");\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function formatMemory(memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    var maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    var formatted = memory.map(function (word, index) {\n      var address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return \"  0x\".concat(address, \":  \").concat(truffleColors.pink(word));\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function formatStorage(storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    var slots = Object.keys(storage).slice().sort();\n    var formatted = slots.map(function (slot, index) {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return \"0x\".concat(slot, \":\\n\") + \"  \".concat(truffleColors.blue(storage[slot]));\n      } else {\n        return \"  \".concat(truffleColors.blue(storage[slot]));\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function formatCalldata(calldata) {\n    //takes a Uint8Array\n    var selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    var words = [];\n\n    for (var wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n\n    var maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    var maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n\n    var formattedSelector;\n\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + \"  0x\".concat(\"00\".padStart(maxPrefixLength, \"0\"), \":  \") + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    var formatted = words.map(function (word, index) {\n      var address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      var data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return \"  0x\".concat(address, \":  \").concat(truffleColors.pink(data));\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function formatValue(value) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var nativized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    var valueToInspect = nativized ? value : new Codec.Format.Utils.Inspect.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map(function (line, i) {\n      // don't indent first line\n      var padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function formatCustomError(decoding) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var name = decoding.definedIn ? \"\".concat(decoding.definedIn.typeName, \".\").concat(decoding.abi.name) : decoding.abi.name;\n\n    if (decoding.arguments.length === 0) {\n      return \"\".concat(name, \"()\");\n    }\n\n    var prefix = \"\".concat(name, \"(\");\n    var formattedValues = decoding.arguments.map(function (_ref) {\n      var name = _ref.name,\n          value = _ref.value;\n      var argumentPrefix = name ? \"\".concat(name, \": \") : \"\";\n      var typeString = \" (type: \".concat(Codec.Format.Types.typeStringWithoutLocation(value.type), \")\");\n      return (DebugUtils.formatValue(value, argumentPrefix.length) + typeString + \",\").split(/\\r?\\n/g).map(function (line) {\n        return \" \".repeat(indent) + line;\n      }).join(OS.EOL);\n    });\n    return [prefix].concat(_toConsumableArray(formattedValues), [\")\"]).join(OS.EOL);\n  },\n  formatStacktrace: function formatStacktrace(stacktrace) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    //get message or panic code from stacktrace\n    var _stacktrace$ = stacktrace[0],\n        message = _stacktrace$.message,\n        panic = _stacktrace$.panic,\n        custom = _stacktrace$.custom; //we want to print inner to outer, so first, let's\n    //reverse\n\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n\n    var lines = stacktrace.map(function (_ref2) {\n      var functionName = _ref2.functionName,\n          contractName = _ref2.contractName,\n          address = _ref2.address,\n          location = _ref2.location,\n          type = _ref2.type;\n      var name;\n\n      if (contractName && functionName) {\n        name = \"\".concat(contractName, \".\").concat(functionName);\n      } else if (contractName) {\n        name = contractName;\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n\n      var locationString;\n\n      if (location) {\n        var sourcePath = location.source.sourcePath,\n            _location$sourceRange = location.sourceRange.lines.start,\n            line = _location$sourceRange.line,\n            column = _location$sourceRange.column;\n        locationString = sourcePath ? \"\".concat(sourcePath, \":\").concat(line + 1, \":\").concat(column + 1) //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n\n      var addressString = type === \"external\" ? address !== undefined ? \" [address \".concat(address, \"]\") : \" [unknown address]\" : \"\";\n      return \"at \".concat(name).concat(addressString, \" (\").concat(locationString, \")\");\n    });\n    var status = stacktrace[0].status;\n\n    if (status != undefined) {\n      var statusLine;\n\n      if (message !== undefined) {\n        statusLine = status ? \"Error: Improper return (caused message: \".concat(message, \")\") : \"Error: Revert (message: \".concat(message, \")\");\n      } else if (panic !== undefined) {\n        statusLine = status ? \"Panic: Improper return (caused \".concat(DebugUtils.panicString(panic).toLowerCase(), \" (code 0x\").concat(panic.toString(16), \"))\") : \"Panic: \".concat(DebugUtils.panicString(panic), \" (code 0x\").concat(panic.toString(16), \")\");\n      } else if (custom !== undefined) {\n        statusLine = status ? \"Error: Improper return (caused custom error)\" : \"Error: Revert (custom error)\";\n      } else {\n        statusLine = status ? \"Error: Improper return (may be an unexpected self-destruct)\" : \"Error: Revert or exceptional halt\";\n      }\n\n      lines.unshift(statusLine);\n    }\n\n    var indented = lines.map(function (line, index) {\n      return index === 0 ? line : \" \".repeat(indent) + line;\n    });\n    return indented.join(OS.EOL);\n  },\n  colorize: function colorize(code) {\n    var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Solidity\";\n    var options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false //NOTE: you might think you should pass highlight: true,\n      //but you'd be wrong!  I don't understand this either\n\n    };\n\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n\n        return chromafi(code, options);\n\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n\n        return chromafi(code, options);\n\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n  //HACK\n  cleanThis: function cleanThis(variables, replacement) {\n    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(variables).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          variable = _ref4[0],\n          value = _ref4[1];\n\n      return variable === \"this\" ? _defineProperty({}, replacement, value) : _defineProperty({}, variable, value);\n    }))));\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: function () {\n    var _getTransactionSourcesBeforeStarting = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(bugger) {\n      var _ref7;\n\n      var sources, controller, source, compilationId, id, internal;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return bugger.reset();\n\n            case 2:\n              sources = {};\n              controller = bugger.selectors.controller;\n\n            case 4:\n              if (bugger.view(controller.current.trace.finished)) {\n                _context.next = 12;\n                break;\n              }\n\n              source = bugger.view(controller.current.location.source);\n              compilationId = source.compilationId, id = source.id, internal = source.internal; //stepInto should skip internal sources, but there still might be\n              //one at the end\n\n              if (!internal && compilationId !== undefined && id !== undefined) {\n                sources[compilationId] = _objectSpread({}, sources[compilationId], _defineProperty({}, id, source));\n              }\n\n              _context.next = 10;\n              return bugger.stepInto();\n\n            case 10:\n              _context.next = 4;\n              break;\n\n            case 12:\n              _context.next = 14;\n              return bugger.reset();\n\n            case 14:\n              return _context.abrupt(\"return\", (_ref7 = []).concat.apply(_ref7, _toConsumableArray(Object.values(sources).map(Object.values))));\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function getTransactionSourcesBeforeStarting(_x) {\n      return _getTransactionSourcesBeforeStarting.apply(this, arguments);\n    }\n\n    return getTransactionSourcesBeforeStarting;\n  }()\n};\nmodule.exports = DebugUtils;","map":null,"metadata":{},"sourceType":"script"}