{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nexport var toStringMethod = Symbol('fast-check/toStringMethod');\nexport function hasToStringMethod(instance) {\n  return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && toStringMethod in instance && typeof instance[toStringMethod] === 'function';\n}\nexport var asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');\nexport function hasAsyncToStringMethod(instance) {\n  return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === 'function';\n}\nvar findSymbolNameRegex = /^Symbol\\((.*)\\)$/;\n\nfunction getSymbolDescription(s) {\n  if (s.description !== undefined) return s.description;\n  var m = findSymbolNameRegex.exec(String(s));\n  return m && m[1].length ? m[1] : null;\n}\n\nfunction stringifyNumber(numValue) {\n  switch (numValue) {\n    case 0:\n      return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';\n\n    case Number.NEGATIVE_INFINITY:\n      return 'Number.NEGATIVE_INFINITY';\n\n    case Number.POSITIVE_INFINITY:\n      return 'Number.POSITIVE_INFINITY';\n\n    default:\n      return numValue === numValue ? String(numValue) : 'Number.NaN';\n  }\n}\n\nfunction isSparseArray(arr) {\n  var previousNumberedIndex = -1;\n\n  for (var index in arr) {\n    var numberedIndex = Number(index);\n    if (numberedIndex !== previousNumberedIndex + 1) return true;\n    previousNumberedIndex = numberedIndex;\n  }\n\n  return previousNumberedIndex + 1 !== arr.length;\n}\n\nexport function stringifyInternal(value, previousValues, getAsyncContent) {\n  var currentValues = previousValues.concat([value]);\n\n  if (typeof value === 'object') {\n    if (previousValues.indexOf(value) !== -1) {\n      return '[cyclic]';\n    }\n  }\n\n  if (hasAsyncToStringMethod(value)) {\n    var content = getAsyncContent(value);\n\n    if (content.state === 'fulfilled') {\n      return content.value;\n    }\n  }\n\n  if (hasToStringMethod(value)) {\n    try {\n      return value[toStringMethod]();\n    } catch (err) {}\n  }\n\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Array]':\n      {\n        var arr = value;\n\n        if (arr.length >= 50 && isSparseArray(arr)) {\n          var assignments = [];\n\n          for (var index in arr) {\n            if (!Number.isNaN(Number(index))) assignments.push(\"\".concat(index, \":\").concat(stringifyInternal(arr[index], currentValues, getAsyncContent)));\n          }\n\n          return assignments.length !== 0 ? \"Object.assign(Array(\".concat(arr.length, \"),{\").concat(assignments.join(','), \"})\") : \"Array(\".concat(arr.length, \")\");\n        }\n\n        var stringifiedArray = arr.map(function (v) {\n          return stringifyInternal(v, currentValues, getAsyncContent);\n        }).join(',');\n        return arr.length === 0 || arr.length - 1 in arr ? \"[\".concat(stringifiedArray, \"]\") : \"[\".concat(stringifiedArray, \",]\");\n      }\n\n    case '[object BigInt]':\n      return \"\".concat(value, \"n\");\n\n    case '[object Boolean]':\n      return typeof value === 'boolean' ? JSON.stringify(value) : \"new Boolean(\".concat(JSON.stringify(value), \")\");\n\n    case '[object Date]':\n      {\n        var d = value;\n        return Number.isNaN(d.getTime()) ? \"new Date(NaN)\" : \"new Date(\".concat(JSON.stringify(d.toISOString()), \")\");\n      }\n\n    case '[object Map]':\n      return \"new Map(\".concat(stringifyInternal(Array.from(value), currentValues, getAsyncContent), \")\");\n\n    case '[object Null]':\n      return \"null\";\n\n    case '[object Number]':\n      return typeof value === 'number' ? stringifyNumber(value) : \"new Number(\".concat(stringifyNumber(Number(value)), \")\");\n\n    case '[object Object]':\n      {\n        try {\n          var toStringAccessor = value.toString;\n\n          if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {\n            return value.toString();\n          }\n        } catch (err) {\n          return '[object Object]';\n        }\n\n        var mapper = function mapper(k) {\n          return \"\".concat(k === '__proto__' ? '[\"__proto__\"]' : typeof k === 'symbol' ? \"[\".concat(stringifyInternal(k, currentValues, getAsyncContent), \"]\") : JSON.stringify(k), \":\").concat(stringifyInternal(value[k], currentValues, getAsyncContent));\n        };\n\n        var stringifiedProperties = [].concat(_toConsumableArray(Object.keys(value).map(mapper)), _toConsumableArray(Object.getOwnPropertySymbols(value).filter(function (s) {\n          var descriptor = Object.getOwnPropertyDescriptor(value, s);\n          return descriptor && descriptor.enumerable;\n        }).map(mapper)));\n        var rawRepr = '{' + stringifiedProperties.join(',') + '}';\n\n        if (Object.getPrototypeOf(value) === null) {\n          return rawRepr === '{}' ? 'Object.create(null)' : \"Object.assign(Object.create(null),\".concat(rawRepr, \")\");\n        }\n\n        return rawRepr;\n      }\n\n    case '[object Set]':\n      return \"new Set(\".concat(stringifyInternal(Array.from(value), currentValues, getAsyncContent), \")\");\n\n    case '[object String]':\n      return typeof value === 'string' ? JSON.stringify(value) : \"new String(\".concat(JSON.stringify(value), \")\");\n\n    case '[object Symbol]':\n      {\n        var s = value;\n\n        if (Symbol.keyFor(s) !== undefined) {\n          return \"Symbol.for(\".concat(JSON.stringify(Symbol.keyFor(s)), \")\");\n        }\n\n        var desc = getSymbolDescription(s);\n\n        if (desc === null) {\n          return 'Symbol()';\n        }\n\n        var knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];\n        return s === knownSymbol ? desc : \"Symbol(\".concat(JSON.stringify(desc), \")\");\n      }\n\n    case '[object Promise]':\n      {\n        var promiseContent = getAsyncContent(value);\n\n        switch (promiseContent.state) {\n          case 'fulfilled':\n            return \"Promise.resolve(\".concat(stringifyInternal(promiseContent.value, currentValues, getAsyncContent), \")\");\n\n          case 'rejected':\n            return \"Promise.reject(\".concat(stringifyInternal(promiseContent.value, currentValues, getAsyncContent), \")\");\n\n          case 'pending':\n            return \"new Promise(() => {/*pending*/})\";\n\n          case 'unknown':\n          default:\n            return \"new Promise(() => {/*unknown*/})\";\n        }\n      }\n\n    case '[object Error]':\n      if (value instanceof Error) {\n        return \"new Error(\".concat(stringifyInternal(value.message, currentValues, getAsyncContent), \")\");\n      }\n\n      break;\n\n    case '[object Undefined]':\n      return \"undefined\";\n\n    case '[object Int8Array]':\n    case '[object Uint8Array]':\n    case '[object Uint8ClampedArray]':\n    case '[object Int16Array]':\n    case '[object Uint16Array]':\n    case '[object Int32Array]':\n    case '[object Uint32Array]':\n    case '[object Float32Array]':\n    case '[object Float64Array]':\n    case '[object BigInt64Array]':\n    case '[object BigUint64Array]':\n      {\n        if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {\n          return \"Buffer.from(\".concat(stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent), \")\");\n        }\n\n        var valuePrototype = Object.getPrototypeOf(value);\n        var className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;\n\n        if (typeof className === 'string') {\n          var typedArray = value;\n          var valuesFromTypedArr = typedArray.values();\n          return \"\".concat(className, \".from(\").concat(stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent), \")\");\n        }\n\n        break;\n      }\n  }\n\n  try {\n    return value.toString();\n  } catch (_a) {\n    return Object.prototype.toString.call(value);\n  }\n}\nexport function stringify(value) {\n  return stringifyInternal(value, [], function () {\n    return {\n      state: 'unknown',\n      value: undefined\n    };\n  });\n}\nexport function possiblyAsyncStringify(value) {\n  var stillPendingMarker = Symbol();\n  var pendingPromisesForCache = [];\n  var cache = new Map();\n\n  function createDelay0() {\n    var handleId = null;\n\n    var cancel = function cancel() {\n      if (handleId !== null) {\n        clearTimeout(handleId);\n      }\n    };\n\n    var delay = new Promise(function (resolve) {\n      handleId = setTimeout(function () {\n        handleId = null;\n        resolve(stillPendingMarker);\n      }, 0);\n    });\n    return {\n      delay: delay,\n      cancel: cancel\n    };\n  }\n\n  var unknownState = {\n    state: 'unknown',\n    value: undefined\n  };\n\n  var getAsyncContent = function getAsyncContent(data) {\n    var cacheKey = data;\n\n    if (cache.has(cacheKey)) {\n      return cache.get(cacheKey);\n    }\n\n    var delay0 = createDelay0();\n    var p = asyncToStringMethod in data ? Promise.resolve().then(function () {\n      return data[asyncToStringMethod]();\n    }) : data;\n    p.catch(function () {});\n    pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then(function (successValue) {\n      if (successValue === stillPendingMarker) cache.set(cacheKey, {\n        state: 'pending',\n        value: undefined\n      });else cache.set(cacheKey, {\n        state: 'fulfilled',\n        value: successValue\n      });\n      delay0.cancel();\n    }, function (errorValue) {\n      cache.set(cacheKey, {\n        state: 'rejected',\n        value: errorValue\n      });\n      delay0.cancel();\n    }));\n    cache.set(cacheKey, unknownState);\n    return unknownState;\n  };\n\n  function loop() {\n    var stringifiedValue = stringifyInternal(value, [], getAsyncContent);\n\n    if (pendingPromisesForCache.length === 0) {\n      return stringifiedValue;\n    }\n\n    return Promise.all(pendingPromisesForCache.splice(0)).then(loop);\n  }\n\n  return loop();\n}\nexport function asyncStringify(_x) {\n  return _asyncStringify.apply(this, arguments);\n}\n\nfunction _asyncStringify() {\n  _asyncStringify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", Promise.resolve(possiblyAsyncStringify(value)));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _asyncStringify.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}