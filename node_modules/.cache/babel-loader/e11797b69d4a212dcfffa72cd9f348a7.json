{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar Simple = require('./simple');\n\nvar Decoder = require('./decoder');\n\nvar constants = require('./constants');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar NoFilter = require('nofilter');\n\nvar MT = constants.MT;\nvar NUMBYTES = constants.NUMBYTES;\nvar SYMS = constants.SYMS;\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's';\n  } else {\n    return '';\n  }\n}\n/**\n * Generate the expanded format of RFC 7049, section 2.2.1\n *\n * @extends {stream.Transform}\n */\n\n\nvar Commented = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(Commented, _stream$Transform);\n\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {object} [options={}] - Stream options\n   * @param {number} [options.max_depth=10] - how many times to indent\n   *   the dashes\n   * @param {number} [options.depth=1] - initial indentation depth\n   * @param {boolean} [options.no_summary=false] - if true, omit the summary\n   *   of the full bytes read at the end\n   */\n  function Commented(options) {\n    var _this;\n\n    _classCallCheck(this, Commented);\n\n    var opts = Object.assign({\n      depth: 1,\n      max_depth: 10,\n      no_summary: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    var max_depth = opts.max_depth;\n    delete opts.max_depth;\n    var depth = opts.depth;\n    delete opts.depth;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Commented).call(this, opts));\n    _this.depth = depth;\n    _this.max_depth = max_depth;\n    _this.all = new NoFilter();\n    opts.tags = {\n      24: _this._tag_24.bind(_assertThisInitialized(_assertThisInitialized(_this)))\n    };\n    _this.parser = new Decoder(opts);\n\n    _this.parser.on('value', _this._on_value.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('start', _this._on_start.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('start-string', _this._on_start_string.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('stop', _this._on_stop.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('more-bytes', _this._on_more.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('error', _this._on_error.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    if (!opts.no_summary) {\n      _this.parser.on('data', _this._on_data.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n    }\n\n    _this.parser.bs.on('read', _this._on_read.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  _createClass(Commented, [{\n    key: \"_tag_24\",\n    value: function _tag_24(v) {\n      var _this2 = this;\n\n      var c = new Commented({\n        depth: this.depth + 1,\n        no_summary: true\n      });\n      c.on('data', function (b) {\n        return _this2.push(b);\n      });\n      c.on('error', function (er) {\n        return _this2.emit('error', er);\n      });\n      c.end(v);\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(fresh, encoding, cb) {\n      this.parser.write(fresh, encoding, cb);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_flush\",\n    value: function _flush(cb) {\n      // TODO: find the test that covers this, and look at the return value\n      return this.parser._flush(cb);\n    }\n    /**\n     * @callback commentCallback\n     * @param {Error} [error] - if one was generated\n     * @param {string} [commented] - the comment string\n     */\n\n    /**\n     * @typedef CommentOptions\n     * @property {number} [max_depth=10] how many times to indent the dashes\n     * @property {string} [encoding='hex'] encoding of the input\n     */\n\n    /**\n     * Comment on an input Buffer or string, creating a string passed to the\n     * callback.  If callback not specified, a promise is returned.\n     *\n     * @static\n     * @param {string|Buffer} input\n     * @param {CommentOptions|commentCallback|string} [options] or callback\n     * @param {commentCallback=} cb\n     * @returns {Promise} if cb not specified\n     */\n\n  }, {\n    key: \"_on_error\",\n\n    /**\n     * @private\n     */\n    value: function _on_error(er) {\n      this.push('ERROR: ');\n      this.push(er.toString());\n      this.push('\\n');\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_on_read\",\n    value: function _on_read(buf) {\n      this.all.write(buf);\n      var hex = buf.toString('hex');\n      this.push(new Array(this.depth + 1).join('  '));\n      this.push(hex);\n      var ind = (this.max_depth - this.depth) * 2;\n      ind -= hex.length;\n\n      if (ind < 1) {\n        ind = 1;\n      }\n\n      this.push(new Array(ind + 1).join(' '));\n      return this.push('-- ');\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_on_more\",\n    value: function _on_more(mt, len, parent_mt, pos) {\n      this.depth++;\n      var desc = '';\n\n      switch (mt) {\n        case MT.POS_INT:\n          desc = 'Positive number,';\n          break;\n\n        case MT.NEG_INT:\n          desc = 'Negative number,';\n          break;\n\n        case MT.ARRAY:\n          desc = 'Array, length';\n          break;\n\n        case MT.MAP:\n          desc = 'Map, count';\n          break;\n\n        case MT.BYTE_STRING:\n          desc = 'Bytes, length';\n          break;\n\n        case MT.UTF8_STRING:\n          desc = 'String, length';\n          break;\n\n        case MT.SIMPLE_FLOAT:\n          if (len === 1) {\n            desc = 'Simple value,';\n          } else {\n            desc = 'Float,';\n          }\n\n          break;\n      }\n\n      return this.push(desc + ' next ' + len + ' byte' + plural(len) + '\\n');\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_on_start_string\",\n    value: function _on_start_string(mt, tag, parent_mt, pos) {\n      this.depth++;\n      var desc = '';\n\n      switch (mt) {\n        case MT.BYTE_STRING:\n          desc = 'Bytes, length: ' + tag;\n          break;\n\n        case MT.UTF8_STRING:\n          desc = 'String, length: ' + tag.toString();\n          break;\n      }\n\n      return this.push(desc + '\\n');\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_on_start\",\n    value: function _on_start(mt, tag, parent_mt, pos) {\n      this.depth++;\n\n      if (tag !== SYMS.BREAK) {\n        switch (parent_mt) {\n          case MT.ARRAY:\n            this.push(\"[\".concat(pos, \"], \"));\n            break;\n\n          case MT.MAP:\n            if (pos % 2) {\n              this.push(\"{Val:\".concat(Math.floor(pos / 2), \"}, \"));\n            } else {\n              this.push(\"{Key:\".concat(Math.floor(pos / 2), \"}, \"));\n            }\n\n            break;\n        }\n      }\n\n      switch (mt) {\n        case MT.TAG:\n          this.push(\"Tag #\".concat(tag));\n\n          if (tag == 24) {\n            this.push(' Encoded CBOR data item');\n          }\n\n          break;\n\n        case MT.ARRAY:\n          if (tag === SYMS.STREAM) {\n            this.push('Array (streaming)');\n          } else {\n            this.push(\"Array, \".concat(tag, \" item\").concat(plural(tag)));\n          }\n\n          break;\n\n        case MT.MAP:\n          if (tag === SYMS.STREAM) {\n            this.push('Map (streaming)');\n          } else {\n            this.push(\"Map, \".concat(tag, \" pair\").concat(plural(tag)));\n          }\n\n          break;\n\n        case MT.BYTE_STRING:\n          this.push('Bytes (streaming)');\n          break;\n\n        case MT.UTF8_STRING:\n          this.push('String (streaming)');\n          break;\n      }\n\n      return this.push('\\n');\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_on_stop\",\n    value: function _on_stop(mt) {\n      return this.depth--;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_on_value\",\n    value: function _on_value(val, parent_mt, pos, ai) {\n      if (val !== SYMS.BREAK) {\n        switch (parent_mt) {\n          case MT.ARRAY:\n            this.push(\"[\".concat(pos, \"], \"));\n            break;\n\n          case MT.MAP:\n            if (pos % 2) {\n              this.push(\"{Val:\".concat(Math.floor(pos / 2), \"}, \"));\n            } else {\n              this.push(\"{Key:\".concat(Math.floor(pos / 2), \"}, \"));\n            }\n\n            break;\n        }\n      }\n\n      if (val === SYMS.BREAK) {\n        this.push('BREAK\\n');\n      } else if (val === SYMS.NULL) {\n        this.push('null\\n');\n      } else if (val === SYMS.UNDEFINED) {\n        this.push('undefined\\n');\n      } else if (typeof val === 'string') {\n        this.depth--;\n\n        if (val.length > 0) {\n          this.push(JSON.stringify(val));\n          this.push('\\n');\n        }\n      } else if (Buffer.isBuffer(val)) {\n        this.depth--;\n\n        if (val.length > 0) {\n          this.push(val.toString('hex'));\n          this.push('\\n');\n        }\n      } else if (val instanceof bignumber) {\n        this.push(val.toString());\n        this.push('\\n');\n      } else {\n        this.push(util.inspect(val));\n        this.push('\\n');\n      }\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          this.depth--;\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_on_data\",\n    value: function _on_data() {\n      this.push('0x');\n      this.push(this.all.read().toString('hex'));\n      return this.push('\\n');\n    }\n  }], [{\n    key: \"comment\",\n    value: function comment(input, options, cb) {\n      if (input == null) {\n        throw new Error('input required');\n      }\n\n      var encoding = typeof input === 'string' ? 'hex' : void 0;\n      var max_depth = 10;\n\n      switch (typeof options) {\n        case 'function':\n          cb = options;\n          break;\n\n        case 'string':\n          encoding = options;\n          break;\n\n        case 'number':\n          max_depth = options;\n          break;\n\n        case 'object':\n          var ref1 = options.encoding;\n          var ref2 = options.max_depth;\n          encoding = ref1 != null ? ref1 : encoding;\n          max_depth = ref2 != null ? ref2 : max_depth;\n          break;\n\n        case 'undefined':\n          break;\n\n        default:\n          throw new Error('Unknown option type');\n      }\n\n      var bs = new NoFilter();\n      var d = new Commented({\n        max_depth: max_depth\n      });\n      var p = null;\n\n      if (typeof cb === 'function') {\n        d.on('end', function () {\n          cb(null, bs.toString('utf8'));\n        });\n        d.on('error', cb);\n      } else {\n        p = new Promise(function (resolve, reject) {\n          d.on('end', function () {\n            resolve(bs.toString('utf8'));\n          });\n          return d.on('error', reject);\n        });\n      }\n\n      d.pipe(bs);\n      d.end(input, encoding);\n      return p;\n    }\n  }]);\n\n  return Commented;\n}(stream.Transform);\n\nmodule.exports = Commented;","map":null,"metadata":{},"sourceType":"script"}