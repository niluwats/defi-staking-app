{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:allocate\");\nexports.Utils = __importStar(require(\"./utils\"));\n\nvar Import = __importStar(require(\"../import\"));\n\nvar AbiDataUtils = __importStar(require(\"../utils\"));\n\nvar Web3Utils = require(\"web3-utils\"); //sorry for untyped import\n\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar Common = __importStar(require(\"../../common\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Ast = __importStar(require(\"../../ast\"));\n\nvar import_1 = require(\"../../contexts/import\");\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\n\nexports.FallbackOutputAllocation = {\n  kind: \"returnmessage\",\n  selector: new Uint8Array(),\n  allocationMode: \"full\"\n};\n\nfunction getAbiAllocations(userDefinedTypes) {\n  var allocations = {};\n\n  for (var _i = 0, _Object$values = Object.values(userDefinedTypes); _i < _Object$values.length; _i++) {\n    var dataType = _Object$values[_i];\n\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getAbiAllocations = getAbiAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n} //note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\n\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n  var start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var dynamic = false; //note that we will mutate the start argument also!\n  //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  var allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n\n  var memberAllocations = [];\n\n  var _iterator = _createForOfIteratorHelper(members),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var member = _step.value;\n      var length = void 0;\n      var dynamicMember = void 0;\n\n      var _abiSizeAndAllocate = abiSizeAndAllocate(member.type, userDefinedTypes, allocations);\n\n      length = _abiSizeAndAllocate.size;\n      dynamicMember = _abiSizeAndAllocate.dynamic;\n      allocations = _abiSizeAndAllocate.allocations;\n\n      //vomit on illegal types in calldata -- note the short-circuit!\n      if (length === undefined) {\n        allocations[parentId] = null;\n        return allocations;\n      }\n\n      var pointer = {\n        location: \"abi\",\n        start: start,\n        length: length\n      };\n      memberAllocations.push({\n        name: member.name,\n        type: member.type,\n        pointer: pointer\n      });\n      start += length;\n      dynamic = dynamic || dynamicMember;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    length: dynamic ? Evm.Utils.WORD_SIZE : start,\n    dynamic: dynamic\n  };\n  return allocations;\n} //first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\n\n\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  switch (dataType.typeClass) {\n    case \"bool\":\n    case \"address\":\n    case \"contract\":\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n    case \"enum\":\n    case \"userDefinedValueType\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: false,\n        allocations: existingAllocations\n      };\n\n    case \"string\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: true,\n        allocations: existingAllocations\n      };\n\n    case \"bytes\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: dataType.kind === \"dynamic\",\n        allocations: existingAllocations\n      };\n\n    case \"mapping\":\n      return {\n        allocations: existingAllocations\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            size: Evm.Utils.WORD_SIZE,\n            dynamic: false,\n            allocations: existingAllocations\n          };\n\n        case \"internal\":\n          return {\n            allocations: existingAllocations\n          };\n      }\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: Evm.Utils.WORD_SIZE,\n              dynamic: true,\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            if (dataType.length.isZero()) {\n              //arrays of length 0 are static regardless of base type\n              return {\n                size: 0,\n                dynamic: false,\n                allocations: existingAllocations\n              };\n            }\n\n            var _abiSizeAndAllocate2 = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),\n                baseSize = _abiSizeAndAllocate2.size,\n                dynamic = _abiSizeAndAllocate2.dynamic,\n                allocations = _abiSizeAndAllocate2.allocations;\n\n            return {\n              //WARNING!  The use of toNumber() here may throw an exception!\n              //I'm judging this OK since if you have arrays that large we have bigger problems :P\n              size: dataType.length.toNumber() * baseSize,\n              dynamic: dynamic,\n              allocations: allocations\n            };\n        }\n      }\n\n    case \"struct\":\n      {\n        var _allocations = existingAllocations;\n        var allocation = _allocations[dataType.id];\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          var storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          _allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = _allocations[storedType.id];\n        } //having found our allocation, if it's not null, we can just look up its size and dynamicity\n\n\n        if (allocation !== null) {\n          return {\n            size: allocation.length,\n            dynamic: allocation.dynamic,\n            allocations: _allocations\n          };\n        } //if it is null, this type doesn't go in the abi\n        else {\n            return {\n              allocations: _allocations\n            };\n          }\n      }\n\n    case \"tuple\":\n      {\n        //Warning! Yucky wasteful recomputation here!\n        var size = 0;\n        var _dynamic = false; //note that we don't just invoke allocateStruct here!\n        //why not? because it has no ID to store the result in!\n        //and we can't use a fake like -1 because there might be a recursive call to it,\n        //and then the results would overwrite each other\n        //I mean, we could do some hashing thing or something, but I think it's easier to just\n        //copy the logic in this one case (sorry)\n\n        var _iterator2 = _createForOfIteratorHelper(dataType.memberTypes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var member = _step2.value;\n\n            var _abiSizeAndAllocate3 = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations),\n                memberSize = _abiSizeAndAllocate3.size,\n                memberDynamic = _abiSizeAndAllocate3.dynamic;\n\n            size += memberSize;\n            _dynamic = _dynamic || memberDynamic;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return {\n          size: size,\n          dynamic: _dynamic,\n          allocations: existingAllocations\n        };\n      }\n  }\n} //assumes you've already done allocation! don't use if you haven't!\n\n/**\n * @protected\n */\n\n\nfunction abiSizeInfo(dataType, allocations) {\n  var _abiSizeAndAllocate4 = abiSizeAndAllocate(dataType, null, allocations),\n      size = _abiSizeAndAllocate4.size,\n      dynamic = _abiSizeAndAllocate4.dynamic; //the above line should work fine... as long as allocation is already done!\n  //the middle argument, userDefinedTypes, is only needed during allocation\n  //again, this function is only for use if allocation is done, so it's safe to pass null here\n\n\n  return {\n    size: size,\n    dynamic: dynamic\n  };\n}\n\nexports.abiSizeInfo = abiSizeInfo; //allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\n\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n  //first: determine the corresponding function node\n  //(simultaneously: determine the offset)\n  var node = undefined;\n  var inputParametersFull;\n  var outputParametersFull;\n  var inputParametersAbi;\n  var outputParametersAbi;\n  var offset; //refers to INPUT offset; output offset is always 0\n\n  debug(\"allocating calldata and returndata\");\n\n  switch (abiEntry.type) {\n    case \"constructor\":\n      if (!constructorContext) {\n        return undefined;\n      }\n\n      var rawLength = constructorContext.binary.length;\n      offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n      //for a constructor, we only want to search the particular contract\n\n      if (contractNode) {\n        node = contractNode.nodes.find(function (functionNode) {\n          return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a function node, but then it will\n          //return false (well, unless it's a getter node!)\n          abiEntry, functionNode, referenceDeclarations);\n        });\n      } //if we can't find it, we'll handle this below\n\n\n      break;\n\n    case \"function\":\n      offset = Evm.Utils.SELECTOR_SIZE; //search through base contracts, from most derived (left) to most base (right)\n\n      if (contractNode) {\n        var linearizedBaseContracts = contractNode.linearizedBaseContracts;\n        debug(\"linearized: %O\", linearizedBaseContracts);\n        node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, function (functionNode) {\n          return AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations);\n        }, contractNode).node; //may be undefined!  that's OK!\n\n        debug(\"found node: %o\", Boolean(node));\n      }\n\n      break;\n  } //now: get the parameters (both full-mode & ABI)\n\n\n  if (node) {\n    switch (node.nodeType) {\n      case \"FunctionDefinition\":\n        //normal case\n        inputParametersFull = node.parameters.parameters;\n        outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n\n        break;\n\n      case \"VariableDeclaration\":\n        //getter case\n        var _Ast$Utils$getterPara = Ast.Utils.getterParameters(node, referenceDeclarations);\n\n        inputParametersFull = _Ast$Utils$getterPara.inputs;\n        outputParametersFull = _Ast$Utils$getterPara.outputs;\n        break;\n    }\n  } else {\n    inputParametersFull = undefined;\n    outputParametersFull = undefined;\n  }\n\n  inputParametersAbi = abiEntry.inputs;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputParametersAbi = abiEntry.outputs;\n      break;\n\n    case \"constructor\":\n      //we just leave this empty for constructors\n      outputParametersAbi = [];\n      break;\n  } //now: do the allocation!\n\n\n  var _allocateDataArgument = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset),\n      abiAllocationInput = _allocateDataArgument.allocation,\n      inputMode = _allocateDataArgument.mode;\n\n  var _allocateDataArgument2 = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler //note no offset\n  ),\n      abiAllocationOutput = _allocateDataArgument2.allocation,\n      outputMode = _allocateDataArgument2.mode;\n\n  debug(\"modes: %s in, %s out\", inputMode, outputMode); //finally: transform the allocation appropriately\n\n  var inputArgumentsAllocation = abiAllocationInput.members.map(function (member) {\n    return Object.assign(Object.assign({}, member), {\n      pointer: {\n        location: \"calldata\",\n        start: member.pointer.start,\n        length: member.pointer.length\n      }\n    });\n  });\n  var outputArgumentsAllocation = abiAllocationOutput.members.map(function (member) {\n    return Object.assign(Object.assign({}, member), {\n      pointer: {\n        location: \"returndata\",\n        start: member.pointer.start,\n        length: member.pointer.length\n      }\n    });\n  });\n  var inputsAllocation = {\n    abi: abiEntry,\n    offset: offset,\n    arguments: inputArgumentsAllocation,\n    allocationMode: inputMode\n  };\n  var outputsAllocation;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputsAllocation = {\n        selector: new Uint8Array(),\n        arguments: outputArgumentsAllocation,\n        allocationMode: outputMode,\n        kind: \"return\"\n      };\n      break;\n\n    case \"constructor\":\n      outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n      break;\n  }\n\n  return {\n    input: inputsAllocation,\n    output: outputsAllocation\n  }; //TS chokes on this for some reason\n} //note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\n\n\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  var offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n\n  var parameterTypes;\n  var abiAllocation;\n\n  if (allocationMode === \"full\") {\n    var id = \"-1\"; //fake ID that doesn't matter\n\n    parameterTypes = fullModeParameters.map(function (parameter) {\n      return {\n        name: parameter.name,\n        type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n\n      };\n    });\n    debug(\"parameterTypes: %O\", parameterTypes); //now: perform the allocation!\n\n    try {\n      abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    } catch (_a) {\n      //if something goes wrong, switch to ABI mdoe\n      debug(\"falling back to ABI due to exception!\");\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    //this is the ABI case.  we end up here EITHER\n    //if node doesn't exist, OR if something went wrong\n    //during allocation\n    var _id = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiParameters.map(function (parameter) {\n      return {\n        name: parameter.name,\n        type: Import.abiParameterToType(parameter)\n      };\n    });\n    abiAllocation = allocateMembers(_id, parameterTypes, userDefinedTypes, abiAllocations, offset)[_id];\n  }\n\n  return {\n    allocation: abiAllocation,\n    mode: allocationMode\n  };\n} //allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n\n\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  var parameterTypes;\n  var nodeId;\n  var id; //first: determine the corresponding event node\n  //search through base contracts, from most derived (right) to most base (left)\n\n  var node = undefined;\n  var definedIn = undefined;\n  var allocationMode = \"full\"; //degrade to abi as needed\n\n  debug(\"allocating ABI: %O\", abiEntry);\n\n  if (contractNode) {\n    //first: check same contract for the event\n    node = contractNode.nodes.find(function (eventNode) {\n      return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be an event node, but then it will\n      //return false\n      abiEntry, eventNode, referenceDeclarations);\n    }); //if we found the node, great!  If not...\n\n    if (!node) {\n      debug(\"didn't find node in base contract...\"); //let's search for the node among the base contracts.\n      //but if we find it...\n      //[note: the following code is overcomplicated; it was used\n      //when we were trying to get the actual node, it's overcomplicated\n      //now that we're just determining its presence.  oh well]\n\n      var linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n      linearizedBaseContractsMinusSelf.shift(); //remove self\n\n      debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n      node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, function (eventNode) {\n        return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a event node, but then it will return false\n        abiEntry, eventNode, referenceDeclarations);\n      } //don't pass deriveContractNode here, we're not checking the contract itself\n      ).node; //may be undefined! that's OK!\n\n      if (node) {\n        //...if we find the node in an ancestor, we\n        //deliberately *don't* allocate!  instead such cases\n        //will be handled during a later combination step\n        debug(\"bailing out for later handling!\");\n        debug(\"ABI: %O\", abiEntry);\n        return undefined;\n      }\n    }\n  } //otherwise, leave node undefined\n\n\n  if (node) {\n    debug(\"found node\"); //if we found the node, let's also turn it into a type\n\n    definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here\n    //...and set the ID\n\n    id = import_1.makeTypeId(node.id, compilationId);\n  } else {\n    //if no node, have to fall back into ABI mode\n    debug(\"falling back to ABI because no node\");\n    allocationMode = \"abi\";\n  } //now: construct the list of parameter types, attaching indexedness info\n  //and overall position (for later reconstruction)\n\n\n  var indexed;\n  var nonIndexed;\n  var abiAllocation; //the untransformed allocation for the non-indexed parameters\n\n  if (allocationMode === \"full\") {\n    nodeId = node.id.toString();\n    var parameters = node.parameters.parameters;\n    parameterTypes = parameters.map(function (definition) {\n      return {\n        //note: if node is defined, compiler had better be defined, too!\n        type: Ast.Import.definitionToType(definition, compilationId, compiler),\n        name: definition.name,\n        indexed: definition.indexed\n      };\n    }); //now: split the list of parameters into indexed and non-indexed\n\n    var _lodash_partition_1$d = lodash_partition_1.default(parameterTypes, function (parameter) {\n      return parameter.indexed;\n    });\n\n    var _lodash_partition_1$d2 = _slicedToArray(_lodash_partition_1$d, 2);\n\n    indexed = _lodash_partition_1$d2[0];\n    nonIndexed = _lodash_partition_1$d2[1];\n\n    try {\n      //now: perform the allocation for the non-indexed parameters!\n      abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    } catch (_a) {\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    nodeId = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiEntry.inputs.map(function (abiParameter) {\n      return {\n        type: Import.abiParameterToType(abiParameter),\n        name: abiParameter.name,\n        indexed: abiParameter.indexed\n      };\n    }); //now: split the list of parameters into indexed and non-indexed\n\n    var _lodash_partition_1$d3 = lodash_partition_1.default(parameterTypes, function (parameter) {\n      return parameter.indexed;\n    });\n\n    var _lodash_partition_1$d4 = _slicedToArray(_lodash_partition_1$d3, 2);\n\n    indexed = _lodash_partition_1$d4[0];\n    nonIndexed = _lodash_partition_1$d4[1];\n    //now: perform the allocation for the non-indexed parameters!\n    abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n  } //now: transform the result appropriately\n\n\n  var nonIndexedArgumentsAllocation = abiAllocation.members.map(function (member) {\n    return Object.assign(Object.assign({}, member), {\n      pointer: {\n        location: \"eventdata\",\n        start: member.pointer.start,\n        length: member.pointer.length\n      }\n    });\n  }); //now: allocate the indexed parameters\n\n  var startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n\n  var indexedArgumentsAllocation = indexed.map(function (_ref, position) {\n    var type = _ref.type,\n        name = _ref.name;\n    return {\n      type: type,\n      name: name,\n      pointer: {\n        location: \"eventtopic\",\n        topic: startingTopic + position\n      }\n    };\n  }); //finally: weave these back together\n\n  var argumentsAllocation = [];\n\n  var _iterator3 = _createForOfIteratorHelper(parameterTypes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var parameter = _step3.value;\n      var arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;\n      argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    } //...and return\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return {\n    abi: abiEntry,\n    contextHash: undefined,\n    definedIn: definedIn,\n    id: id,\n    arguments: argumentsAllocation,\n    allocationMode: allocationMode,\n    anonymous: abiEntry.anonymous\n  };\n}\n\nfunction allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  //first: if we got passed just a node & no abi entry,\n  var id = undefined;\n  var definedIn = undefined;\n  var parametersFull = undefined;\n  var parametersAbi = abiEntry.inputs;\n\n  if (errorNode) {\n    //first, set parametersFull\n    parametersFull = errorNode.parameters.parameters; //now, set id\n\n    id = import_1.makeTypeId(errorNode.id, compilationId); //now, set definedIn\n\n    var contractNode = null;\n\n    for (var _i2 = 0, _Object$values2 = Object.values(referenceDeclarations); _i2 < _Object$values2.length; _i2++) {\n      var node = _Object$values2[_i2];\n\n      if (node.nodeType === \"ContractDefinition\") {\n        if (node.nodes.some(function (subNode) {\n          return subNode.id === errorNode.id;\n        })) {\n          contractNode = node;\n          break;\n        }\n      } //if we didn't find it, then contractNode is null\n      //(and thus so will be definedIn)\n\n    }\n\n    if (contractNode === null) {\n      definedIn = null;\n    } else {\n      definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler);\n    }\n  } //otherwise, leave parametersFull, id, and definedIn undefined\n\n\n  var _allocateDataArgument3 = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector\n  ),\n      abiAllocation = _allocateDataArgument3.allocation,\n      allocationMode = _allocateDataArgument3.mode; //finally: transform the allocation appropriately\n\n\n  var argumentsAllocation = abiAllocation.members.map(function (member) {\n    return Object.assign(Object.assign({}, member), {\n      pointer: {\n        location: \"returndata\",\n        start: member.pointer.start,\n        length: member.pointer.length\n      }\n    });\n  });\n  var selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));\n  return {\n    kind: \"revert\",\n    selector: selector,\n    abi: abiEntry,\n    id: id,\n    definedIn: definedIn,\n    arguments: argumentsAllocation,\n    allocationMode: allocationMode\n  };\n}\n\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  var allocations = {\n    constructorAllocation: undefined,\n    //(if it doesn't then it will remain as default)\n    functionAllocations: {}\n  };\n\n  if (!abi) {\n    //if no ABI, can't do much!\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    return allocations;\n  }\n\n  var _iterator4 = _createForOfIteratorHelper(abi),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var abiEntry = _step4.value;\n\n      if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n        //the first of these conditions is a hack workaround for a Solidity bug.\n        //the second of these is because... seriously? we're not handling these\n        //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n        //thankfully)\n        continue;\n      }\n\n      switch (abiEntry.type) {\n        case \"constructor\":\n          allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n          debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n          break;\n\n        case \"function\":\n          allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n          break;\n\n        default:\n          //skip over fallback, error, and event\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  if (!allocations.constructorAllocation) {\n    //set a default constructor allocation if we haven't allocated one yet\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n  }\n\n  return allocations;\n}\n\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n  if (!constructorContext) {\n    return undefined;\n  }\n\n  var rawLength = constructorContext.binary.length;\n  var offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n\n  var input = {\n    offset: offset,\n    abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n    arguments: [],\n    allocationMode: \"full\"\n  };\n  var output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n\n  return {\n    input: input,\n    output: output\n  };\n} //note: context should be deployed context!\n\n\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n  if (!context) {\n    //just return a default abi mode result\n    return {\n      selector: new Uint8Array(),\n      allocationMode: \"abi\",\n      kind: \"bytecode\",\n      delegatecallGuard: false\n    };\n  }\n\n  var immutableReferences = context.immutableReferences,\n      compilationId = context.compilationId,\n      compiler = context.compiler,\n      contractKind = context.contractKind,\n      binary = context.binary;\n  var immutables;\n\n  if (allocationMode === \"full\" && immutableReferences) {\n    if (contractNode) {\n      debug(\"allocating immutables\");\n      immutables = [];\n\n      var _loop = function _loop() {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),\n            id = _Object$entries$_i[0],\n            references = _Object$entries$_i[1];\n\n        if (references.length === 0) {\n          return \"continue\"; //don't allocate immutables that don't exist\n        }\n\n        var astId = parseInt(id); //get the corresponding variable node; potentially fail\n\n        var _findNodeAndContract = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, function (node) {\n          return node.id === astId;\n        }, contractNode),\n            definition = _findNodeAndContract.node,\n            definedIn = _findNodeAndContract.contract;\n\n        if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n          debug(\"didn't find definition for %d!\", astId);\n          allocationMode = \"abi\";\n          immutables = undefined;\n          return \"break\";\n        }\n\n        var definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here\n\n        var dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n        immutables.push({\n          name: definition.name,\n          definedIn: definedInClass,\n          type: dataType,\n          pointer: {\n            location: \"returndata\",\n            start: references[0].start,\n            length: references[0].length\n          }\n        });\n      };\n\n      for (var _i3 = 0, _Object$entries = Object.entries(immutableReferences); _i3 < _Object$entries.length; _i3++) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n        if (_ret === \"break\") break;\n      }\n    } else if (Object.entries(immutableReferences).length > 0) {\n      //if there are immutables, but no contract mode, go to abi mode\n      debug(\"immutables but no node!\");\n      allocationMode = \"abi\";\n    }\n  } else {\n    debug(\"no immutables\");\n  } //now, is there a delegatecall guard?\n\n\n  var delegatecallGuard = false;\n\n  if (contractKind === \"library\") {\n    //note: I am relying on this being present!\n    //(also this part is a bit HACKy)\n    var pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n    var delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n\n    if (binary.startsWith(delegateCallGuardString)) {\n      delegatecallGuard = true;\n    }\n  }\n\n  return {\n    selector: new Uint8Array(),\n    allocationMode: allocationMode,\n    kind: \"bytecode\",\n    immutables: immutables,\n    delegatecallGuard: delegatecallGuard\n  };\n}\n\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  var allocations = {\n    constructorAllocations: {},\n    functionAllocations: {}\n  };\n\n  var _iterator5 = _createForOfIteratorHelper(contracts),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var contract = _step5.value;\n      var contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n\n      if (contract.constructorContext) {\n        allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;\n      }\n\n      if (contract.deployedContext) {\n        allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations; //set this up under both constructor *and* deployed! this is to handle\n        //constructor returndata decoding\n\n        allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return allocations;\n}\n\nexports.getCalldataAllocations = getCalldataAllocations;\n\nfunction getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  var useAst = Boolean(contractNode && contractNode.usedErrors);\n\n  if (useAst) {\n    var errorNodes = contractNode.usedErrors.map(function (errorNodeId) {\n      return referenceDeclarations[errorNodeId];\n    });\n    var abis;\n\n    try {\n      abis = errorNodes.map(function (errorNode) {\n        return Ast.Utils.definitionToAbi(errorNode, referenceDeclarations);\n      });\n    } catch (_a) {\n      useAst = false;\n    }\n\n    if (useAst) {\n      //i.e. if the above operation succeeded\n      return contractNode.usedErrors.map(function (errorNodeId) {\n        return referenceDeclarations[errorNodeId];\n      }).map(function (errorNode, index) {\n        return allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler);\n      });\n    }\n  }\n\n  if (!useAst && abi) {\n    //deliberately *not* an else!\n    return abi.filter(function (abiEntry) {\n      return abiEntry.type === \"error\";\n    }).filter(function (abiEntry) {\n      return !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry);\n    }) //hack workaround\n    .map(function (abiEntry) {\n      return allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler);\n    });\n  } //otherwise just return nothing\n\n\n  return [];\n}\n\nfunction getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  var _ref2;\n\n  var allContexts = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(contracts.map(function (_ref3) {\n    var deployedContext = _ref3.deployedContext,\n        constructorContext = _ref3.constructorContext;\n    return [deployedContext, constructorContext];\n  }))).filter(function (x) {\n    return x;\n  }) //filter out nonexistent contexts\n  .map(function (context) {\n    return context.context;\n  });\n\n  allContexts.push(\"\"); //HACK: add fictional empty-string context to represent no-context\n  //holds allocations for a given context\n\n  var selfAllocations = {}; //holds allocations for *other* contexts\n\n  var additionalAllocations = {}; //now: process the allocations for each contract. we'll add each contract's\n  //allocations to *its* entries in allocations, and to every *other* entry\n  //in additionalAllocations.\n\n  var _iterator6 = _createForOfIteratorHelper(contracts),\n      _step6;\n\n  try {\n    var _loop2 = function _loop2() {\n      var contract = _step6.value;\n      var contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n      var contexts = [//contexts for this contract\n      contract.deployedContext, contract.constructorContext].filter(function (x) {\n        return x;\n      }) //filter out nonexistent contexts\n      .map(function (context) {\n        return context.context;\n      });\n      var otherContexts = allContexts.filter( //contexts for all other contracts\n      function (contextHash) {\n        return !contexts.includes(contextHash);\n      }); //add them to selfAllocations\n\n      var _iterator8 = _createForOfIteratorHelper(contexts),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var contextHash = _step8.value;\n          selfAllocations[contextHash] = contractAllocations;\n        } //add them to additionalAllocations\n\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      var _iterator9 = _createForOfIteratorHelper(otherContexts),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _contextHash = _step9.value;\n\n          if (additionalAllocations[_contextHash] === undefined) {\n            additionalAllocations[_contextHash] = [];\n          }\n\n          additionalAllocations[_contextHash] = additionalAllocations[_contextHash].concat(contractAllocations);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    };\n\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      _loop2();\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  var allocations = Object.assign.apply(Object, [{}].concat(_toConsumableArray(allContexts.map(function (contextHash) {\n    return _defineProperty({}, contextHash, {});\n  })))); //now: perform coalescense!\n\n  var _iterator7 = _createForOfIteratorHelper(contracts),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var contract = _step7.value;\n      //we're setting up contexts again, sorry >_>\n      var contexts = [//contexts for this contract\n      contract.deployedContext, contract.constructorContext].filter(function (x) {\n        return x;\n      }) //filter out nonexistent contexts\n      .map(function (context) {\n        return context.context;\n      });\n\n      var _iterator10 = _createForOfIteratorHelper(contexts),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var contextHash = _step10.value;\n          allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);\n          debug(\"allocations: %O\", allocations[contextHash]);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    } //...also coalesce the fake \"\" context\n\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  allocations[\"\"] = coalesceReturndataAllocations([], additionalAllocations[\"\"] || []);\n  /*\n  for (const [contextHash, contextAllocations] of Object.entries(allAllocations)) {\n    for (const [signature, signatureAllocations] of Object.entries(contextAllocations)) {\n      const selector = Web3Utils.soliditySha3({ type: \"string\", value: signature })\n        .slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n      if (!allocations[contextHash][selector]) {\n        allocations[contextHash][selector] = [];\n      }\n      allocations[contextHash][selector] = allocations[contextHash][selector].concat(signatureAllocations);\n    }\n  }\n  */\n\n  debug(\"error allocations: %O\", allocations);\n  return allocations;\n}\n\nexports.getReturndataAllocations = getReturndataAllocations;\n\nfunction coalesceReturndataAllocations(selfAllocations, additionalAllocations) {\n  var bySelector = {}; //start with the additional allocations; we want to process\n  //the self allocations last, due to special handling of no-ID allocations there\n\n  var _iterator11 = _createForOfIteratorHelper(additionalAllocations),\n      _step11;\n\n  try {\n    var _loop3 = function _loop3() {\n      var allocation = _step11.value;\n      var signature = AbiDataUtils.abiSignature(allocation.abi);\n      var selector = Web3Utils.soliditySha3({\n        type: \"string\",\n        value: signature\n      }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n      if (bySelector[selector]) {\n        //note: at this point, for any given signature, there should only be a\n        //no-ID allocation for that signature if it's the only one\n        if (allocation.id !== undefined) {\n          //delete anything with that signature but w/o an ID, or with this same ID\n          bySelector[selector] = bySelector[selector].filter(function (_ref5) {\n            var abi = _ref5.abi,\n                id = _ref5.id;\n            return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n          }); //add this allocation\n\n          bySelector[selector].push(allocation);\n        } else if (!bySelector[selector].some(function (_ref6) {\n          var abi = _ref6.abi;\n          return AbiDataUtils.abiSignature(abi) === signature;\n        })) {\n          //only add ID-less ones if there isn't anything of that signature already\n          bySelector[selector].push(allocation);\n        }\n      } else {\n        //if there's nothing there thus far, add it\n        bySelector[selector] = [allocation];\n      }\n    };\n\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      _loop3();\n    } //now we're going to perform a modified version of this procedure for the self allocations:\n    //1. we're going to add to the front, not the back\n    //2. we can add an ID-less one even if there are already ones with IDs there\n    //(sorry for the copypaste)\n\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(selfAllocations),\n      _step12;\n\n  try {\n    var _loop4 = function _loop4() {\n      var allocation = _step12.value;\n      var signature = AbiDataUtils.abiSignature(allocation.abi);\n      var selector = Web3Utils.soliditySha3({\n        type: \"string\",\n        value: signature\n      }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n      if (bySelector[selector]) {\n        //delete anything with that signature but w/o an ID, or with this same ID\n        //(if this alloc has no ID, this will only delete ID-less ones :) )\n        bySelector[selector] = bySelector[selector].filter(function (_ref7) {\n          var abi = _ref7.abi,\n              id = _ref7.id;\n          return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n        }); //add this allocation to front, not back!\n\n        bySelector[selector].unshift(allocation);\n      } else {\n        //if there's nothing there thus far, add it\n        bySelector[selector] = [allocation];\n      }\n    };\n\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      _loop4();\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return bySelector;\n}\n\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  return abi.filter(function (abiEntry) {\n    return abiEntry.type === \"event\";\n  }).filter(function (abiEntry) {\n    return !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry);\n  }) //hack workaround\n  .map(function (abiEntry) {\n    return {\n      selector: AbiDataUtils.abiSelector(abiEntry),\n      anonymous: abiEntry.anonymous,\n      topics: AbiDataUtils.topicsCount(abiEntry),\n      allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n    };\n  }); //note we do *not* filter out undefined allocations; we need these as placeholders\n} //note: constructor context is ignored by this function; no need to pass it in\n//WARNING: this function is full of hacks... sorry\n\n\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  //first: do allocations for individual contracts\n  var individualAllocations = {};\n  var groupedAllocations = {};\n  var allocations = {};\n\n  var _iterator13 = _createForOfIteratorHelper(contracts),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var _step13$value = _step13.value,\n          abi = _step13$value.abi,\n          deployedContext = _step13$value.deployedContext,\n          contractNode = _step13$value.contractNode,\n          compilationId = _step13$value.compilationId,\n          compiler = _step13$value.compiler;\n\n      if (!deployedContext && !contractNode) {\n        //we'll need *one* of these two at least\n        continue;\n      }\n\n      var contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n      var key = makeContractKey(deployedContext, contractNode ? contractNode.id : undefined, compilationId);\n\n      if (individualAllocations[key] === undefined) {\n        individualAllocations[key] = {};\n      }\n\n      var _iterator16 = _createForOfIteratorHelper(contractAllocations),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var allocationTemporary = _step16.value;\n          //we'll use selector *even for anonymous* here, because it's just\n          //for determining what overrides what at this point\n          individualAllocations[key][allocationTemporary.selector] = {\n            context: deployedContext,\n            contractNode: contractNode,\n            allocationTemporary: allocationTemporary,\n            compilationId: compilationId\n          };\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n    } //now: put things together for inheritance\n    //note how we always put things in order from most derived to most base\n\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  for (var contextOrId in individualAllocations) {\n    groupedAllocations[contextOrId] = {};\n\n    var _loop5 = function _loop5(selector) {\n      var _individualAllocation = individualAllocations[contextOrId][selector],\n          context = _individualAllocation.context,\n          contractNode = _individualAllocation.contractNode,\n          allocationTemporary = _individualAllocation.allocationTemporary,\n          compilationId = _individualAllocation.compilationId;\n      debug(\"allocationTemporary: %O\", allocationTemporary);\n      var allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations\n      //first, copy from individual allocations\n\n      groupedAllocations[contextOrId][selector] = {\n        context: context,\n        contractNode: contractNode,\n        allocationsTemporary: allocationsTemporary\n      }; //if no contract node, that's all.  if there is...\n\n      if (contractNode) {\n        //...we have to do inheritance processing\n        debug(\"contract Id: %d\", contractNode.id);\n        debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n        var linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n        linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n\n        var _iterator14 = _createForOfIteratorHelper(linearizedBaseContractsMinusSelf),\n            _step14;\n\n        try {\n          var _loop6 = function _loop6() {\n            var baseId = _step14.value;\n            debug(\"checking baseId: %d\", baseId);\n            var baseNode = referenceDeclarations[compilationId][baseId];\n\n            if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n              debug(\"failed to find node for baseId: %d\", baseId);\n              return \"break\"; //not a continue!\n              //if we can't find the base node, it's better to stop the loop,\n              //rather than continue to potentially erroneous things\n            } //note: we're not actually going to *use* the baseNode here.\n            //we're just checking for whether we can *find* it\n            //why? because if we couldn't find it, that means that events defined in\n            //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n\n\n            var baseContractInfo = contracts.find(function (contractAllocationInfo) {\n              return contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId;\n            });\n\n            if (!baseContractInfo) {\n              //similar to above... this failure case can happen when there are\n              //two contracts with the same name and you attempt to use the\n              //artifacts; say you have contracts A, B, and B', where A inherits\n              //from B, and B and B' have the same name, and B' is the one that\n              //gets the artifact; B will end up in reference declarations and so\n              //get found above, but it won't appear in contracts, causing the\n              //problem here.  Unfortunately I don't know any great way to handle this,\n              //so, uh, we treat it as a failure same as above.\n              debug(\"failed to find contract info for baseId: %d\", baseId);\n              return \"break\";\n            }\n\n            var baseContext = baseContractInfo.deployedContext;\n            var baseKey = makeContractKey(baseContext, baseId, compilationId);\n\n            if (individualAllocations[baseKey][selector] !== undefined) {\n              var baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n              debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n\n              if (baseAllocation.allocation) {\n                //don't push undefined!\n                groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n              }\n            }\n          };\n\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var _ret2 = _loop6();\n\n            if (_ret2 === \"break\") break;\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n      }\n    };\n\n    for (var selector in individualAllocations[contextOrId]) {\n      _loop5(selector);\n    }\n  } //finally: transform into final form & return,\n  //filtering out things w/o a context\n\n\n  for (var contractKey in groupedAllocations) {\n    if (!hasContext(contractKey)) {\n      continue; //(this filters out ones that had no context and therefore were\n      //given by ID; we needed these at the previous stage but from\n      //here on they're irrelevant)\n    }\n\n    var contextHash = contextHashForKey(contractKey);\n\n    for (var _selector in groupedAllocations[contextHash]) {\n      var _groupedAllocations$c = groupedAllocations[contextHash][_selector],\n          allocationsTemporary = _groupedAllocations$c.allocationsTemporary,\n          context = _groupedAllocations$c.context;\n\n      var _iterator15 = _createForOfIteratorHelper(allocationsTemporary),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _step15$value = _step15.value,\n              anonymous = _step15$value.anonymous,\n              topics = _step15$value.topics,\n              allocation = _step15$value.allocation;\n          var contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n\n          if (contractKind !== \"library\") {\n            contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n          }\n\n          allocation = Object.assign(Object.assign({}, allocation), {\n            contextHash: contextHash\n          }); //the allocation's context hash at this point depends on where it was defined, but\n          //that's not what we want going in the final allocation table!\n\n          if (allocations[topics] === undefined) {\n            allocations[topics] = {\n              bySelector: {},\n              anonymous: {\n                contract: {},\n                library: {}\n              }\n            };\n          }\n\n          if (!anonymous) {\n            if (allocations[topics].bySelector[_selector] === undefined) {\n              allocations[topics].bySelector[_selector] = {\n                contract: {},\n                library: {}\n              };\n            }\n\n            if (allocations[topics].bySelector[_selector][contractKind][contextHash] === undefined) {\n              allocations[topics].bySelector[_selector][contractKind][contextHash] = [];\n            }\n\n            allocations[topics].bySelector[_selector][contractKind][contextHash].push(allocation);\n          } else {\n            if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {\n              allocations[topics].anonymous[contractKind][contextHash] = [];\n            }\n\n            allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n          }\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getEventAllocations = getEventAllocations; //if derivedContractNode is passed, we check that before referenceDeclarations\n\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n  var searchResult = linearizedBaseContracts.reduce(function (foundNodeAndContract, baseContractId) {\n    if (foundNodeAndContract !== undefined) {\n      return foundNodeAndContract; //once we've found something, we don't need to keep looking\n    }\n\n    debug(\"searching contract %d\", baseContractId);\n    var baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n    : referenceDeclarations[baseContractId];\n\n    if (baseContractNode === undefined || baseContractNode.nodeType !== \"ContractDefinition\") {\n      debug(\"bad contract node!\");\n      return null; //return null rather than undefined so that this will propagate through\n      //(i.e. by returning null here we give up the search)\n      //(we don't want to continue due to possibility of grabbing the wrong override)\n    }\n\n    var node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n\n    if (node) {\n      debug(\"found node: %o\", node);\n      return {\n        node: node,\n        contract: baseContractNode\n      };\n    } else {\n      return undefined;\n    }\n  }, undefined //start with no node found\n  );\n  return searchResult || {\n    node: undefined,\n    contract: undefined\n  };\n}\n\nfunction makeContractKey(context, id, compilationId) {\n  return context ? context.context : id + \":\" + compilationId; //HACK!\n}\n\nfunction hasContext(key) {\n  return key.startsWith(\"0x\"); //HACK!\n}\n\nfunction contextHashForKey(key) {\n  return hasContext(key) ? key //HACK!\n  : undefined;\n}","map":null,"metadata":{},"sourceType":"script"}