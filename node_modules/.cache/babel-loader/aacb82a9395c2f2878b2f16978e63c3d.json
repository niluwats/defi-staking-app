{"ast":null,"code":"var _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar Reason = require(\"./reason\");\n\nvar handlers = require(\"./handlers\");\n\nvar override = {\n  timeoutMessage: \"not mined within\",\n  // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt: function extractReceipt(message) {\n    var hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      var receiptString = \"{\" + message.split(\"{\")[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: function () {\n    var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, web3Error) {\n      var constructor, currentBlock, receipt, reason, listener, currentPollingBlock, pollID;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              constructor = this;\n              currentBlock = override.defaultMaxBlocks; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n              if (handlers.ignoreTimeoutError(context, web3Error)) {\n                _context2.next = 13;\n                break;\n              }\n\n              // We might have been routed here in web3 >= beta.34 by their own status check\n              // error. We want to extract the receipt, emit a receipt event\n              // and reject it ourselves.\n              receipt = override.extractReceipt(web3Error.message);\n\n              if (!receipt) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 7;\n              return handlers.receipt(context, receipt);\n\n            case 7:\n              return _context2.abrupt(\"return\");\n\n            case 8:\n              _context2.next = 10;\n              return Reason.get(context.params, constructor.web3, constructor.interfaceAdapter);\n\n            case 10:\n              reason = _context2.sent;\n\n              if (reason) {\n                web3Error.reason = reason;\n                web3Error.message += \" -- Reason given: \".concat(reason, \".\");\n              }\n\n              return _context2.abrupt(\"return\", context.promiEvent.reject(web3Error));\n\n            case 13:\n              // This will run every block from now until contract.timeoutBlocks\n              listener = function listener(pollID) {\n                currentBlock++;\n\n                if (currentBlock > constructor.timeoutBlocks) {\n                  clearInterval(pollID);\n                  return;\n                }\n\n                constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(function (result) {\n                  if (!result) return; // make sure reporter receives tx receipt promievent\n\n                  handlers.receipt(context, result);\n                  result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n                }).catch(function (err) {\n                  clearInterval(pollID);\n                  context.promiEvent.reject(err);\n                });\n              }; // Start polling\n\n\n              _context2.next = 16;\n              return constructor.interfaceAdapter.getBlockNumber();\n\n            case 16:\n              currentPollingBlock = _context2.sent;\n              pollID = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                var newBlock;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return constructor.interfaceAdapter.getBlockNumber();\n\n                      case 2:\n                        newBlock = _context.sent;\n\n                        if (newBlock > currentPollingBlock) {\n                          currentPollingBlock = newBlock;\n                          listener(pollID);\n                        }\n\n                      case 4:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })), override.pollingInterval);\n\n            case 18:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function start(_x, _x2) {\n      return _start.apply(this, arguments);\n    }\n\n    return start;\n  }()\n};\nmodule.exports = override;","map":null,"metadata":{},"sourceType":"script"}