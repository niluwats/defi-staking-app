{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitionToStoredType = exports.definitionToType = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:ast:import\");\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar Compiler = __importStar(require(\"../../compiler\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar import_1 = require(\"../../contexts/import\"); //NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\n\n\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n  var typeClass = Utils.typeClass(definition);\n  var typeHint = Utils.typeStringWithoutLocation(definition);\n\n  switch (typeClass) {\n    case \"bool\":\n      return {\n        typeClass: typeClass,\n        typeHint: typeHint\n      };\n\n    case \"address\":\n      {\n        switch (Compiler.Utils.solidityFamily(compiler)) {\n          case \"unknown\": //I guess?\n\n          case \"pre-0.5.0\":\n            return {\n              typeClass: typeClass,\n              kind: \"general\",\n              typeHint: typeHint\n            };\n\n          default:\n            return {\n              typeClass: typeClass,\n              kind: \"specific\",\n              payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"uint\":\n      {\n        var bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass: typeClass,\n          bits: bytes * 8,\n          typeHint: typeHint\n        };\n      }\n\n    case \"int\":\n      {\n        //typeScript won't let me group these for some reason\n        var _bytes = Utils.specifiedSize(definition);\n\n        return {\n          typeClass: typeClass,\n          bits: _bytes * 8,\n          typeHint: typeHint\n        };\n      }\n\n    case \"fixed\":\n      {\n        //typeScript won't let me group these for some reason\n        var _bytes2 = Utils.specifiedSize(definition);\n\n        var places = Utils.decimalPlaces(definition);\n        return {\n          typeClass: typeClass,\n          bits: _bytes2 * 8,\n          places: places,\n          typeHint: typeHint\n        };\n      }\n\n    case \"ufixed\":\n      {\n        var _bytes3 = Utils.specifiedSize(definition);\n\n        var _places = Utils.decimalPlaces(definition);\n\n        return {\n          typeClass: typeClass,\n          bits: _bytes3 * 8,\n          places: _places,\n          typeHint: typeHint\n        };\n      }\n\n    case \"string\":\n      {\n        if (forceLocation === null) {\n          return {\n            typeClass: typeClass,\n            typeHint: typeHint\n          };\n        }\n\n        var location = forceLocation || Utils.referenceType(definition);\n        return {\n          typeClass: typeClass,\n          location: location,\n          typeHint: typeHint\n        };\n      }\n\n    case \"bytes\":\n      {\n        var length = Utils.specifiedSize(definition);\n\n        if (length !== null) {\n          return {\n            typeClass: typeClass,\n            kind: \"static\",\n            length: length,\n            typeHint: typeHint\n          };\n        } else {\n          if (forceLocation === null) {\n            return {\n              typeClass: typeClass,\n              kind: \"dynamic\",\n              typeHint: typeHint\n            };\n          }\n\n          var _location = forceLocation || Utils.referenceType(definition);\n\n          return {\n            typeClass: typeClass,\n            kind: \"dynamic\",\n            location: _location,\n            typeHint: typeHint\n          };\n        }\n      }\n\n    case \"array\":\n      {\n        var baseDefinition = Utils.baseDefinition(definition);\n        var baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n\n        var _location2 = forceLocation || Utils.referenceType(definition);\n\n        if (Utils.isDynamicArray(definition)) {\n          if (forceLocation !== null) {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"dynamic\",\n              location: _location2,\n              typeHint: typeHint\n            };\n          } else {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"dynamic\",\n              typeHint: typeHint\n            };\n          }\n        } else {\n          var _length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n\n          if (forceLocation !== null) {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"static\",\n              length: _length,\n              location: _location2,\n              typeHint: typeHint\n            };\n          } else {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"static\",\n              length: _length,\n              typeHint: typeHint\n            };\n          }\n        }\n      }\n\n    case \"mapping\":\n      {\n        var keyDefinition = Utils.keyDefinition(definition); //note that we can skip the scopes argument here! that's only needed when\n        //a general node, rather than a declaration, is being passed in\n\n        var keyType = definitionToType(keyDefinition, compilationId, compiler, null); //suppress the location on the key type (it'll be given as memory but\n        //this is meaningless)\n        //also, we have to tell TypeScript ourselves that this will be an elementary\n        //type; it has no way of knowing that\n\n        debug(\"definition: %O\", definition);\n        var valueDefinition = Utils.valueDefinition(definition);\n        var valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n\n        if (forceLocation === null) {\n          return {\n            typeClass: typeClass,\n            keyType: keyType,\n            valueType: valueType\n          };\n        }\n\n        return {\n          typeClass: typeClass,\n          keyType: keyType,\n          valueType: valueType,\n          location: \"storage\"\n        };\n      }\n\n    case \"function\":\n      {\n        //WARNING! This case will not work unless given the actual\n        //definition!  It should return something *roughly* usable, though.\n        var visibility = Utils.visibility(definition); //undefined if bad node\n\n        var mutability = Utils.mutability(definition); //undefined if bad node\n\n        var _ref = Utils.parameters(definition) || [[], []],\n            _ref2 = _slicedToArray(_ref, 2),\n            inputParameters = _ref2[0],\n            outputParameters = _ref2[1]; //HACK\n        //note: don't force a location on these! use the listed location!\n\n\n        var inputParameterTypes = inputParameters.map(function (parameter) {\n          return definitionToType(parameter, compilationId, compiler);\n        });\n        var outputParameterTypes = outputParameters.map(function (parameter) {\n          return definitionToType(parameter, compilationId, compiler);\n        });\n\n        switch (visibility) {\n          case \"internal\":\n            return {\n              typeClass: typeClass,\n              visibility: visibility,\n              mutability: mutability,\n              inputParameterTypes: inputParameterTypes,\n              outputParameterTypes: outputParameterTypes\n            };\n\n          case \"external\":\n            return {\n              typeClass: typeClass,\n              visibility: visibility,\n              kind: \"specific\",\n              mutability: mutability,\n              inputParameterTypes: inputParameterTypes,\n              outputParameterTypes: outputParameterTypes\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"struct\":\n      {\n        var id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        var qualifiedName = typeHint.match(/struct (.*)/)[1];\n        var definingContractName;\n        var typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          var _qualifiedName$split = qualifiedName.split(\".\");\n\n          var _qualifiedName$split2 = _slicedToArray(_qualifiedName$split, 2);\n\n          definingContractName = _qualifiedName$split2[0];\n          typeName = _qualifiedName$split2[1];\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (forceLocation === null) {\n          if (definingContractName) {\n            return {\n              typeClass: typeClass,\n              kind: \"local\",\n              id: id,\n              typeName: typeName,\n              definingContractName: definingContractName\n            };\n          } else {\n            return {\n              typeClass: typeClass,\n              kind: \"global\",\n              id: id,\n              typeName: typeName\n            };\n          }\n        }\n\n        var _location3 = forceLocation || Utils.referenceType(definition);\n\n        if (definingContractName) {\n          return {\n            typeClass: typeClass,\n            kind: \"local\",\n            id: id,\n            typeName: typeName,\n            definingContractName: definingContractName,\n            location: _location3\n          };\n        } else {\n          return {\n            typeClass: typeClass,\n            kind: \"global\",\n            id: id,\n            typeName: typeName,\n            location: _location3\n          };\n        }\n      }\n\n    case \"enum\":\n      {\n        var _id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n\n        var _qualifiedName = typeHint.match(/enum (.*)/)[1];\n\n        var _definingContractName;\n\n        var _typeName;\n\n        if (_qualifiedName.includes(\".\")) {\n          var _qualifiedName$split3 = _qualifiedName.split(\".\");\n\n          var _qualifiedName$split4 = _slicedToArray(_qualifiedName$split3, 2);\n\n          _definingContractName = _qualifiedName$split4[0];\n          _typeName = _qualifiedName$split4[1];\n        } else {\n          _typeName = _qualifiedName; //leave definingContractName undefined\n        }\n\n        if (_definingContractName) {\n          return {\n            typeClass: typeClass,\n            kind: \"local\",\n            id: _id,\n            typeName: _typeName,\n            definingContractName: _definingContractName\n          };\n        } else {\n          return {\n            typeClass: typeClass,\n            kind: \"global\",\n            id: _id,\n            typeName: _typeName\n          };\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        var _id2 = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n\n        var _definingContractName2;\n\n        var _typeName2;\n\n        if (typeHint.includes(\".\")) {\n          var _typeHint$split = typeHint.split(\".\");\n\n          var _typeHint$split2 = _slicedToArray(_typeHint$split, 2);\n\n          _definingContractName2 = _typeHint$split2[0];\n          _typeName2 = _typeHint$split2[1];\n        } else {\n          _typeName2 = typeHint; //leave definingContractName undefined\n        }\n\n        if (_definingContractName2) {\n          return {\n            typeClass: typeClass,\n            kind: \"local\",\n            id: _id2,\n            typeName: _typeName2,\n            definingContractName: _definingContractName2\n          };\n        } else {\n          return {\n            typeClass: typeClass,\n            kind: \"global\",\n            id: _id2,\n            typeName: _typeName2\n          };\n        }\n      }\n\n    case \"contract\":\n      {\n        var _id3 = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n\n        var _typeName3 = typeHint.match(/(contract|library|interface) (.*)/)[2]; //note: we use the type string rather than the type identifier\n        //in order to avoid having to deal with the underscore problem\n\n        var contractKind = Utils.contractKind(definition);\n        return {\n          typeClass: typeClass,\n          kind: \"native\",\n          id: _id3,\n          typeName: _typeName3,\n          contractKind: contractKind\n        };\n      }\n\n    case \"magic\":\n      {\n        var typeIdentifier = Utils.typeIdentifier(definition);\n        var variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];\n        return {\n          typeClass: typeClass,\n          variable: variable\n        };\n      }\n  }\n}\n\nexports.definitionToType = definitionToType; //whereas the above takes variable definitions, this takes the actual type\n//definition\n\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n  switch (definition.nodeType) {\n    case \"StructDefinition\":\n      {\n        var _getDefiningInfo = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations),\n            id = _getDefiningInfo.id,\n            typeName = _getDefiningInfo.typeName,\n            definingContractName = _getDefiningInfo.definingContractName,\n            definingContract = _getDefiningInfo.definingContract;\n\n        var memberTypes = definition.members.map(function (member) {\n          return {\n            name: member.name,\n            type: definitionToType(member, compilationId, compiler, null)\n          };\n        });\n\n        if (definingContract) {\n          return {\n            typeClass: \"struct\",\n            kind: \"local\",\n            id: id,\n            typeName: typeName,\n            definingContractName: definingContractName,\n            definingContract: definingContract,\n            memberTypes: memberTypes\n          };\n        } else {\n          return {\n            typeClass: \"struct\",\n            kind: \"global\",\n            id: id,\n            typeName: typeName,\n            memberTypes: memberTypes\n          };\n        }\n      }\n\n    case \"EnumDefinition\":\n      {\n        var _getDefiningInfo2 = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations),\n            _id4 = _getDefiningInfo2.id,\n            _typeName4 = _getDefiningInfo2.typeName,\n            _definingContractName3 = _getDefiningInfo2.definingContractName,\n            _definingContract = _getDefiningInfo2.definingContract;\n\n        var options = definition.members.map(function (member) {\n          return member.name;\n        });\n\n        if (_definingContract) {\n          return {\n            typeClass: \"enum\",\n            kind: \"local\",\n            id: _id4,\n            typeName: _typeName4,\n            definingContractName: _definingContractName3,\n            definingContract: _definingContract,\n            options: options\n          };\n        } else {\n          return {\n            typeClass: \"enum\",\n            kind: \"global\",\n            id: _id4,\n            typeName: _typeName4,\n            options: options\n          };\n        }\n      }\n\n    case \"UserDefinedValueTypeDefinition\":\n      {\n        var _getDefiningInfo3 = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations),\n            _id5 = _getDefiningInfo3.id,\n            _typeName5 = _getDefiningInfo3.typeName,\n            _definingContractName4 = _getDefiningInfo3.definingContractName,\n            _definingContract2 = _getDefiningInfo3.definingContract;\n\n        var underlyingType = definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here\n\n        if (_definingContract2) {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"local\",\n            id: _id5,\n            typeName: _typeName5,\n            definingContractName: _definingContractName4,\n            definingContract: _definingContract2,\n            underlyingType: underlyingType\n          };\n        } else {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"global\",\n            id: _id5,\n            typeName: _typeName5,\n            underlyingType: underlyingType\n          };\n        }\n      }\n\n    case \"ContractDefinition\":\n      {\n        var _id6 = import_1.makeTypeId(definition.id, compilationId);\n\n        var _typeName6 = definition.name;\n        var contractKind = definition.contractKind;\n        var payable = Utils.isContractPayable(definition);\n        return {\n          typeClass: \"contract\",\n          kind: \"native\",\n          id: _id6,\n          typeName: _typeName6,\n          contractKind: contractKind,\n          payable: payable\n        };\n      }\n  }\n}\n\nexports.definitionToStoredType = definitionToStoredType;\n\nfunction getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {\n  var id = import_1.makeTypeId(definition.id, compilationId);\n  var definingContractName;\n  var typeName;\n\n  if (definition.canonicalName) {\n    if (definition.canonicalName.includes(\".\")) {\n      var _definition$canonical = definition.canonicalName.split(\".\");\n\n      var _definition$canonical2 = _slicedToArray(_definition$canonical, 2);\n\n      definingContractName = _definition$canonical2[0];\n      typeName = _definition$canonical2[1];\n    } else {\n      typeName = definition.canonicalName;\n    }\n  } else {\n    //due to a bug, in 0.8.8 UDVTs lack a canonicalName.\n    //so we'll set typeName based on name instead of canonicalName,\n    //and set definingContractName below based on definingContract.\n    //(this does mean that we'll mess up a bit if referenceDeclarations\n    //is not passed... but realistically that shouldn't come up?  really the\n    //same kind of hapepns for every type)\n    typeName = definition.name;\n  }\n\n  var definingContract = undefined;\n  ;\n\n  if (referenceDeclarations) {\n    var contractDefinition = Object.values(referenceDeclarations).find(function (node) {\n      return node.nodeType === \"ContractDefinition\" && node.nodes.some(function (subNode) {\n        return import_1.makeTypeId(subNode.id, compilationId) === id;\n      });\n    });\n\n    if (contractDefinition) {\n      definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations\n\n      if (!definingContractName) {\n        definingContractName = contractDefinition.name;\n      }\n    }\n  }\n\n  return {\n    definingContract: definingContract,\n    definingContractName: definingContractName,\n    typeName: typeName,\n    id: id\n  };\n}","map":null,"metadata":{},"sourceType":"script"}