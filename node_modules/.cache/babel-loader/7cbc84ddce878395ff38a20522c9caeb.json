{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:storage:allocate\");\n\nvar Compiler = __importStar(require(\"../../compiler\"));\n\nvar Common = __importStar(require(\"../../common\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar Ast = __importStar(require(\"../../ast\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\n\nvar UnknownBaseContractIdError = /*#__PURE__*/function (_Error) {\n  _inherits(UnknownBaseContractIdError, _Error);\n\n  function UnknownBaseContractIdError(derivedId, derivedName, derivedKind, baseId) {\n    var _this;\n\n    _classCallCheck(this, UnknownBaseContractIdError);\n\n    var message = \"Cannot locate base contract ID \".concat(baseId, \" of \").concat(derivedKind, \" \").concat(derivedName, \" (ID \").concat(derivedId, \")\");\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(UnknownBaseContractIdError).call(this, message));\n    _this.name = \"UnknownBaseContractIdError\";\n    _this.derivedId = derivedId;\n    _this.derivedName = derivedName;\n    _this.derivedKind = derivedKind;\n    _this.baseId = baseId;\n    return _this;\n  }\n\n  return UnknownBaseContractIdError;\n}(_wrapNativeSuper(Error));\n\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError; //contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\n\nfunction getStorageAllocations(userDefinedTypesByCompilation) {\n  var allocations = {};\n\n  for (var _i = 0, _Object$values = Object.values(userDefinedTypesByCompilation); _i < _Object$values.length; _i++) {\n    var compilation = _Object$values[_i];\n    var compiler = compilation.compiler,\n        userDefinedTypes = compilation.types;\n\n    for (var _i2 = 0, _Object$values2 = Object.values(compilation.types); _i2 < _Object$values2.length; _i2++) {\n      var dataType = _Object$values2[_i2];\n\n      if (dataType.typeClass === \"struct\") {\n        try {\n          allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);\n        } catch (_a) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n          //note: a better way of handling this would probably be to *mark* it\n          //as failed rather than throwing an exception as that would lead to less\n          //recomputation, but this is simpler and I don't think the recomputation\n          //should really be a problem\n        }\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\n\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  var existingAllocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var allocations = existingAllocations;\n\n  var _iterator = _createForOfIteratorHelper(contracts),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var contractInfo = _step.value;\n      var contract = contractInfo.contractNode,\n          immutableReferences = contractInfo.immutableReferences,\n          compiler = contractInfo.compiler,\n          compilationId = contractInfo.compilationId;\n\n      try {\n        allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n      } catch (_a) {//we're just going to allow failure here and catch the problem elsewhere\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return allocations;\n}\n\nexports.getStateAllocations = getStateAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);\n}\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {\n  var offset = 0; //will convert to BN when placing in slot\n\n  var index = Evm.Utils.WORD_SIZE - 1; //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  var allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  //otherwise, we need to allocate\n\n  var memberAllocations = [];\n\n  var _iterator2 = _createForOfIteratorHelper(members),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var member = _step2.value;\n      var size = void 0;\n\n      var _storageSizeAndAlloca = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler);\n\n      size = _storageSizeAndAlloca.size;\n      allocations = _storageSizeAndAlloca.allocations;\n\n      //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n      //if it's sized in bytes but there's not enough room, we also need a new slot\n      if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {\n        index = Evm.Utils.WORD_SIZE - 1;\n        offset += 1;\n      } //otherwise, we remain in place\n\n\n      var range = void 0;\n\n      if (Utils.isWordsLength(size)) {\n        //words case\n        range = {\n          from: {\n            slot: {\n              offset: new bn_js_1.default(offset) //start at the current slot...\n\n            },\n            index: 0 //...at the beginning of the word.\n\n          },\n          to: {\n            slot: {\n              offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n\n            },\n            index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n\n          }\n        };\n      } else {\n        //bytes case\n        range = {\n          from: {\n            slot: {\n              offset: new bn_js_1.default(offset) //start at the current slot...\n\n            },\n            index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n\n          },\n          to: {\n            slot: {\n              offset: new bn_js_1.default(offset) //end at the current slot...\n\n            },\n            index: index //...at the current position.\n\n          }\n        };\n      }\n\n      memberAllocations.push({\n        name: member.name,\n        type: member.type,\n        pointer: {\n          location: \"storage\",\n          range: range\n        }\n      }); //finally, adjust the current position.\n      //if it was sized in words, move down that many slots and reset position w/in slot\n\n      if (Utils.isWordsLength(size)) {\n        offset += size.words;\n        index = Evm.Utils.WORD_SIZE - 1;\n      } //if it was sized in bytes, move down an appropriate number of bytes.\n      else {\n          index -= size.bytes; //but if this puts us into the next word, move to the next word.\n\n          if (index < 0) {\n            index = Evm.Utils.WORD_SIZE - 1;\n            offset += 1;\n          }\n        }\n    } //finally, let's determine the overall siz; we're dealing with a struct, so\n    //the size is measured in words\n    //it's one plus the last word used, i.e. one plus the current word... unless the\n    //current word remains entirely unused, then it's just the current word\n    //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n    //empty structs behave in versions where they're legal)\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var totalSize;\n\n  if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n    totalSize = {\n      words: offset\n    };\n  } else {\n    totalSize = {\n      words: offset + 1\n    };\n  } //having made our allocation, let's add it to allocations!\n\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    size: totalSize\n  }; //...and we're done!\n\n  return allocations;\n}\n\nfunction getStateVariables(contractNode) {\n  // process for state variables\n  return contractNode.nodes.filter(function (node) {\n    return node.nodeType === \"VariableDeclaration\" && node.stateVariable;\n  });\n}\n\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  var _ref4;\n\n  var existingAllocations = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  //we're going to do a 2-deep clone here\n  var allocations = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(existingAllocations).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        compilationId = _ref2[0],\n        compilationAllocations = _ref2[1];\n\n    return _defineProperty({}, compilationId, Object.assign({}, compilationAllocations));\n  }))));\n\n  if (!immutableReferences) {\n    immutableReferences = {}; //also, let's set this up for convenience\n  } //base contracts are listed from most derived to most base, so we\n  //have to reverse before processing, but reverse() is in place, so we\n  //clone with slice first\n\n\n  var linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse(); //first, let's get all the variables under consideration\n\n  var variables = (_ref4 = []).concat.apply(_ref4, _toConsumableArray(linearizedBaseContractsFromBase.map(function (id) {\n    var baseNode = referenceDeclarations[id];\n\n    if (baseNode === undefined) {\n      throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n    }\n\n    return getStateVariables(baseNode).map(function (definition) {\n      return {\n        definition: definition,\n        definedIn: baseNode\n      };\n    });\n  }))); //just in case the constant field ever gets removed\n\n\n  var isConstant = function isConstant(definition) {\n    return definition.constant || definition.mutability === \"constant\";\n  }; //now: we split the variables into storage, constant, and code\n\n\n  var _lodash_partition_1$d = lodash_partition_1.default(variables, function (variable) {\n    return isConstant(variable.definition);\n  }),\n      _lodash_partition_1$d2 = _slicedToArray(_lodash_partition_1$d, 2),\n      constantVariables = _lodash_partition_1$d2[0],\n      variableVariables = _lodash_partition_1$d2[1]; //why use this function instead of just checking\n  //definition.mutability?\n  //because of a bug in Solidity 0.6.5 that causes the mutability field\n  //not to exist.  So, we also have to check against immutableReferences.\n\n\n  var isImmutable = function isImmutable(definition) {\n    return definition.mutability === \"immutable\" || definition.id.toString() in immutableReferences;\n  };\n\n  var _lodash_partition_1$d3 = lodash_partition_1.default(variableVariables, function (variable) {\n    return isImmutable(variable.definition);\n  }),\n      _lodash_partition_1$d4 = _slicedToArray(_lodash_partition_1$d3, 2),\n      immutableVariables = _lodash_partition_1$d4[0],\n      storageVariables = _lodash_partition_1$d4[1]; //transform storage variables into data types\n\n\n  var storageVariableTypes = storageVariables.map(function (variable) {\n    return {\n      name: variable.definition.name,\n      type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n    };\n  }); //let's allocate the storage variables using a fictitious ID\n\n  var id = \"-1\";\n  var storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id]; //transform to new format\n\n  var storageVariableAllocations = storageVariables.map(function (_ref5, index) {\n    var definition = _ref5.definition,\n        definedIn = _ref5.definedIn;\n    return {\n      definition: definition,\n      definedIn: definedIn,\n      compilationId: compilationId,\n      pointer: storageVariableStorageAllocations.members[index].pointer\n    };\n  }); //now let's create allocations for the immutables\n\n  var immutableVariableAllocations = immutableVariables.map(function (_ref6) {\n    var definition = _ref6.definition,\n        definedIn = _ref6.definedIn;\n    var references = immutableReferences[definition.id.toString()] || [];\n    var pointer;\n\n    if (references.length === 0) {\n      pointer = {\n        location: \"nowhere\"\n      };\n    } else {\n      pointer = {\n        location: \"code\",\n        start: references[0].start,\n        length: references[0].length\n      };\n    }\n\n    return {\n      definition: definition,\n      definedIn: definedIn,\n      compilationId: compilationId,\n      pointer: pointer\n    };\n  }); //and let's create allocations for the constants\n\n  var constantVariableAllocations = constantVariables.map(function (_ref7) {\n    var definition = _ref7.definition,\n        definedIn = _ref7.definedIn;\n    return {\n      definition: definition,\n      definedIn: definedIn,\n      compilationId: compilationId,\n      pointer: {\n        location: \"definition\",\n        definition: definition.value\n      }\n    };\n  }); //now, reweave the three together\n\n  var contractAllocation = [];\n\n  var _iterator3 = _createForOfIteratorHelper(variables),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var variable = _step3.value;\n      var arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;\n      contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    } //finally, set things and return\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (!allocations[compilationId]) {\n    allocations[compilationId] = {};\n  }\n\n  allocations[compilationId][contract.id] = {\n    members: contractAllocation\n  };\n  return allocations;\n} //NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\n\n\nfunction storageSize(dataType, userDefinedTypes, allocations, compiler) {\n  return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;\n}\n\nexports.storageSize = storageSize;\n\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //we'll only directly handle reference types here;\n  //direct types will be handled by dispatching to Basic.Allocate.byteLength\n  //in the default case\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      {\n        switch (dataType.kind) {\n          case \"static\":\n            //really a basic type :)\n            return {\n              size: {\n                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n              },\n              allocations: existingAllocations\n            };\n\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n        }\n      }\n\n    case \"string\":\n    case \"mapping\":\n      return {\n        size: {\n          words: 1\n        },\n        allocations: existingAllocations\n      };\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            //static array case\n            var length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n\n            if (length === 0) {\n              //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n              return {\n                size: {\n                  words: 1\n                },\n                allocations: existingAllocations\n              };\n            }\n\n            var _storageSizeAndAlloca2 = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),\n                baseSize = _storageSizeAndAlloca2.size,\n                allocations = _storageSizeAndAlloca2.allocations;\n\n            if (!Utils.isWordsLength(baseSize)) {\n              //bytes case\n              var perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n              debug(\"length %o\", length);\n              var numWords = Math.ceil(length / perWord);\n              return {\n                size: {\n                  words: numWords\n                },\n                allocations: allocations\n              };\n            } else {\n              //words case\n              return {\n                size: {\n                  words: baseSize.words * length\n                },\n                allocations: allocations\n              };\n            }\n\n        }\n      }\n\n    case \"struct\":\n      {\n        var _allocations = existingAllocations;\n        var allocation = _allocations[dataType.id]; //may be undefined!\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          var storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          _allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = _allocations[dataType.id];\n        } //having found our allocation, we can just look up its size\n\n\n        return {\n          size: allocation.size,\n          allocations: _allocations\n        };\n      }\n\n    case \"userDefinedValueType\":\n      if (Compiler.Utils.solidityFamily(compiler) === \"0.8.7+\") {\n        //UDVTs were introduced in Solidity 0.8.8.  However, in that version,\n        //and that version only, they have a bug where they always take up a\n        //full word in storage regardless of the size of the underlying type.\n        return {\n          size: {\n            words: 1\n          },\n          allocations: existingAllocations\n        };\n      }\n\n    //otherwise, treat them normally\n    //DELIBERATE FALL-TRHOUGH\n\n    default:\n      //otherwise, it's a direct type\n      return {\n        size: {\n          bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n        },\n        allocations: existingAllocations\n      };\n  }\n}","map":null,"metadata":{},"sourceType":"script"}