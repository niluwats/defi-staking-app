{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar stream = require('stream');\n\nvar BinaryParseStream = require('../vendor/binary-parse-stream');\n\nvar Tagged = require('./tagged');\n\nvar Simple = require('./simple');\n\nvar utils = require('./utils');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar NoFilter = require('nofilter');\n\nvar constants = require('./constants'); // Do not fix this if you want to support node v4\n\n\nvar MT = constants.MT;\nvar NUMBYTES = constants.NUMBYTES;\nvar SIMPLE = constants.SIMPLE;\nvar SYMS = constants.SYMS;\nvar BI = utils.bigIntize(constants.BI);\nvar BN = constants.BN;\nvar COUNT = Symbol('count');\nvar PENDING_KEY = Symbol('pending_key');\nvar MAJOR = Symbol('major type');\nvar ERROR = Symbol('error');\nvar NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  var a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  var b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n/**\n * @param {Buffer} v\n * @private\n */\n\n\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v);\n}\n/**\n * @param {BigInt} v\n * @private\n */\n\n\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v);\n}\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\n\n\nvar Decoder = /*#__PURE__*/function (_BinaryParseStream) {\n  _inherits(Decoder, _BinaryParseStream);\n\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  function Decoder(options) {\n    var _this;\n\n    _classCallCheck(this, Decoder);\n\n    options = options || {};\n    var tags = options.tags;\n    delete options.tags;\n    var max_depth = options.max_depth != null ? options.max_depth : -1;\n    delete options.max_depth;\n    var bigI = utils.hasBigInt ? !!options.bigint : false;\n    delete options.bigint;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Decoder).call(this, options));\n    _this.running = true;\n    _this.max_depth = max_depth;\n    _this.tags = tags;\n\n    if (bigI) {\n      if (_this.tags == null) {\n        _this.tags = {};\n      }\n\n      if (_this.tags[2] == null) {\n        _this.tags[2] = _tag_2;\n      }\n\n      if (_this.tags[3] == null) {\n        _this.tags[3] = _tag_3;\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n\n\n  _createClass(Decoder, [{\n    key: \"close\",\n\n    /**\n     * Stop processing\n     */\n    value: function close() {\n      this.running = false;\n      this.__fresh = true;\n    }\n  }, {\n    key: \"_parse\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function _parse() {\n      var parent, depth, val, octet, mt, ai, parent_major, parent_length, numbytes, buf, hasParent, again, pm, allstrings, i, len, _i, _len, _i2, _len2, t, old;\n\n      return _regeneratorRuntime.wrap(function _parse$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              parent = null;\n              depth = 0;\n              val = null;\n\n            case 3:\n              if (!true) {\n                _context.next = 151;\n                break;\n              }\n\n              if (!(this.max_depth >= 0 && depth > this.max_depth)) {\n                _context.next = 6;\n                break;\n              }\n\n              throw new Error('Maximum depth ' + this.max_depth + ' exceeded');\n\n            case 6:\n              _context.next = 8;\n              return 1;\n\n            case 8:\n              octet = _context.sent[0];\n\n              if (this.running) {\n                _context.next = 11;\n                break;\n              }\n\n              throw new Error('Unexpected data: 0x' + octet.toString(16));\n\n            case 11:\n              mt = octet >> 5;\n              ai = octet & 0x1f;\n              parent_major = parent != null ? parent[MAJOR] : undefined;\n              parent_length = parent != null ? parent.length : undefined;\n              _context.t0 = ai;\n              _context.next = _context.t0 === NUMBYTES.ONE ? 18 : _context.t0 === NUMBYTES.TWO ? 23 : _context.t0 === NUMBYTES.FOUR ? 23 : _context.t0 === NUMBYTES.EIGHT ? 23 : _context.t0 === 28 ? 30 : _context.t0 === 29 ? 30 : _context.t0 === 30 ? 30 : _context.t0 === NUMBYTES.INDEFINITE ? 32 : 38;\n              break;\n\n            case 18:\n              this.emit('more-bytes', mt, 1, parent_major, parent_length);\n              _context.next = 21;\n              return 1;\n\n            case 21:\n              val = _context.sent[0];\n              return _context.abrupt(\"break\", 39);\n\n            case 23:\n              numbytes = 1 << ai - 24;\n              this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n              _context.next = 27;\n              return numbytes;\n\n            case 27:\n              buf = _context.sent;\n              val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n              return _context.abrupt(\"break\", 39);\n\n            case 30:\n              this.running = false;\n              throw new Error('Additional info not implemented: ' + ai);\n\n            case 32:\n              _context.t1 = mt;\n              _context.next = _context.t1 === MT.POS_INT ? 35 : _context.t1 === MT.NEG_INT ? 35 : _context.t1 === MT.TAG ? 35 : 36;\n              break;\n\n            case 35:\n              throw new Error(\"Invalid indefinite encoding for MT \".concat(mt));\n\n            case 36:\n              val = -1;\n              return _context.abrupt(\"break\", 39);\n\n            case 38:\n              val = ai;\n\n            case 39:\n              _context.t2 = mt;\n              _context.next = _context.t2 === MT.POS_INT ? 42 : _context.t2 === MT.NEG_INT ? 43 : _context.t2 === MT.BYTE_STRING ? 45 : _context.t2 === MT.UTF8_STRING ? 45 : _context.t2 === MT.ARRAY ? 61 : _context.t2 === MT.MAP ? 61 : _context.t2 === MT.TAG ? 75 : _context.t2 === MT.SIMPLE_FLOAT ? 80 : 88;\n              break;\n\n            case 42:\n              return _context.abrupt(\"break\", 88);\n\n            case 43:\n              if (val === Number.MAX_SAFE_INTEGER) {\n                val = BN.NEG_MAX;\n              } else if (val instanceof bignumber) {\n                val = BN.MINUS_ONE.minus(val);\n              } else {\n                val = -1 - val;\n              }\n\n              return _context.abrupt(\"break\", 88);\n\n            case 45:\n              _context.t3 = val;\n              _context.next = _context.t3 === 0 ? 48 : _context.t3 === -1 ? 51 : 55;\n              break;\n\n            case 48:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = mt === MT.BYTE_STRING ? Buffer.allocUnsafe(0) : '';\n              return _context.abrupt(\"break\", 60);\n\n            case 51:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 55:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              _context.next = 58;\n              return val;\n\n            case 58:\n              val = _context.sent;\n\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              }\n\n            case 60:\n              return _context.abrupt(\"break\", 88);\n\n            case 61:\n              _context.t4 = val;\n              _context.next = _context.t4 === 0 ? 64 : _context.t4 === -1 ? 66 : 70;\n              break;\n\n            case 64:\n              val = mt === MT.MAP ? {} : [];\n              return _context.abrupt(\"break\", 74);\n\n            case 66:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 70:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 74:\n              return _context.abrupt(\"break\", 88);\n\n            case 75:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, 1);\n              parent.push(val);\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 80:\n              if (!(typeof val === 'number')) {\n                _context.next = 87;\n                break;\n              }\n\n              if (!(ai === NUMBYTES.ONE && val < 32)) {\n                _context.next = 83;\n                break;\n              }\n\n              throw new Error(\"Invalid two-byte encoding of simple value \".concat(val));\n\n            case 83:\n              hasParent = parent != null;\n              val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n              _context.next = 88;\n              break;\n\n            case 87:\n              val = utils.parseCBORfloat(val);\n\n            case 88:\n              this.emit('value', val, parent_major, parent_length, ai);\n              again = false;\n\n            case 90:\n              if (!(parent != null)) {\n                _context.next = 147;\n                break;\n              }\n\n              _context.t5 = false;\n              _context.next = _context.t5 === (val !== SYMS.BREAK) ? 94 : _context.t5 === !Array.isArray(parent) ? 96 : _context.t5 === !(parent instanceof NoFilter) ? 98 : 103;\n              break;\n\n            case 94:\n              parent[COUNT] = 1;\n              return _context.abrupt(\"break\", 103);\n\n            case 96:\n              parent.push(val);\n              return _context.abrupt(\"break\", 103);\n\n            case 98:\n              pm = parent[MAJOR];\n\n              if (!(pm != null && pm !== mt)) {\n                _context.next = 102;\n                break;\n              }\n\n              this.running = false;\n              throw new Error('Invalid major type in indefinite encoding');\n\n            case 102:\n              parent.write(val);\n\n            case 103:\n              if (!(--parent[COUNT] !== 0)) {\n                _context.next = 106;\n                break;\n              }\n\n              again = true;\n              return _context.abrupt(\"break\", 147);\n\n            case 106:\n              --depth;\n              delete parent[COUNT];\n\n              if (!Array.isArray(parent)) {\n                _context.next = 132;\n                break;\n              }\n\n              _context.t6 = parent[MAJOR];\n              _context.next = _context.t6 === MT.ARRAY ? 112 : _context.t6 === MT.MAP ? 114 : _context.t6 === MT.TAG ? 127 : 130;\n              break;\n\n            case 112:\n              val = parent;\n              return _context.abrupt(\"break\", 130);\n\n            case 114:\n              allstrings = true;\n\n              if (!(parent.length % 2 !== 0)) {\n                _context.next = 117;\n                break;\n              }\n\n              throw new Error('Invalid map length: ' + parent.length);\n\n            case 117:\n              i = 0, len = parent.length;\n\n            case 118:\n              if (!(i < len)) {\n                _context.next = 125;\n                break;\n              }\n\n              if (!(typeof parent[i] !== 'string')) {\n                _context.next = 122;\n                break;\n              }\n\n              allstrings = false;\n              return _context.abrupt(\"break\", 125);\n\n            case 122:\n              i += 2;\n              _context.next = 118;\n              break;\n\n            case 125:\n              if (allstrings) {\n                val = {};\n\n                for (_i = 0, _len = parent.length; _i < _len; _i += 2) {\n                  val[parent[_i]] = parent[_i + 1];\n                }\n              } else {\n                val = new Map();\n\n                for (_i2 = 0, _len2 = parent.length; _i2 < _len2; _i2 += 2) {\n                  val.set(parent[_i2], parent[_i2 + 1]);\n                }\n              }\n\n              return _context.abrupt(\"break\", 130);\n\n            case 127:\n              t = new Tagged(parent[0], parent[1]);\n              val = t.convert(this.tags);\n              return _context.abrupt(\"break\", 130);\n\n            case 130:\n              _context.next = 140;\n              break;\n\n            case 132:\n              if (!(parent instanceof NoFilter)) {\n                _context.next = 140;\n                break;\n              }\n\n              _context.t7 = parent[MAJOR];\n              _context.next = _context.t7 === MT.BYTE_STRING ? 136 : _context.t7 === MT.UTF8_STRING ? 138 : 140;\n              break;\n\n            case 136:\n              val = parent.slice();\n              return _context.abrupt(\"break\", 140);\n\n            case 138:\n              val = parent.toString('utf-8');\n              return _context.abrupt(\"break\", 140);\n\n            case 140:\n              this.emit('stop', parent[MAJOR]);\n              old = parent;\n              parent = parent[SYMS.PARENT];\n              delete old[SYMS.PARENT];\n              delete old[MAJOR];\n              _context.next = 90;\n              break;\n\n            case 147:\n              if (again) {\n                _context.next = 149;\n                break;\n              }\n\n              return _context.abrupt(\"return\", val);\n\n            case 149:\n              _context.next = 3;\n              break;\n\n            case 151:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _parse, this);\n    })\n  }], [{\n    key: \"nullcheck\",\n    value: function nullcheck(val) {\n      switch (val) {\n        case SYMS.NULL:\n          return null;\n\n        case SYMS.UNDEFINED:\n          return undefined;\n\n        case NOT_FOUND:\n          throw new Error('Value not found');\n\n        default:\n          return val;\n      }\n    }\n    /**\n     * @typedef DecodeOptions\n     * @property {string} [encoding='hex'] - The encoding of the input.\n     *   Ignored if input is a Buffer.\n     */\n\n    /**\n     * Decode the first CBOR item in the input, synchronously.  This will throw an\n     * exception if the input is not valid CBOR.\n     *\n     * @static\n     * @param {string|Buffer|stream.Readable} input\n     * @param {DecodeOptions|string} [options] Options\n     * @returns {any} - the decoded value\n     */\n\n  }, {\n    key: \"decodeFirstSync\",\n    value: function decodeFirstSync(input, options) {\n      options = options || {\n        encoding: 'hex'\n      };\n      var opts = {};\n      var encod;\n\n      switch (typeof options) {\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding;\n          delete opts.encoding;\n          break;\n      }\n\n      var c = new Decoder(opts);\n      var s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input)); // for/of doesn't work when you need to call next() with a value\n      // generator created by parser will be \"done\" after each CBOR entity\n      // parser will yield numbers of bytes that it wants\n\n      var parser = c._parse();\n\n      var state = parser.next();\n\n      while (!state.done) {\n        var b = s.read(state.value);\n\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n\n        state = parser.next(b);\n      }\n\n      var val = Decoder.nullcheck(state.value);\n\n      if (s.length > 0) {\n        var nextByte = s.read(1);\n        s.unshift(nextByte);\n        var er = new Error('Unexpected data: 0x' + nextByte[0].toString(16));\n        er.value = val;\n        throw er;\n      }\n\n      return val;\n    }\n    /**\n     * Decode all of the CBOR items in the input into an array.  This will throw\n     * an exception if the input is not valid CBOR; a zero-length input will\n     * return an empty array.\n     *\n     * @static\n     * @param {string|Buffer|stream.Readable} input\n     * @param {DecodeOptions|string} [options] Options or encoding string\n     * @returns {Array} - Array of all found items\n     */\n\n  }, {\n    key: \"decodeAllSync\",\n    value: function decodeAllSync(input, options) {\n      options = options || {\n        encoding: 'hex'\n      };\n      var opts = {};\n      var encod;\n\n      switch (typeof options) {\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding;\n          delete opts.encoding;\n      }\n\n      var c = new Decoder(opts);\n      var s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n      var res = [];\n\n      while (s.length > 0) {\n        var parser = c._parse();\n\n        var state = parser.next();\n\n        while (!state.done) {\n          var b = s.read(state.value);\n\n          if (b == null || b.length !== state.value) {\n            throw new Error('Insufficient data');\n          }\n\n          state = parser.next(b);\n        }\n\n        res.push(Decoder.nullcheck(state.value));\n      }\n\n      return res;\n    }\n    /**\n     * @callback decodeCallback\n     * @param {Error} [error] - if one was generated\n     * @param {any} [value] - the decoded value\n     */\n\n    /**\n     * Decode the first CBOR item in the input.  This will error if there are more\n     * bytes left over at the end, and optionally if there were no valid CBOR\n     * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n     * if no data was found and the `required` option is false.\n     *\n     * @static\n     * @param {string|Buffer} input - the input to parse\n     * @param {DecodeOptions|decodeCallback|string} [options] - options\n     * @param {decodeCallback} [cb] callback\n     * @returns {Promise<any>} returned even if callback is specified\n     */\n\n  }, {\n    key: \"decodeFirst\",\n    value: function decodeFirst(input, options, cb) {\n      var opts = {};\n      var required = false;\n      var encod = 'hex';\n\n      switch (typeof options) {\n        case 'function':\n          cb = options;\n          encod = utils.guessEncoding(input);\n          break;\n\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n          delete opts.encoding;\n          required = opts.required != null ? opts.required : false;\n          delete opts.required;\n      }\n\n      var c = new Decoder(opts);\n      var v = NOT_FOUND;\n      var p = new Promise(function (resolve, reject) {\n        c.on('data', function (val) {\n          v = Decoder.nullcheck(val);\n          c.close();\n        });\n        c.once('error', function (er) {\n          if (v !== NOT_FOUND) {\n            er.value = v;\n          }\n\n          v = ERROR;\n          c.close();\n          return reject(er);\n        });\n        c.once('end', function () {\n          switch (v) {\n            case NOT_FOUND:\n              if (required) {\n                return reject(new Error('No CBOR found'));\n              } else {\n                return resolve(v);\n              }\n\n            case ERROR:\n              return void 0;\n\n            default:\n              return resolve(v);\n          }\n        });\n      });\n\n      if (typeof cb === 'function') {\n        p.then(function (v) {\n          return cb(null, v);\n        }, cb);\n      }\n\n      c.end(input, encod);\n      return p;\n    }\n    /**\n     * @callback decodeAllCallback\n     * @param {Error} error - if one was generated\n     * @param {Array} value - all of the decoded values, wrapped in an Array\n     */\n\n    /**\n     * Decode all of the CBOR items in the input.  This will error if there are\n     * more bytes left over at the end.\n     *\n     * @static\n     * @param {(string|Buffer)} input - the input to parse\n     * @param {(string|Object)} options - Decoding options.\n     *   If string, the input encoding.\n     * @param {decodeAllCallback} cb callback\n     * @returns {Promise<Array>} even if callback is specified\n     */\n\n  }, {\n    key: \"decodeAll\",\n    value: function decodeAll(input, options, cb) {\n      var opts = {};\n      var encod = 'hex';\n\n      switch (typeof options) {\n        case 'function':\n          cb = options;\n          encod = utils.guessEncoding(input);\n          break;\n\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n          delete opts.encoding;\n      }\n\n      var c = new Decoder(opts);\n      var vals = [];\n      c.on('data', function (val) {\n        return vals.push(Decoder.nullcheck(val));\n      });\n      var p = new Promise(function (resolve, reject) {\n        c.on('error', reject);\n        c.on('end', function () {\n          return resolve(vals);\n        });\n      });\n\n      if (typeof cb === 'function') {\n        p.then(function (v) {\n          return cb(null, v);\n        }, cb);\n      }\n\n      c.end(input, encod);\n      return p;\n    }\n  }]);\n\n  return Decoder;\n}(BinaryParseStream);\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":null,"metadata":{},"sourceType":"script"}