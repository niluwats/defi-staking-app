{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.infoToCompilations = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:compilations:utils\");\n\nvar Ast = __importStar(require(\"../ast\"));\n\nvar Format = __importStar(require(\"../format\"));\n\nvar errors_1 = require(\"../errors\");\n\nfunction shimCompilations(inputCompilations) {\n  var shimmedCompilationIdPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return inputCompilations.map(function (compilation, compilationIndex) {\n    return shimCompilation(compilation, \"\".concat(shimmedCompilationIdPrefix, \"Number(\").concat(compilationIndex, \")\"));\n  });\n}\n\nexports.shimCompilations = shimCompilations;\n\nfunction shimCompilation(inputCompilation) {\n  var shimmedCompilationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n    files: inputCompilation.sourceIndexes,\n    sources: inputCompilation.sources,\n    shimmedCompilationId: shimmedCompilationId,\n    compiler: inputCompilation.compiler\n  })), {\n    compiler: inputCompilation.compiler\n  });\n}\n\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\n\nfunction shimArtifacts(artifacts, files) {\n  var shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  return [shimContracts(artifacts, {\n    files: files,\n    shimmedCompilationId: shimmedCompilationId\n  })];\n}\n\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\n\nfunction shimContracts(artifacts) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var files = options.files,\n      inputSources = options.sources;\n  var shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n  var contracts = [];\n  var sources = [];\n  var unreliableSourceOrder = false;\n\n  var _iterator = _createForOfIteratorHelper(artifacts),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var artifact = _step.value;\n      var contractName = artifact.contractName,\n          bytecode = artifact.bytecode,\n          sourceMap = artifact.sourceMap,\n          deployedBytecode = artifact.deployedBytecode,\n          deployedSourceMap = artifact.deployedSourceMap,\n          immutableReferences = artifact.immutableReferences,\n          sourcePath = artifact.sourcePath,\n          source = artifact.source,\n          ast = artifact.ast,\n          abi = artifact.abi,\n          compiler = artifact.compiler,\n          generatedSources = artifact.generatedSources,\n          deployedGeneratedSources = artifact.deployedGeneratedSources;\n\n      if (artifact.contract_name) {\n        //just in case\n        contractName = artifact.contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing\n      }\n\n      debug(\"contractName: %s\", contractName);\n      var contractObject = {\n        contractName: contractName,\n        bytecode: bytecode,\n        sourceMap: sourceMap,\n        deployedBytecode: deployedBytecode,\n        deployedSourceMap: deployedSourceMap,\n        immutableReferences: immutableReferences,\n        abi: abi,\n        generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n        deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n        compiler: compiler\n      };\n      var sourceObject = {\n        sourcePath: sourcePath,\n        source: source,\n        ast: ast,\n        compiler: compiler,\n        language: inferLanguage(ast, compiler, sourcePath)\n      }; //ast needs to be coerced because schema doesn't quite match our types here...\n      //if files or sources was passed, trust that to determine the source index\n\n      if (files || inputSources) {\n        //note: we never set the unreliableSourceOrder flag in this branch;\n        //we just trust files/sources.  If this info is bad, then, uh, too bad.\n        var _index2 = inputSources ? inputSources.findIndex(function (source) {\n          return source.sourcePath === sourcePath;\n        }) : files.indexOf(sourcePath);\n\n        if (!inputSources) {\n          //if inputSources was passed, we'll handle this separately below\n          sourceObject.id = _index2.toString(); //HACK\n\n          sources[_index2] = sourceObject;\n        }\n\n        contractObject.primarySourceId = _index2.toString(); //HACK\n      } else {\n        //if neither was passed, attempt to determine it from the ast\n        var _index3;\n\n        if (sourceObject.ast) {\n          //note: this works for both Solidity and Vyper\n          _index3 = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n        } else if (compiler && compiler.name === \"vyper\") {\n          _index3 = 0; //if it's Vyper but there's no AST, we can\n          //assume that it was compiled alone and therefore has index 0\n        } //if that didn't work, try the source map\n\n\n        if (_index3 === undefined && (sourceMap || deployedSourceMap)) {\n          var sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n          _index3 = extractPrimarySource(sourceMapString);\n        } //else leave undefined for now\n\n\n        var _getIndexToAddAt = getIndexToAddAt(sourceObject, _index3, sources, unreliableSourceOrder);\n\n        _index3 = _getIndexToAddAt.index;\n        unreliableSourceOrder = _getIndexToAddAt.unreliableSourceOrder;\n\n        if (_index3 !== null) {\n          //if we're in this case, inputSources was not passed\n          sourceObject.id = _index3.toString(); //HACK\n\n          sources[_index3] = sourceObject;\n          contractObject.primarySourceId = _index3.toString();\n        }\n      }\n\n      contracts.push(contractObject);\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    } //now: check for id overlap with internal sources\n    //(don't bother if inputSources or files was passed)\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!inputSources && !files) {\n    var _iterator2 = _createForOfIteratorHelper(contracts),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var contract = _step2.value;\n        var generatedSources = contract.generatedSources,\n            deployedGeneratedSources = contract.deployedGeneratedSources;\n\n        for (var index in generatedSources) {\n          if (index in sources) {\n            unreliableSourceOrder = true;\n          }\n        }\n\n        for (var _index in deployedGeneratedSources) {\n          if (_index in sources) {\n            unreliableSourceOrder = true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  var compiler;\n\n  if (options.compiler) {\n    compiler = options.compiler;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  } //if input sources was passed, set up the sources object directly :)\n\n\n  if (inputSources) {\n    sources = inputSources.map(function (_ref, index) {\n      var sourcePath = _ref.sourcePath,\n          source = _ref.contents,\n          ast = _ref.ast,\n          language = _ref.language;\n      return {\n        sourcePath: sourcePath,\n        source: source,\n        ast: ast,\n        language: language,\n        id: index.toString(),\n        compiler: compiler //redundant but let's include it\n\n      };\n    });\n  }\n\n  return {\n    id: shimmedCompilationId,\n    unreliableSourceOrder: unreliableSourceOrder,\n    sources: sources,\n    contracts: contracts,\n    compiler: compiler\n  };\n}\n\nexports.shimContracts = shimContracts; //note: this works for Vyper too!\n\nfunction sourceIndexForAst(ast) {\n  if (Array.isArray(ast)) {\n    //special handling for old Vyper versions\n    ast = ast[0];\n  }\n\n  if (!ast) {\n    return undefined;\n  }\n\n  return parseInt(ast.src.split(\":\")[2]); //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  var contractName = contract.contractName,\n      sourceMap = contract.sourceMap,\n      deployedSourceMap = contract.deployedSourceMap,\n      primarySourceId = contract.primarySourceId;\n  var unreliableSourceOrder = compilation.unreliableSourceOrder,\n      sources = compilation.sources;\n  var sourcesToCheck; //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(function (source) {\n      return source && source.id === primarySourceId;\n    })];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    var sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n    var sourceId = extractPrimarySource(sourceMapString);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n\n  return sourcesToCheck.reduce(function (foundNode, source) {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n\n    if (!source.ast || source.language !== \"Solidity\") {\n      //ignore non-Solidity ASTs for now, we don't support them yet\n      return undefined;\n    }\n\n    return source.ast.nodes.find(function (node) {\n      return node.nodeType === \"ContractDefinition\" && node.name === contractName;\n    });\n  }, undefined);\n}\n\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\n\nfunction extractPrimarySource(sourceMap) {\n  if (!sourceMap) {\n    //HACK?\n    return 0; //in this case (e.g. a Vyper contract with an old-style\n    //source map) we infer that it was compiled by itself\n  }\n\n  return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || \"0\");\n}\n\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n  if (!generatedSources) {\n    return [];\n  }\n\n  if (!isGeneratedSources(generatedSources)) {\n    return generatedSources; //if already normalizeed, leave alone\n  }\n\n  var sources = []; //output\n\n  var _iterator3 = _createForOfIteratorHelper(generatedSources),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var source = _step3.value;\n      sources[source.id] = {\n        id: source.id.toString(),\n        sourcePath: source.name,\n        source: source.contents,\n        //ast needs to be coerced because schema doesn't quite match our types here...\n        ast: source.ast,\n        compiler: compiler,\n        language: source.language\n      };\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return sources;\n} //HACK\n\n\nfunction isGeneratedSources(sources) {\n  //note: for some reason arr.includes(undefined) returns true on sparse arrays\n  //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n  return sources.length > 0 && !sources.includes(undefined) && (sources[0].contents !== undefined || sources[0].name !== undefined);\n} //HACK, maybe?\n\n\nfunction inferLanguage(ast, compiler, sourcePath) {\n  if (ast) {\n    if (ast.nodeType === \"SourceUnit\") {\n      return \"Solidity\";\n    } else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n      //Every Yul source I've seen has YulBlock as the root, but\n      //I'm not sure that that's *always* the case\n      return \"Yul\";\n    } else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n      return \"Vyper\";\n    }\n  } else if (compiler) {\n    if (compiler.name === \"vyper\") {\n      return \"Vyper\";\n    } else if (compiler.name === \"solc\") {\n      //assuming sources compiled with solc without sourcePath are Solidity\n      if (sourcePath && sourcePath.endsWith(\".yul\")) {\n        return \"Yul\";\n      } else {\n        return \"Solidity\";\n      }\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n  //first: is this already there? only add it if it's not.\n  //(we determine this by sourcePath if present, and the actual source\n  //contents if not)\n  debug(\"sourcePath: %s\", sourceObject.sourcePath);\n  debug(\"given index: %d\", index);\n  debug(\"sources: %o\", sources.map(function (source) {\n    return source.sourcePath;\n  }));\n\n  if (sources.every(function (existingSource) {\n    return existingSource.sourcePath !== sourceObject.sourcePath || !sourceObject.sourcePath && !existingSource.sourcePath && existingSource.source !== sourceObject.source;\n  })) {\n    if (unreliableSourceOrder || index === undefined || index in sources) {\n      //if we can't add it at the correct spot, set the\n      //unreliable source order flag\n      debug(\"collision!\");\n      unreliableSourceOrder = true;\n    } //otherwise, just leave things alone\n\n\n    if (unreliableSourceOrder) {\n      //in case of unreliable source order, we'll ignore what indices\n      //things are *supposed* to have and just append things to the end\n      index = sources.length;\n    }\n\n    return {\n      index: index,\n      unreliableSourceOrder: unreliableSourceOrder\n    };\n  } else {\n    //return index: null indicates don't add this because it's\n    //already present\n    debug(\"already present, not adding\");\n    return {\n      index: null,\n      unreliableSourceOrder: unreliableSourceOrder\n    };\n  }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\n\n\nfunction simpleShimSourceMap(sourceMap) {\n  if (sourceMap === undefined) {\n    return undefined; //undefined case\n  } else if (typeof sourceMap === \"object\") {\n    return sourceMap.pc_pos_map_compressed; //Vyper object case\n  } else {\n    try {\n      return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n    } catch (_) {\n      return sourceMap; //Solidity case\n    }\n  }\n}\n\nexports.simpleShimSourceMap = simpleShimSourceMap;\n/**\n * collects user defined types & tagged outputs for a given set of compilations,\n * returning both the definition nodes and (for the types) the type objects\n *\n * \"Tagged outputs\" means user-defined things that are output by a contract\n * (not input to a contract), and which are distinguished by (potentially\n * ambiguous) selectors.  So, events and custom errors are tagged outputs.\n * Function arguments are not tagged outputs (they're not outputs).\n * Return values are not tagged outputs (they don't have a selector).\n * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n * be considered tagged outputs, but we're only looking at user-defined ones\n * here.\n */\n\nfunction collectUserDefinedTypesAndTaggedOutputs(compilations) {\n  var references = {};\n  var types = {};\n\n  var _iterator4 = _createForOfIteratorHelper(compilations),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var compilation = _step4.value;\n      references[compilation.id] = {};\n      types[compilation.id] = {\n        compiler: compilation.compiler,\n        types: {}\n      };\n\n      var _iterator5 = _createForOfIteratorHelper(compilation.sources),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var source = _step5.value;\n\n          if (!source) {\n            continue; //remember, sources could be empty if shimmed!\n          }\n\n          var ast = source.ast,\n              compiler = source.compiler,\n              language = source.language;\n\n          if (language === \"Solidity\" && ast) {\n            //don't check Yul or Vyper sources!\n            var _iterator6 = _createForOfIteratorHelper(ast.nodes),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var node = _step6.value;\n\n                if (node.nodeType === \"StructDefinition\" || node.nodeType === \"EnumDefinition\" || node.nodeType === \"UserDefinedValueTypeDefinition\" || node.nodeType === \"ContractDefinition\") {\n                  references[compilation.id][node.id] = node; //we don't have all the references yet, but we actually don't need them :)\n\n                  var dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);\n                  types[compilation.id].types[dataType.id] = dataType;\n                } else if (node.nodeType === \"EventDefinition\" || node.nodeType === \"ErrorDefinition\") {\n                  references[compilation.id][node.id] = node;\n                }\n\n                if (node.nodeType === \"ContractDefinition\") {\n                  var _iterator7 = _createForOfIteratorHelper(node.nodes),\n                      _step7;\n\n                  try {\n                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                      var subNode = _step7.value;\n\n                      if (subNode.nodeType === \"StructDefinition\" || subNode.nodeType === \"EnumDefinition\" || subNode.nodeType === \"UserDefinedValueTypeDefinition\") {\n                        references[compilation.id][subNode.id] = subNode; //we don't have all the references yet, but we only need the\n                        //reference to the defining contract, which we just added above!\n\n                        var _dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);\n\n                        types[compilation.id].types[_dataType.id] = _dataType;\n                      } else if (subNode.nodeType === \"EventDefinition\" || subNode.nodeType === \"ErrorDefinition\") {\n                        references[compilation.id][subNode.id] = subNode;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator7.e(err);\n                  } finally {\n                    _iterator7.f();\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return {\n    definitions: references,\n    typesByCompilation: types,\n    types: Format.Types.forgetCompilations(types)\n  };\n}\n\nexports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;\n\nfunction projectInfoIsCodecStyle(info) {\n  return Boolean(info.compilations);\n}\n\nfunction projectInfoIsCommonStyle(info) {\n  return Boolean(info.commonCompilations);\n}\n\nfunction projectInfoIsArtifacts(info) {\n  return Boolean(info.artifacts);\n}\n\nfunction infoToCompilations(projectInfo) {\n  if (!projectInfo) {\n    throw new errors_1.NoProjectInfoError();\n  }\n\n  if (projectInfoIsCodecStyle(projectInfo)) {\n    return projectInfo.compilations;\n  } else if (projectInfoIsCommonStyle(projectInfo)) {\n    return shimCompilations(projectInfo.commonCompilations);\n  } else if (projectInfoIsArtifacts(projectInfo)) {\n    return shimArtifacts(projectInfo.artifacts);\n  }\n}\n\nexports.infoToCompilations = infoToCompilations;","map":null,"metadata":{},"sourceType":"script"}