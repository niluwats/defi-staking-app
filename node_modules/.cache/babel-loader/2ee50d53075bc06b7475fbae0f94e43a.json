{"ast":null,"code":"import _toConsumableArray from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { VerbosityLevel } from '../configuration/VerbosityLevel.js';\nimport { ExecutionStatus } from './ExecutionStatus.js';\nexport var RunExecution = /*#__PURE__*/function () {\n  function RunExecution(verbosity, interruptedAsFailure) {\n    var _this = this;\n\n    _classCallCheck(this, RunExecution);\n\n    this.verbosity = verbosity;\n    this.interruptedAsFailure = interruptedAsFailure;\n\n    this.isSuccess = function () {\n      return _this.pathToFailure == null;\n    };\n\n    this.firstFailure = function () {\n      return _this.pathToFailure ? +_this.pathToFailure.split(':')[0] : -1;\n    };\n\n    this.numShrinks = function () {\n      return _this.pathToFailure ? _this.pathToFailure.split(':').length - 1 : 0;\n    };\n\n    this.rootExecutionTrees = [];\n    this.currentLevelExecutionTrees = this.rootExecutionTrees;\n    this.failure = null;\n    this.numSkips = 0;\n    this.numSuccesses = 0;\n    this.interrupted = false;\n  }\n\n  _createClass(RunExecution, [{\n    key: \"appendExecutionTree\",\n    value: function appendExecutionTree(status, value) {\n      var currentTree = {\n        status: status,\n        value: value,\n        children: []\n      };\n      this.currentLevelExecutionTrees.push(currentTree);\n      return currentTree;\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(value, id, message) {\n      if (this.verbosity >= VerbosityLevel.Verbose) {\n        var currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value);\n        this.currentLevelExecutionTrees = currentTree.children;\n      }\n\n      if (this.pathToFailure == null) this.pathToFailure = \"\".concat(id);else this.pathToFailure += \":\".concat(id);\n      this.value = value;\n      this.failure = message;\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(value) {\n      if (this.verbosity >= VerbosityLevel.VeryVerbose) {\n        this.appendExecutionTree(ExecutionStatus.Skipped, value);\n      }\n\n      if (this.pathToFailure == null) {\n        ++this.numSkips;\n      }\n    }\n  }, {\n    key: \"success\",\n    value: function success(value) {\n      if (this.verbosity >= VerbosityLevel.VeryVerbose) {\n        this.appendExecutionTree(ExecutionStatus.Success, value);\n      }\n\n      if (this.pathToFailure == null) {\n        ++this.numSuccesses;\n      }\n    }\n  }, {\n    key: \"interrupt\",\n    value: function interrupt() {\n      this.interrupted = true;\n    }\n  }, {\n    key: \"extractFailures\",\n    value: function extractFailures() {\n      if (this.isSuccess()) {\n        return [];\n      }\n\n      var failures = [];\n      var cursor = this.rootExecutionTrees;\n\n      while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {\n        var failureTree = cursor[cursor.length - 1];\n        failures.push(failureTree.value);\n        cursor = failureTree.children;\n      }\n\n      return failures;\n    }\n  }, {\n    key: \"toRunDetails\",\n    value: function toRunDetails(seed, basePath, maxSkips, qParams) {\n      if (!this.isSuccess()) {\n        return {\n          failed: true,\n          interrupted: this.interrupted,\n          numRuns: this.firstFailure() + 1 - this.numSkips,\n          numSkips: this.numSkips,\n          numShrinks: this.numShrinks(),\n          seed: seed,\n          counterexample: this.value,\n          counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),\n          error: this.failure,\n          failures: this.extractFailures(),\n          executionSummary: this.rootExecutionTrees,\n          verbose: this.verbosity,\n          runConfiguration: qParams.toParameters()\n        };\n      }\n\n      var failed = this.numSkips > maxSkips || this.interrupted && this.interruptedAsFailure;\n      return {\n        failed: failed,\n        interrupted: this.interrupted,\n        numRuns: this.numSuccesses,\n        numSkips: this.numSkips,\n        numShrinks: 0,\n        seed: seed,\n        counterexample: null,\n        counterexamplePath: null,\n        error: null,\n        failures: [],\n        executionSummary: this.rootExecutionTrees,\n        verbose: this.verbosity,\n        runConfiguration: qParams.toParameters()\n      };\n    }\n  }]);\n\n  return RunExecution;\n}();\n\nRunExecution.mergePaths = function (offsetPath, path) {\n  if (offsetPath.length === 0) return path;\n  var offsetItems = offsetPath.split(':');\n  var remainingItems = path.split(':');\n  var middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];\n  return [].concat(_toConsumableArray(offsetItems.slice(0, offsetItems.length - 1)), [\"\".concat(middle)], _toConsumableArray(remainingItems.slice(1))).join(':');\n};","map":null,"metadata":{},"sourceType":"module"}