{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbi),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiReferenceByAddress),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiReferenceStatic),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiStructByPosition),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiTupleByPosition);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar errors_1 = require(\"../../errors\");\n\nfunction decodeAbi(dataType, pointer, info) {\n  var options,\n      dynamic,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbi$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n          if (!(Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\")) {\n            _context.next = 18;\n            break;\n          }\n\n          _context.prev = 2;\n          dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n          _context.next = 9;\n          break;\n\n        case 6:\n          _context.prev = 6;\n          _context.t0 = _context[\"catch\"](2);\n          return _context.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context.t0, options.strictAbiMode));\n\n        case 9:\n          if (!dynamic) {\n            _context.next = 14;\n            break;\n          }\n\n          return _context.delegateYield(decodeAbiReferenceByAddress(dataType, pointer, info, options), \"t1\", 11);\n\n        case 11:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 14:\n          return _context.delegateYield(decodeAbiReferenceStatic(dataType, pointer, info, options), \"t2\", 15);\n\n        case 15:\n          return _context.abrupt(\"return\", _context.t2);\n\n        case 16:\n          _context.next = 21;\n          break;\n\n        case 18:\n          debug(\"pointer %o\", pointer);\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), \"t3\", 20);\n\n        case 20:\n          return _context.abrupt(\"return\", _context.t3);\n\n        case 21:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 6]]);\n}\n\nexports.decodeAbi = decodeAbi;\n\nfunction decodeAbiReferenceByAddress(dataType, pointer, info) {\n  var options,\n      strict,\n      base,\n      lengthOverride,\n      allocations,\n      state,\n      location,\n      rawValue,\n      rawValueAsBN,\n      rawValueAsNumber,\n      error,\n      startPosition,\n      dynamic,\n      size,\n      _allocate_1$abiSizeIn,\n      staticPointer,\n      length,\n      lengthAsBN,\n      rawLength,\n      childPointer,\n      baseSize,\n      decodedChildren,\n      index,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeAbiReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n          strict = options.strictAbiMode, base = options.abiPointerBase, lengthOverride = options.lengthOverride;\n          base = base || 0; //in case base was undefined\n\n          allocations = info.allocations.abi, state = info.state;\n          debug(\"pointer %o\", pointer); //this variable holds the location we should look to *next*\n          //stack pointers point to calldata; other pointers point to same location\n\n          location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n\n          if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n            //length overrides are only applicable when you're decoding a pointer\n            //from the stack!  otherwise they must be ignored!\n            lengthOverride = undefined;\n          }\n\n          _context2.prev = 7;\n          return _context2.delegateYield(read_1.default(pointer, state), \"t0\", 9);\n\n        case 9:\n          rawValue = _context2.t0;\n          _context2.next = 15;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t1 = _context2[\"catch\"](7);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t1, strict));\n\n        case 15:\n          rawValueAsBN = Conversion.toBN(rawValue);\n          debug(\"rawValue: %O\", rawValue);\n          debug(\"rawValueAsBN: %O\", rawValueAsBN);\n          _context2.prev = 18;\n          rawValueAsNumber = rawValueAsBN.toNumber();\n          _context2.next = 28;\n          break;\n\n        case 22:\n          _context2.prev = 22;\n          _context2.t2 = _context2[\"catch\"](18);\n          error = {\n            kind: \"OverlargePointersNotImplementedError\",\n            pointerAsBN: rawValueAsBN\n          };\n\n          if (!strict) {\n            _context2.next = 27;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 27:\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 28:\n          startPosition = rawValueAsNumber + base;\n          debug(\"startPosition %d\", startPosition);\n          _context2.prev = 30;\n          _allocate_1$abiSizeIn = allocate_1.abiSizeInfo(dataType, allocations);\n          dynamic = _allocate_1$abiSizeIn.dynamic;\n          size = _allocate_1$abiSizeIn.size;\n          _context2.next = 39;\n          break;\n\n        case 36:\n          _context2.prev = 36;\n          _context2.t3 = _context2[\"catch\"](30);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t3, strict));\n\n        case 39:\n          if (dynamic) {\n            _context2.next = 43;\n            break;\n          }\n\n          //this will only come up when called from stack.ts\n          staticPointer = {\n            location: location,\n            start: startPosition,\n            length: size\n          };\n          return _context2.delegateYield(decodeAbiReferenceStatic(dataType, staticPointer, info, options), \"t4\", 42);\n\n        case 42:\n          return _context2.abrupt(\"return\", _context2.t4);\n\n        case 43:\n          _context2.t5 = dataType.typeClass;\n          _context2.next = _context2.t5 === \"bytes\" ? 46 : _context2.t5 === \"string\" ? 46 : _context2.t5 === \"array\" ? 72 : _context2.t5 === \"struct\" ? 118 : _context2.t5 === \"tuple\" ? 120 : 122;\n          break;\n\n        case 46:\n          if (!(lengthOverride !== undefined)) {\n            _context2.next = 50;\n            break;\n          }\n\n          lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;\n          //if a length override is given, that means the given start\n          //position skips over the length word!\n\n          _context2.next = 60;\n          break;\n\n        case 50:\n          _context2.prev = 50;\n          return _context2.delegateYield(read_1.default({\n            location: location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t6\", 52);\n\n        case 52:\n          rawLength = _context2.t6;\n          _context2.next = 58;\n          break;\n\n        case 55:\n          _context2.prev = 55;\n          _context2.t7 = _context2[\"catch\"](50);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t7, strict));\n\n        case 58:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n          //so it'll be set up to read the data\n\n        case 60:\n          if (!(strict && lengthAsBN.gtn(state[location].length))) {\n            _context2.next = 62;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArrayOrStringStrictModeError\",\n            lengthAsBN: lengthAsBN,\n            dataLength: state[location].length\n          });\n\n        case 62:\n          _context2.prev = 62;\n          length = lengthAsBN.toNumber();\n          _context2.next = 69;\n          break;\n\n        case 66:\n          _context2.prev = 66;\n          _context2.t8 = _context2[\"catch\"](62);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 69:\n          childPointer = {\n            location: location,\n            start: startPosition,\n            length: length\n          };\n          return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info, options), \"t9\", 71);\n\n        case 71:\n          return _context2.abrupt(\"return\", _context2.t9);\n\n        case 72:\n          if (!(dataType.kind === \"static\")) {\n            _context2.next = 76;\n            break;\n          }\n\n          //static-length array\n          lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't\n          //include a length word!\n\n          _context2.next = 91;\n          break;\n\n        case 76:\n          if (!(lengthOverride !== undefined)) {\n            _context2.next = 81;\n            break;\n          }\n\n          debug(\"override: %o\", lengthOverride); //dynamic-length array, but with length override\n\n          lengthAsBN = lengthOverride; //we don't increment start position; if a length override was\n          //given, that means the pointer skipped the length word!\n\n          _context2.next = 91;\n          break;\n\n        case 81:\n          _context2.prev = 81;\n          return _context2.delegateYield(read_1.default({\n            location: location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t10\", 83);\n\n        case 83:\n          rawLength = _context2.t10;\n          _context2.next = 89;\n          break;\n\n        case 86:\n          _context2.prev = 86;\n          _context2.t11 = _context2[\"catch\"](81);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t11, strict));\n\n        case 89:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n\n        case 91:\n          if (!(strict && lengthAsBN.gtn(state[location].length))) {\n            _context2.next = 93;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN: lengthAsBN,\n            dataLength: state[location].length\n          });\n\n        case 93:\n          _context2.prev = 93;\n          length = lengthAsBN.toNumber();\n          _context2.next = 100;\n          break;\n\n        case 97:\n          _context2.prev = 97;\n          _context2.t12 = _context2[\"catch\"](93);\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 100:\n          _context2.prev = 100;\n          baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n          _context2.next = 107;\n          break;\n\n        case 104:\n          _context2.prev = 104;\n          _context2.t13 = _context2[\"catch\"](100);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t13, strict));\n\n        case 107:\n          decodedChildren = [];\n          index = 0;\n\n        case 109:\n          if (!(index < length)) {\n            _context2.next = 117;\n            break;\n          }\n\n          _context2.t14 = decodedChildren;\n          return _context2.delegateYield(decodeAbi(dataType.baseType, {\n            location: location,\n            start: startPosition + index * baseSize,\n            length: baseSize\n          }, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t15\", 112);\n\n        case 112:\n          _context2.t16 = _context2.t15;\n\n          _context2.t14.push.call(_context2.t14, _context2.t16);\n\n        case 114:\n          index++;\n          _context2.next = 109;\n          break;\n\n        case 117:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 118:\n          return _context2.delegateYield(decodeAbiStructByPosition(dataType, location, startPosition, info, options), \"t17\", 119);\n\n        case 119:\n          return _context2.abrupt(\"return\", _context2.t17);\n\n        case 120:\n          return _context2.delegateYield(decodeAbiTupleByPosition(dataType, location, startPosition, info, options), \"t18\", 121);\n\n        case 121:\n          return _context2.abrupt(\"return\", _context2.t18);\n\n        case 122:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[7, 12], [18, 22], [30, 36], [50, 55], [62, 66], [81, 86], [93, 97], [100, 104]]);\n}\n\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\n\nfunction decodeAbiReferenceStatic(dataType, pointer, info) {\n  var options,\n      location,\n      lengthAsBN,\n      length,\n      error,\n      baseSize,\n      decodedChildren,\n      index,\n      _args3 = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbiReferenceStatic$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};\n          debug(\"static\");\n          debug(\"pointer %o\", pointer);\n          location = pointer.location;\n          _context3.t0 = dataType.typeClass;\n          _context3.next = _context3.t0 === \"array\" ? 7 : _context3.t0 === \"struct\" ? 36 : _context3.t0 === \"tuple\" ? 38 : 40;\n          break;\n\n        case 7:\n          //we're in the static case, so we know the array must be statically sized\n          lengthAsBN = dataType.length;\n          _context3.prev = 8;\n          length = lengthAsBN.toNumber();\n          _context3.next = 18;\n          break;\n\n        case 12:\n          _context3.prev = 12;\n          _context3.t1 = _context3[\"catch\"](8);\n          //note: since this is the static case, we don't bother including the stronger\n          //strict-mode guard against getting DOSed by large array sizes, since in this\n          //case we're not reading the size from the input; if there's a huge static size\n          //array, well, we'll just have to deal with it\n          error = {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN: lengthAsBN\n          };\n\n          if (!options.strictAbiMode) {\n            _context3.next = 17;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 17:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 18:\n          _context3.prev = 18;\n          baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n          _context3.next = 25;\n          break;\n\n        case 22:\n          _context3.prev = 22;\n          _context3.t2 = _context3[\"catch\"](18);\n          return _context3.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context3.t2, options.strictAbiMode));\n\n        case 25:\n          decodedChildren = [];\n          index = 0;\n\n        case 27:\n          if (!(index < length)) {\n            _context3.next = 35;\n            break;\n          }\n\n          _context3.t3 = decodedChildren;\n          return _context3.delegateYield(decodeAbi(dataType.baseType, {\n            location: location,\n            start: pointer.start + index * baseSize,\n            length: baseSize\n          }, info, options), \"t4\", 30);\n\n        case 30:\n          _context3.t5 = _context3.t4;\n\n          _context3.t3.push.call(_context3.t3, _context3.t5);\n\n        case 32:\n          index++;\n          _context3.next = 27;\n          break;\n\n        case 35:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 36:\n          return _context3.delegateYield(decodeAbiStructByPosition(dataType, location, pointer.start, info, options), \"t6\", 37);\n\n        case 37:\n          return _context3.abrupt(\"return\", _context3.t6);\n\n        case 38:\n          return _context3.delegateYield(decodeAbiTupleByPosition(dataType, location, pointer.start, info, options), \"t7\", 39);\n\n        case 39:\n          return _context3.abrupt(\"return\", _context3.t7);\n\n        case 40:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[8, 12], [18, 22]]);\n}\n\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer\n\nfunction decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  var options,\n      allocations,\n      typeLocation,\n      typeId,\n      structAllocation,\n      error,\n      decodedMembers,\n      index,\n      memberAllocation,\n      memberPointer,\n      childPointer,\n      memberName,\n      memberType,\n      _args4 = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbiStructByPosition$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : {};\n          allocations = info.allocations.abi;\n          typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context4.next = 10;\n            break;\n          }\n\n          error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: dataType\n          };\n\n          if (!(options.strictAbiMode || options.allowRetry)) {\n            _context4.next = 9;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error, true);\n\n        case 9:\n          return _context4.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 10:\n          decodedMembers = [];\n          index = 0;\n\n        case 12:\n          if (!(index < structAllocation.members.length)) {\n            _context4.next = 27;\n            break;\n          }\n\n          memberAllocation = structAllocation.members[index];\n          memberPointer = memberAllocation.pointer;\n          childPointer = {\n            location: location,\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length\n          };\n          memberName = memberAllocation.name;\n          memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n          _context4.t0 = decodedMembers;\n          _context4.t1 = memberName;\n          return _context4.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t2\", 21);\n\n        case 21:\n          _context4.t3 = _context4.t2;\n          _context4.t4 = {\n            name: _context4.t1,\n            value: _context4.t3\n          };\n\n          _context4.t0.push.call(_context4.t0, _context4.t4);\n\n        case 24:\n          index++;\n          _context4.next = 12;\n          break;\n\n        case 27:\n          return _context4.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 28:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n} //note that this function takes the start position as a *number*; it does not take a pointer\n\n\nfunction decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  var options,\n      decodedMembers,\n      position,\n      _iterator,\n      _step,\n      _step$value,\n      name,\n      memberType,\n      memberSize,\n      childPointer,\n      _args5 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeAbiTupleByPosition$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          options = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};\n          //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n          //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n          //However it may be worth revisiting this in the future if performance turns out to be a problem\n          //(changing this may be pretty hard though)\n          decodedMembers = [];\n          position = startPosition;\n          _iterator = _createForOfIteratorHelper(dataType.memberTypes);\n          _context5.prev = 4;\n\n          _iterator.s();\n\n        case 6:\n          if ((_step = _iterator.n()).done) {\n            _context5.next = 19;\n            break;\n          }\n\n          _step$value = _step.value, name = _step$value.name, memberType = _step$value.type;\n          memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n          childPointer = {\n            location: location,\n            start: position,\n            length: memberSize\n          };\n          _context5.t0 = decodedMembers;\n          _context5.t1 = name;\n          return _context5.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t2\", 13);\n\n        case 13:\n          _context5.t3 = _context5.t2;\n          _context5.t4 = {\n            name: _context5.t1,\n            value: _context5.t3\n          };\n\n          _context5.t0.push.call(_context5.t0, _context5.t4);\n\n          position += memberSize;\n\n        case 17:\n          _context5.next = 6;\n          break;\n\n        case 19:\n          _context5.next = 24;\n          break;\n\n        case 21:\n          _context5.prev = 21;\n          _context5.t5 = _context5[\"catch\"](4);\n\n          _iterator.e(_context5.t5);\n\n        case 24:\n          _context5.prev = 24;\n\n          _iterator.f();\n\n          return _context5.finish(24);\n\n        case 27:\n          return _context5.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 28:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5, null, [[4, 21, 24, 27]]);\n}","map":null,"metadata":{},"sourceType":"script"}