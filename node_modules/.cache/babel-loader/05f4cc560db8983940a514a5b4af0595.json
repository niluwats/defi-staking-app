{"ast":null,"code":"var _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _defineProperty = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar debug = require(\"debug\")(\"contract:manual-send\");\n\nvar ethers = require(\"ethers\");\n\nvar Utils = require(\"./utils\");\n\nvar _require = require(\"web3-core-helpers\"),\n    formatters = _require.formatters; //used for reproducing web3's behavior\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\n\n\nfunction sendTransactionManual(_x, _x2, _x3) {\n  return _sendTransactionManual.apply(this, arguments);\n}\n\nfunction _sendTransactionManual() {\n  _sendTransactionManual = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(web3, params, promiEvent) {\n    var ethersProvider, _setUpParameters, transaction, from, account, ethersSigner, txHash, receipt, ethersResponse, _handleError;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            debug(\"executing manually!\"); //set up ethers provider\n\n            ethersProvider = new ethers.providers.Web3Provider(web3.currentProvider); //let's clone params and set it up properly\n\n            _setUpParameters = setUpParameters(params, web3), transaction = _setUpParameters.transaction, from = _setUpParameters.from; //now: if the from address is in the wallet, web3 will sign the transaction before\n            //sending, so we have to account for that\n\n            account = web3.eth.accounts.wallet[from];\n            ethersSigner = account ? new ethers.Wallet(account.privateKey, ethersProvider) : ethersProvider.getSigner(from);\n            debug(\"got signer\");\n            _context.prev = 6;\n            _context.next = 9;\n            return ethersSigner.sendTransaction(transaction);\n\n          case 9:\n            ethersResponse = _context.sent;\n            txHash = ethersResponse.hash;\n            _context.next = 13;\n            return ethersProvider.waitForTransaction(txHash);\n\n          case 13:\n            receipt = _context.sent;\n            debug(\"no error\");\n            _context.next = 26;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](6);\n            _handleError = handleError(_context.t0);\n            txHash = _handleError.txHash;\n            receipt = _handleError.receipt;\n\n            if (receipt) {\n              _context.next = 26;\n              break;\n            }\n\n            _context.next = 25;\n            return ethersProvider.waitForTransaction(txHash);\n\n          case 25:\n            receipt = _context.sent;\n\n          case 26:\n            debug(\"txHash: %s\", txHash);\n            receipt = translateReceipt(receipt);\n            promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n\n            _context.next = 31;\n            return handleResult(receipt, transaction.to == null);\n\n          case 31:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 32:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[6, 17]]);\n  }));\n  return _sendTransactionManual.apply(this, arguments);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return {\n      txHash: error.data.hash\n    };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    var transactionHash = Object.keys(error.data).find(function (key) {\n      return key !== \"stack\" && key !== \"name\";\n    });\n    return {\n      txHash: transactionHash\n    };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nfunction handleResult(_x4, _x5) {\n  return _handleResult.apply(this, arguments);\n}\n\nfunction _handleResult() {\n  _handleResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(receipt, isDeployment) {\n    var deploymentFailedMessage;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n\n            if (!receipt.status) {\n              _context2.next = 11;\n              break;\n            }\n\n            if (!isDeployment) {\n              _context2.next = 8;\n              break;\n            }\n\n            _context2.next = 5;\n            return web3.eth.getCode(receipt.contractAddress);\n\n          case 5:\n            _context2.t0 = _context2.sent;\n\n            if (!(_context2.t0 === \"0x\")) {\n              _context2.next = 8;\n              break;\n            }\n\n            throw new Error(deploymentFailedMessage);\n\n          case 8:\n            return _context2.abrupt(\"return\", receipt);\n\n          case 11:\n            if (!isDeployment) {\n              _context2.next = 13;\n              break;\n            }\n\n            throw new Error(deploymentFailedMessage);\n\n          case 13:\n            throw new Error(\"Transaction has been reverted by the EVM:\" + \"\\n\" + JSON.stringify(receipt));\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _handleResult.apply(this, arguments);\n}\n\nfunction setUpParameters(params, web3) {\n  var transaction = Object.assign({}, params);\n  transaction.from = transaction.from != undefined ? transaction.from : web3.eth.defaultAccount; //now let's have web3 check our inputs\n\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas; //also, it insists \"from\" be kept separate\n\n  var _transaction = transaction,\n      from = _transaction.from;\n  delete transaction.from;\n  return {\n    transaction: transaction,\n    from: from\n  };\n} //translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\n\n\nfunction translateReceipt(receipt) {\n  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(receipt).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return _defineProperty({}, key, Utils.is_big_number(value) ? value.toNumber() : value);\n  }))));\n}\n\nmodule.exports = {\n  sendTransactionManual: sendTransactionManual\n};","map":null,"metadata":{},"sourceType":"script"}