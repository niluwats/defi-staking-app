{"ast":null,"code":"var _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar debug = require(\"debug\")(\"contract:handlers\");\n\nvar StatusError = require(\"./statuserror\");\n\nvar Utils = require(\"./utils\");\n\nvar Reason = require(\"./reason\");\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\n\n\nvar handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash web3 timeout errors at user's request.\n   * @param  {Object} contract contract instance\n   * @param  {Object} message  error message\n   * @return {Boolean}\n   */\n  ignoreTimeoutError: function ignoreTimeoutError(_ref, _ref2) {\n    var contract = _ref.contract;\n    var message = _ref2.message;\n    var timedOut = message && message.includes(handlers.timeoutMessage);\n    var shouldWait = contract && contract.timeoutBlocks && contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    var waitForTxPropagation = message && message.includes(handlers.defaultWeb3Error);\n    return shouldWait && (timedOut || waitForTxPropagation);\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function setup(emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context)); // web3 block polls if the confirmation listener is enabled so we want to\n    // give users a way of opting out of this behavior - it causes problems in testing\n\n    if (!context.contract.disableConfirmationListener) {\n      emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    }\n\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function error(context, _error) {\n    if (!handlers.ignoreTimeoutError(context, _error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", _error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function hash(context, _hash) {\n    context.transactionHash = _hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", _hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function confirmation(context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt); // Per web3: initial confirmation index is 0\n\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: function () {\n    var _receipt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(context, _receipt) {\n      var reason, error;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // keep around the raw (not decoded) logs in the raw logs field as a\n              // stopgap until we can get the ABI for all events, not just the current\n              // contract\n              _receipt.rawLogs = _receipt.logs; // Decode logs, use as receipt.logs for ease of use.\n\n              _context.prev = 1;\n              _receipt.logs = _receipt.logs ? Utils.decodeLogs.call(context.contract, _receipt.logs) : [];\n              _context.next = 8;\n              break;\n\n            case 5:\n              _context.prev = 5;\n              _context.t0 = _context[\"catch\"](1);\n              return _context.abrupt(\"return\", context.promiEvent.reject(_context.t0));\n\n            case 8:\n              // Emit receipt\n              context.promiEvent.eventEmitter.emit(\"receipt\", _receipt); // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n\n              if (!context.onlyEmitReceipt) {\n                _context.next = 12;\n                break;\n              }\n\n              context.receipt = _receipt;\n              return _context.abrupt(\"return\");\n\n            case 12:\n              if (!(_receipt.status !== undefined && !_receipt.status)) {\n                _context.next = 18;\n                break;\n              }\n\n              _context.next = 15;\n              return Reason.get(context.params, context.contract.web3, context.contract.interfaceAdapter);\n\n            case 15:\n              reason = _context.sent;\n              error = new StatusError(context.params, _receipt.transactionHash, _receipt, reason);\n              return _context.abrupt(\"return\", context.promiEvent.reject(error));\n\n            case 18:\n              // This object has some duplicate data but is backward compatible.\n              context.promiEvent.resolve({\n                tx: _receipt.transactionHash,\n                receipt: _receipt,\n                logs: _receipt.logs\n              }); //HACK: adding this conditional for when the handler is invoked\n              //manually during stacktracing\n\n              if (this.removeListener) {\n                this.removeListener(\"receipt\", handlers.receipt);\n              }\n\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[1, 5]]);\n    }));\n\n    function receipt(_x, _x2) {\n      return _receipt2.apply(this, arguments);\n    }\n\n    return receipt;\n  }()\n};\nmodule.exports = handlers;","map":null,"metadata":{},"sourceType":"script"}