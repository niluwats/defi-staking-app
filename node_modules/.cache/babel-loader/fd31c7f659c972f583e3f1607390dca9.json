{"ast":null,"code":"var _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _require = require(\"@truffle/interface-adapter\"),\n    Web3Shim = _require.Web3Shim,\n    createInterfaceAdapter = _require.createInterfaceAdapter;\n\nvar utils = require(\"../utils\");\n\nvar execute = require(\"../execute\");\n\nvar bootstrap = require(\"./bootstrap\");\n\nvar debug = require(\"debug\")(\"contract:contract:constructorMethods\");\n\nvar OS = require(\"os\");\n\nmodule.exports = function (Contract) {\n  return {\n    configureNetwork: function configureNetwork() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          networkType = _ref.networkType,\n          provider = _ref.provider;\n\n      // otherwise use existing value as default (at most one of these)\n      networkType = networkType || this.networkType;\n      provider = provider || this.currentProvider; // recreate interfaceadapter\n\n      this.interfaceAdapter = createInterfaceAdapter({\n        networkType: networkType,\n        provider: provider\n      });\n\n      if (this.web3) {\n        // update existing\n        this.web3.setNetworkType(networkType);\n        this.web3.setProvider(provider);\n      } else {\n        // create new\n        this.web3 = new Web3Shim({\n          networkType: networkType,\n          provider: provider\n        });\n      } // save properties\n\n\n      this.currentProvider = provider;\n      this.networkType = networkType;\n    },\n    setProvider: function setProvider(provider) {\n      if (!provider) {\n        throw new Error(\"Invalid provider passed to setProvider(); provider is \".concat(provider));\n      }\n\n      this.configureNetwork({\n        provider: provider\n      });\n    },\n    new: function _new() {\n      utils.checkProvider(this);\n\n      if (!this.bytecode || this.bytecode === \"0x\") {\n        throw new Error(\"\".concat(this.contractName, \" error: contract binary not set. Can't deploy new instance.\\n\") + \"This contract may be abstract, not implement an abstract parent's methods completely\\n\" + \"or not invoke an inherited contract's constructor correctly\\n\");\n      }\n\n      var constructorABI = this.abi.filter(function (i) {\n        return i.type === \"constructor\";\n      })[0];\n      return execute.deploy.call(this, constructorABI).apply(void 0, arguments);\n    },\n    at: function () {\n      var _at = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n        var onChainCode;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(address == null || typeof address !== \"string\" || address.length !== 42)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Invalid address passed to \".concat(this.contractName, \".at(): \").concat(address));\n\n              case 2:\n                _context.next = 4;\n                return this.detectNetwork();\n\n              case 4:\n                _context.next = 6;\n                return this.interfaceAdapter.getCode(address);\n\n              case 6:\n                onChainCode = _context.sent;\n                _context.next = 9;\n                return utils.checkCode(onChainCode, this.contractName, address);\n\n              case 9:\n                return _context.abrupt(\"return\", new this(address));\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function at(_x) {\n        return _at.apply(this, arguments);\n      }\n\n      return at;\n    }(),\n    deployed: function () {\n      var _deployed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.reloadJson) {\n                  this.reloadJson(); //truffle test monkey-patches in this method\n                }\n\n                utils.checkProvider(this);\n                _context2.next = 4;\n                return this.detectNetwork();\n\n              case 4:\n                utils.checkNetworkArtifactMatch(this);\n                utils.checkDeployment(this);\n                return _context2.abrupt(\"return\", new this(this.address));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function deployed() {\n        return _deployed.apply(this, arguments);\n      }\n\n      return deployed;\n    }(),\n    defaults: function defaults(class_defaults) {\n      var _this = this;\n\n      if (this.class_defaults == null) {\n        this.class_defaults = {};\n      }\n\n      if (class_defaults == null) {\n        class_defaults = {};\n      }\n\n      Object.keys(class_defaults).forEach(function (key) {\n        var value = class_defaults[key];\n        _this.class_defaults[key] = value;\n      });\n      return this.class_defaults;\n    },\n    hasNetwork: function hasNetwork(network_id) {\n      return this._json.networks[\"\".concat(network_id)] != null;\n    },\n    isDeployed: function isDeployed() {\n      if (this.network_id == null) {\n        return false;\n      }\n\n      if (this._json.networks[this.network_id] == null) {\n        return false;\n      }\n\n      return !!this.network.address;\n    },\n    detectNetwork: function () {\n      var _detectNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _yield$this$interface, _gasLimit, chainNetworkID, _yield$this$interface2, gasLimit;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.network_id && this.networks[this.network_id] != null)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.interfaceAdapter.getBlock(\"latest\");\n\n              case 3:\n                _yield$this$interface = _context3.sent;\n                _gasLimit = _yield$this$interface.gasLimit;\n                return _context3.abrupt(\"return\", {\n                  id: this.network_id,\n                  blockLimit: _gasLimit\n                });\n\n              case 6:\n                _context3.next = 8;\n                return this.interfaceAdapter.getNetworkId();\n\n              case 8:\n                chainNetworkID = _context3.sent;\n                _context3.next = 11;\n                return this.interfaceAdapter.getBlock(\"latest\");\n\n              case 11:\n                _yield$this$interface2 = _context3.sent;\n                gasLimit = _yield$this$interface2.gasLimit;\n                _context3.next = 15;\n                return utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n\n              case 15:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function detectNetwork() {\n        return _detectNetwork.apply(this, arguments);\n      }\n\n      return detectNetwork;\n    }(),\n    setNetwork: function setNetwork(network_id) {\n      if (!network_id) return;\n      this.network_id = \"\".concat(network_id);\n    },\n    setNetworkType: function setNetworkType() {\n      var networkType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ethereum\";\n      this.configureNetwork({\n        networkType: networkType\n      });\n    },\n    setWallet: function setWallet(wallet) {\n      this.configureNetwork();\n      this.web3.eth.accounts.wallet = wallet;\n    },\n    // Overrides the deployed address to null.\n    // You must call this explicitly so you don't inadvertently do this otherwise.\n    resetAddress: function resetAddress() {\n      delete this.network.address;\n    },\n    // accepts 4 input formats\n    //  - (<name>, <address>)\n    //  - (<contractType>) - must have a deployed instance with an address\n    //  - (<contractInstance>)\n    //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n    link: function link(name, address) {\n      var _this2 = this;\n\n      switch (typeof name) {\n        case \"string\":\n          // Case: Contract.link(<libraryName>, <address>)\n          if (this._json.networks[this.network_id] == null) {\n            this._json.networks[this.network_id] = {\n              events: {},\n              links: {}\n            };\n          }\n\n          this.network.links[name] = address;\n          return;\n\n        case \"function\":\n          // Case: Contract.link(<contractType>)\n          var contract = name;\n\n          if (contract.isDeployed() === false) {\n            throw new Error(\"Cannot link contract without an address.\");\n          }\n\n          this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n          Object.keys(contract.events).forEach(function (topic) {\n            _this2.network.events[topic] = contract.events[topic];\n          });\n          return;\n\n        case \"object\":\n          // 2 Cases:\n          //   - Contract.link({<libraryName>: <address>, ... })\n          //   - Contract.link(<instance>)\n          var obj = name;\n\n          if (obj.constructor && typeof obj.constructor.contractName === \"string\" && obj.address) {\n            // obj is a Truffle contract instance\n            this.link(obj.constructor.contractName, obj.address);\n          } else {\n            // obj is of the form { <libraryName>: <address>, ... }\n            Object.keys(obj).forEach(function (name) {\n              return _this2.link(name, obj[name]);\n            });\n          }\n\n          return;\n\n        default:\n          var invalidInput = \"Input to the link method is in the incorrect\" + \" format. Input must be one of the following:\".concat(OS.EOL) + \"    - a library name and address                 > (\\\"MyLibrary\\\", \" + \"\\\"0x123456789...\\\")\".concat(OS.EOL) + \"    - a contract type                            > \" + \"(MyContract)\".concat(OS.EOL) + \"    - a contract instance                        > \" + \"(myContract)\".concat(OS.EOL) + \"    - an object with library names and addresses > ({ <libName>: \" + \"<address>, <libName2>: <address2>, ... })\".concat(OS.EOL);\n          throw new Error(invalidInput);\n      }\n    },\n    // Note, this function can be called with two input types:\n    // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n    // 2. network id; this will clone the contract and set a specific network id upon cloning.\n    clone: function clone(json) {\n      json = json || {};\n\n      var temp = function TruffleContract() {\n        this.constructor = temp;\n        return Contract.apply(this, arguments);\n      };\n\n      temp.prototype = Object.create(this.prototype);\n      var network_id; // If we have a network id passed\n\n      if (typeof json !== \"object\") {\n        network_id = json;\n        json = this._json;\n      }\n\n      json = utils.merge({}, this._json || {}, json);\n      temp._constructorMethods = this._constructorMethods;\n      temp._properties = this._properties;\n      temp._property_values = {};\n      temp._json = json;\n      bootstrap(temp);\n      temp.class_defaults = temp.prototype.defaults || {};\n\n      if (network_id) {\n        temp.setNetwork(network_id);\n      }\n\n      if (this.currentProvider) {\n        temp.configureNetwork({\n          provider: this.currentProvider,\n          networkType: this.networkType\n        });\n      } // Copy over custom key/values to the contract class\n\n\n      Object.keys(json).forEach(function (key) {\n        if (key.indexOf(\"x-\") !== 0) return;\n        temp[key] = json[key];\n      });\n      return temp;\n    },\n    addProp: function addProp(key, fn) {\n      var _this3 = this;\n\n      var getter = function getter() {\n        if (fn.get != null) {\n          return fn.get.call(_this3);\n        }\n\n        return _this3._property_values[key] || fn.call(_this3);\n      };\n\n      var setter = function setter(val) {\n        if (fn.set != null) {\n          fn.set.call(_this3, val);\n          return;\n        } // If there's not a setter, then the property is immutable.\n\n\n        throw new Error(\"\".concat(key, \" property is immutable\"));\n      };\n\n      var definition = {};\n      definition.enumerable = false;\n      definition.configurable = false;\n      definition.get = getter;\n      definition.set = setter;\n      Object.defineProperty(this, key, definition);\n    },\n    toJSON: function toJSON() {\n      return this._json;\n    },\n    decodeLogs: utils.decodeLogs\n  };\n};","map":null,"metadata":{},"sourceType":"script"}