{"ast":null,"code":"import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { integer } from './integer.js';\nimport { nat } from './nat.js';\nimport { set } from './set.js';\nimport { tuple } from './tuple.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\n\nfunction extractMaxIndex(indexesAndValues) {\n  var maxIndex = -1;\n\n  for (var index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n\n  return maxIndex;\n}\n\nfunction arrayFromItems(length, indexesAndValues) {\n  var array = Array(length);\n\n  for (var index = 0; index !== indexesAndValues.length; ++index) {\n    var it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n\n  return array;\n}\n\nexport function sparseArray(arb) {\n  var constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _constraints$minNumEl = constraints.minNumElements,\n      minNumElements = _constraints$minNumEl === void 0 ? 0 : _constraints$minNumEl,\n      _constraints$maxNumEl = constraints.maxNumElements,\n      maxNumElements = _constraints$maxNumEl === void 0 ? maxLengthFromMinLength(minNumElements) : _constraints$maxNumEl,\n      _constraints$maxLengt = constraints.maxLength,\n      maxLength = _constraints$maxLengt === void 0 ? Math.min(maxLengthFromMinLength(maxNumElements), 4294967295) : _constraints$maxLengt,\n      noTrailingHole = constraints.noTrailingHole;\n\n  if (minNumElements > maxLength) {\n    throw new Error(\"The minimal number of non-hole elements cannot be higher than the maximal length of the array\");\n  }\n\n  if (minNumElements > maxNumElements) {\n    throw new Error(\"The minimal number of non-hole elements cannot be higher than the maximal number of non-holes\");\n  }\n\n  var resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  var maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  var sparseArrayNoTrailingHole = convertFromNext(convertToNext(set(tuple(nat(maxIndexAuthorized), arb), {\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    compare: {\n      selector: function selector(item) {\n        return item[0];\n      }\n    }\n  })).map(function (items) {\n    var lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, function (value) {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return Object.entries(value).map(function (entry) {\n      return [Number(entry[0]), entry[1]];\n    });\n  }));\n\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n\n  return convertFromNext(convertToNext(tuple(sparseArrayNoTrailingHole, integer({\n    min: minNumElements,\n    max: maxLength\n  }))).map(function (data) {\n    var sparse = data[0];\n    var targetLength = data[1];\n\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n\n    var longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, function (value) {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return [value, value.length];\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}