{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forBytecode = exports.forContract = exports.forContracts = void 0;\n\nfunction forContracts(contracts) {\n  // convert to list\n  return Object.values(contracts).map(forContract);\n}\n\nexports.forContracts = forContracts;\n\nfunction forContract(contract) {\n  var contractName = contract.contractName,\n      contract_name = contract.contract_name,\n      sourcePath = contract.sourcePath,\n      source = contract.source,\n      sourceMap = contract.sourceMap,\n      deployedSourceMap = contract.deployedSourceMap,\n      legacyAST = contract.legacyAST,\n      ast = contract.ast,\n      abi = contract.abi,\n      metadata = contract.metadata,\n      bytecode = contract.bytecode,\n      deployedBytecode = contract.deployedBytecode,\n      compiler = contract.compiler,\n      devdoc = contract.devdoc,\n      userdoc = contract.userdoc,\n      immutableReferences = contract.immutableReferences,\n      generatedSources = contract.generatedSources,\n      deployedGeneratedSources = contract.deployedGeneratedSources,\n      db = contract.db;\n  return {\n    contractName: contract_name || contractName,\n    sourcePath: sourcePath,\n    source: source,\n    sourceMap: sourceMap,\n    deployedSourceMap: deployedSourceMap,\n    legacyAST: legacyAST,\n    ast: ast,\n    abi: abi,\n    metadata: metadata,\n    bytecode: forBytecode(bytecode),\n    deployedBytecode: forBytecode(deployedBytecode),\n    compiler: compiler,\n    devdoc: devdoc,\n    userdoc: userdoc,\n    immutableReferences: immutableReferences,\n    generatedSources: generatedSources,\n    deployedGeneratedSources: deployedGeneratedSources,\n    db: db\n  };\n}\n\nexports.forContract = forContract;\n\nfunction forBytecode(bytecode) {\n  if (!bytecode) {\n    return undefined;\n  }\n\n  if (typeof bytecode === \"object\") {\n    return bytecode;\n  }\n\n  var linkReferences = [];\n  var bytes = bytecode.slice(2) // remove 0x prefix\n  .replace(/__[^_]+_*/g, function (linkReference, characterOffset) {\n    var _linkReference$match = linkReference.match(/__([^_]+)_*/),\n        _linkReference$match2 = _slicedToArray(_linkReference$match, 2),\n        name = _linkReference$match2[1];\n\n    var characterLength = linkReference.length;\n    var offset = characterOffset / 2;\n    var length = characterLength / 2;\n    linkReferences.push({\n      offsets: [offset],\n      name: name,\n      length: length\n    });\n    return \"0\".repeat(characterLength);\n  });\n  return {\n    bytes: bytes,\n    linkReferences: linkReferences\n  };\n}\n\nexports.forBytecode = forBytecode;","map":null,"metadata":{},"sourceType":"script"}