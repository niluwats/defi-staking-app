{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Abi = exports.ConstructorEntry = exports.FallbackEntry = exports.ReceiveEntry = exports.FunctionEntry = exports.ErrorEntry = exports.EventEntry = exports.EventParameter = exports.Parameter = void 0;\n\nvar fc = __importStar(require(\"fast-check\"));\n\nvar faker_1 = __importDefault(require(\"faker\"));\n\nvar change_case_1 = require(\"change-case\");\n\nvar Parameter = function Parameter() {\n  return fc.tuple(fc.record({\n    name: ParameterName()\n  }), TypeRecord()).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0].name,\n        type = _ref2[1];\n\n    return Object.assign({\n      name: name\n    }, type);\n  });\n};\n\nexports.Parameter = Parameter;\n\nvar EventParameter = function EventParameter() {\n  return fc.tuple(fc.record({\n    name: ParameterName(),\n    indexed: fc.boolean()\n  }), TypeRecord()).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        _ref4$ = _ref4[0],\n        name = _ref4$.name,\n        indexed = _ref4$.indexed,\n        type = _ref4[1];\n\n    return Object.assign({\n      name: name,\n      indexed: indexed\n    }, type);\n  });\n};\n\nexports.EventParameter = EventParameter;\n\nvar EventEntry = function EventEntry() {\n  return fc.record({\n    type: fc.constant(\"event\"),\n    name: EventName(),\n    inputs: fc.array(exports.EventParameter(), {\n      maxLength: 10\n    }).filter(function (inputs) {\n      if (inputs.filter(function (_ref5) {\n        var indexed = _ref5.indexed;\n        return indexed;\n      }).length > 3) {\n        // only up to 3 params can be indexed\n        return false;\n      } // names that are not blank should be unique\n\n\n      var names = inputs.map(function (_ref6) {\n        var name = _ref6.name;\n        return name;\n      }).filter(function (name) {\n        return name !== \"\";\n      });\n      return names.length === new Set(names).size;\n    }),\n    anonymous: fc.boolean()\n  });\n};\n\nexports.EventEntry = EventEntry;\n\nvar ErrorEntry = function ErrorEntry() {\n  return fc.record({\n    type: fc.constant(\"error\"),\n    name: ErrorName(),\n    inputs: fc.array(exports.Parameter(), {\n      maxLength: 10\n    }).filter(function (inputs) {\n      // names that are not blank should be unique\n      var names = inputs.map(function (_ref7) {\n        var name = _ref7.name;\n        return name;\n      }).filter(function (name) {\n        return name !== \"\";\n      });\n      return names.length === new Set(names).size;\n    })\n  });\n};\n\nexports.ErrorEntry = ErrorEntry;\n\nvar FunctionEntry = function FunctionEntry() {\n  return fc.tuple(fc.record({\n    type: fc.constant(\"function\")\n  }, {\n    withDeletedKeys: true\n  }), fc.record({\n    name: FunctionName(),\n    inputs: fc.array(exports.Parameter(), {\n      maxLength: 10\n    })\n  }), fc.record({\n    outputs: fc.array(exports.Parameter(), {\n      maxLength: 10\n    })\n  }, {\n    withDeletedKeys: true\n  }), fc.tuple(fc.oneof(fc.constant(\"pure\"), fc.constant(\"view\"), fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(function (_ref8) {\n    var _ref9 = _slicedToArray(_ref8, 3),\n        stateMutability = _ref9[0],\n        includeLegacy = _ref9[1],\n        includeModern = _ref9[2];\n\n    var payable = stateMutability === \"payable\";\n    var constant = stateMutability === \"view\" || stateMutability === \"pure\";\n    var modern = {\n      stateMutability: stateMutability\n    };\n    var legacy = {\n      payable: payable,\n      constant: constant\n    };\n    return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n  })).map(function (records) {\n    return records.reduce(function (a, b) {\n      return Object.assign(Object.assign({}, a), b);\n    }, {});\n  }).filter(function (entry) {\n    var inputs = entry.inputs,\n        _entry$outputs = entry.outputs,\n        outputs = _entry$outputs === void 0 ? [] : _entry$outputs; // names that are not blank should be unique\n\n    var names = [].concat(_toConsumableArray(inputs), _toConsumableArray(outputs)).map(function (_ref10) {\n      var name = _ref10.name;\n      return name;\n    }).filter(function (name) {\n      return name !== \"\";\n    });\n    return names.length === new Set(names).size;\n  });\n};\n\nexports.FunctionEntry = FunctionEntry;\n\nvar ReceiveEntry = function ReceiveEntry() {\n  return fc.record({\n    type: fc.constant(\"receive\"),\n    stateMutability: fc.constant(\"payable\")\n  });\n};\n\nexports.ReceiveEntry = ReceiveEntry;\n\nvar FallbackEntry = function FallbackEntry() {\n  return fc.tuple(fc.record({\n    type: fc.constant(\"fallback\")\n  }), fc.tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(function (_ref11) {\n    var _ref12 = _slicedToArray(_ref11, 3),\n        stateMutability = _ref12[0],\n        includeLegacy = _ref12[1],\n        includeModern = _ref12[2];\n\n    var payable = stateMutability === \"payable\";\n    var modern = {\n      stateMutability: stateMutability\n    };\n    var legacy = {\n      payable: payable\n    };\n    return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n  })).map(function (_ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n        type = _ref14[0].type,\n        mutabilityFields = _ref14[1];\n\n    return Object.assign({\n      type: type\n    }, mutabilityFields);\n  });\n};\n\nexports.FallbackEntry = FallbackEntry;\n\nvar ConstructorEntry = function ConstructorEntry() {\n  return fc.tuple(fc.record({\n    type: fc.constant(\"constructor\"),\n    inputs: fc.array(exports.Parameter(), {\n      maxLength: 10\n    }).filter(function (inputs) {\n      // names that are not blank should be unique\n      var names = inputs.map(function (_ref15) {\n        var name = _ref15.name;\n        return name;\n      }).filter(function (name) {\n        return name !== \"\";\n      });\n      return names.length === new Set(names).size;\n    })\n  }), fc.tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(function (_ref16) {\n    var _ref17 = _slicedToArray(_ref16, 3),\n        stateMutability = _ref17[0],\n        includeLegacy = _ref17[1],\n        includeModern = _ref17[2];\n\n    var payable = stateMutability === \"payable\";\n    var modern = {\n      stateMutability: stateMutability\n    };\n    var legacy = {\n      payable: payable\n    };\n    return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n  })).map(function (_ref18) {\n    var _ref19 = _slicedToArray(_ref18, 2),\n        _ref19$ = _ref19[0],\n        type = _ref19$.type,\n        inputs = _ref19$.inputs,\n        mutabilityFields = _ref19[1];\n\n    return Object.assign({\n      type: type,\n      inputs: inputs\n    }, mutabilityFields);\n  });\n};\n\nexports.ConstructorEntry = ConstructorEntry;\n\nvar Abi = function Abi() {\n  return fc.tuple(exports.ConstructorEntry(), exports.FallbackEntry(), exports.ReceiveEntry(), fc.array(fc.oneof(exports.FunctionEntry(), exports.EventEntry(), exports.ErrorEntry()))).chain(function (_ref20) {\n    var _ref21 = _slicedToArray(_ref20, 4),\n        constructor = _ref21[0],\n        fallback = _ref21[1],\n        receive = _ref21[2],\n        entries = _ref21[3];\n\n    return fc.shuffledSubarray([constructor, fallback, receive].concat(_toConsumableArray(entries)));\n  });\n};\n\nexports.Abi = Abi;\nvar Numerics;\n\n(function (Numerics) {\n  // 0 < n <= 32\n  // use subtraction so that fast-check treats 32 as simpler than 1\n  Numerics.Bytes = function () {\n    return fc.nat(31).map(function (k) {\n      return 32 - k;\n    });\n  }; // 0 < n <= 256, 8 | n\n\n\n  Numerics.Bits = function () {\n    return Numerics.Bytes().map(function (k) {\n      return 8 * k;\n    });\n  }; // 0 < n <= 80\n  // use fancy math so that fast-check treats 18 as the simplest case\n  //\n  //     0 ----------------- 79\n  //     lines up as:\n  //     18 ------ 80, 0 --- 17\n\n\n  Numerics.DecimalPlaces = function () {\n    return fc.nat(79).map(function (k) {\n      return (k + 17) % 80 + 1;\n    });\n  };\n\n  Numerics.Precision = function () {\n    return fc.tuple(Numerics.Bits(), Numerics.DecimalPlaces());\n  };\n})(Numerics || (Numerics = {}));\n\nvar Primitives;\n\n(function (Primitives) {\n  Primitives.Uint = function () {\n    return Numerics.Bits().map(function (m) {\n      return \"uint\".concat(m);\n    });\n  };\n\n  Primitives.Int = function () {\n    return Numerics.Bits().map(function (m) {\n      return \"int\".concat(m);\n    });\n  };\n\n  Primitives.Address = function () {\n    return fc.constant(\"address\");\n  };\n\n  Primitives.Bool = function () {\n    return fc.constant(\"bool\");\n  };\n\n  Primitives.Fixed = function () {\n    return Numerics.Precision().map(function (_ref22) {\n      var _ref23 = _slicedToArray(_ref22, 2),\n          m = _ref23[0],\n          n = _ref23[1];\n\n      return \"fixed\".concat(m, \"x\").concat(n);\n    });\n  };\n\n  Primitives.Ufixed = function () {\n    return Numerics.Precision().map(function (_ref24) {\n      var _ref25 = _slicedToArray(_ref24, 2),\n          m = _ref25[0],\n          n = _ref25[1];\n\n      return \"ufixed\".concat(m, \"x\").concat(n);\n    });\n  };\n\n  Primitives.BytesM = function () {\n    return Numerics.Bytes().map(function (m) {\n      return \"bytes\".concat(m);\n    });\n  };\n\n  Primitives.Function = function () {\n    return fc.constant(\"function\");\n  };\n\n  Primitives.Bytes = function () {\n    return fc.constant(\"bytes\");\n  };\n\n  Primitives.String = function () {\n    return fc.constant(\"string\");\n  };\n\n  Primitives.Tuple = function () {\n    return fc.constant(\"tuple\");\n  };\n})(Primitives || (Primitives = {}));\n\nvar Primitive = function Primitive() {\n  return fc.oneof(Primitives.Uint(), Primitives.Int(), Primitives.Address(), Primitives.Bool(), Primitives.Fixed(), Primitives.Ufixed(), Primitives.BytesM(), Primitives.Function(), Primitives.Bytes(), Primitives.String(), Primitives.Tuple());\n};\n\nvar Type = fc.memo(function (n) {\n  return n === 0 ? Primitive() : // we cap this at 3 so that fast-check doesn't blow the stack\n  fc.oneof(Primitive(), ArrayFixed(n > 3 ? 3 : n), ArrayDynamic(n));\n});\nvar ArrayFixed = fc.memo(function (n) {\n  return fc.tuple(Type(n - 1), fc.integer(1, 256)).map(function (_ref26) {\n    var _ref27 = _slicedToArray(_ref26, 2),\n        type = _ref27[0],\n        length = _ref27[1];\n\n    return \"\".concat(type, \"[\").concat(length, \"]\");\n  });\n});\nvar ArrayDynamic = fc.memo(function (n) {\n  return Type(n - 1).map(function (type) {\n    return \"\".concat(type, \"[]\");\n  });\n});\nvar reservedWords = new Set([\"Error\", \"Panic\", \"_\", \"abi\", \"abstract\", \"addmod\", \"address\", \"after\", \"alias\", \"anonymous\", \"apply\", \"as\", \"assembly\", \"assert\", \"auto\", \"block\", \"blockhash\", \"bool\", \"break\", \"byte\", \"bytes\", \"calldata\", \"case\", \"catch\", \"constant\", \"constructor\", \"continue\", \"contract\", \"copyof\", \"days\", \"default\", \"define\", \"delete\", \"ecrecover\", \"else\", \"emit\", \"enum\", \"error\", \"ether\", \"event\", \"external\", \"fallback\", \"false\", \"final\", \"finney\", \"fixed\", \"for\", \"from\", \"function\", \"gasleft\", \"gwei\", \"hours\", \"if\", \"immutable\", \"implements\", \"import\", \"in\", \"indexed\", \"inline\", \"int\", \"interface\", \"internal\", \"is\", \"keccak256\", \"let\", \"library\", \"log0\", \"log1\", \"log2\", \"log3\", \"log4\", \"macro\", \"mapping\", \"match\", \"memory\", \"minutes\", \"modifier\", \"msg\", \"mulmod\", \"mutable\", \"new\", \"now\", \"null\", \"of\", \"override\", \"partial\", \"payable\", \"pragma\", \"private\", \"promise\", \"public\", \"pure\", \"receive\", \"reference\", \"relocatable\", \"require\", \"return\", \"returns\", \"revert\", \"ripemd160\", \"sealed\", \"seconds\", \"selfdestruct\", \"sha256\", \"sha3\", \"sizeof\", \"static\", \"storage\", \"string\", \"struct\", \"suicide\", \"super\", \"supports\", \"switch\", \"szabo\", \"this\", \"throw\", \"true\", \"try\", \"tx\", \"type\", \"typedef\", \"typeof\", \"ufixed\", \"uint\", \"unchecked\", \"using\", \"var\", \"view\", \"virtual\", \"weeks\", \"wei\", \"while\", \"years\"]); // borrowed from https://runkit.com/dubzzz/faker-to-fast-check\n\nvar fakerToArb = function fakerToArb(template) {\n  var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : change_case_1.camelCase;\n  return fc.integer().noBias().noShrink().map(function (seed) {\n    faker_1.default.seed(seed);\n    return transform(faker_1.default.fake(template));\n  }).filter(function (word) {\n    return !reservedWords.has(word);\n  });\n};\n\nvar ParameterName = function ParameterName() {\n  return fc.frequency({\n    arbitrary: fakerToArb(\"{{hacker.noun}}\"),\n    weight: 9\n  }, {\n    arbitrary: fc.constant(\"\"),\n    weight: 1\n  });\n};\n\nvar EventName = function EventName() {\n  return fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\", change_case_1.pascalCase);\n};\n\nvar ErrorName = function ErrorName() {\n  return fakerToArb(\"{{hacker.noun}} {{hacker.noun}}\", change_case_1.pascalCase);\n};\n\nvar FunctionName = function FunctionName() {\n  return fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\");\n};\n\nvar TypeRecord = function TypeRecord() {\n  return Type().chain(function (type) {\n    return type.startsWith(\"tuple\") ? fc.record({\n      type: fc.constant(type),\n      components: fc.array(exports.Parameter().filter(function (_ref28) {\n        var name = _ref28.name;\n        return name !== \"\";\n      }), {\n        minLength: 1,\n        maxLength: 5\n      }).filter(function (items) {\n        var names = items.map(function (_ref29) {\n          var name = _ref29.name;\n          return name;\n        }).filter(function (name) {\n          return name !== \"\";\n        });\n        return names.length === new Set(names).size;\n      })\n    }) : fc.record({\n      type: fc.constant(type)\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}