{"ast":null,"code":"var ansiRegex = require('ansi-regex');\n\nvar superSplit = require('super-split');\n\nvar arrayUniq = require('array-uniq');\n\nvar stripAnsi = require('strip-ansi');\n\nvar realignOutOfBoundsCoords = function realignOutOfBoundsCoords(text, opts) {\n  var plain = stripAnsi(text);\n  var lines = plain.split('\\n');\n  var totalLines = lines.length; // 'End.line marker out of bounds (max).'\n\n  if (opts.end.line > totalLines) {\n    opts.end.line = totalLines;\n  } // 'Start.line marker out of bounds (min).'\n\n\n  if (opts.start.line < 1) {\n    opts.start.line = 1;\n  } // 'Start.column marker out of bounds (min).'\n\n\n  if (opts.start.column < 1) {\n    opts.start.column = 1;\n  } // 'End.column marker out of bounds (max).'\n\n\n  if (opts.end.column > lines[opts.end.line - 1].length) {\n    opts.end.column = lines[opts.end.line - 1].length;\n  }\n\n  if (opts.start.line > opts.end.line) {\n    throw new Error('Your start line is after your end line.');\n  }\n\n  if (opts.start.line === opts.end.line && opts.end.column < opts.start.column) {\n    throw new Error('Your end column is after your start column.');\n  }\n\n  return false;\n}; // Returns arys:\n// 1 - ANSI Escape sequences from section\n// 2 - Glyphs in section (ansi escape seq - or - ascii character)\n\n\nvar atomize = function atomize(section) {\n  var ansies = arrayUniq(section.match(ansiRegex()));\n  var words = superSplit(section, ansies);\n  var glyphs = [];\n  words.forEach(function (word) {\n    if (ansies.includes(word) === false) {\n      glyphs = glyphs.concat(word.split(''));\n      return;\n    }\n\n    glyphs.push(word);\n  });\n  return {\n    ansies: ansies,\n    glyphs: glyphs\n  };\n};\n\nvar markSection = function markSection(section, opts, linear) {\n  var _atomize = atomize(section),\n      ansies = _atomize.ansies,\n      glyphs = _atomize.glyphs;\n\n  var x = 0;\n  var y = 0;\n  var inPoint;\n  var outPoint;\n  var output = '';\n  var height = opts.end.line - opts.start.line;\n\n  var markNotBegun = function markNotBegun() {\n    return typeof inPoint !== 'number' && typeof outPoint !== 'number';\n  };\n\n  var markHasEnded = function markHasEnded() {\n    return typeof inPoint === 'number' && typeof outPoint === 'number';\n  };\n\n  var outsideOfMark = function outsideOfMark() {\n    return markNotBegun() || markHasEnded();\n  };\n\n  glyphs.forEach(function (glyph) {\n    if (ansies.includes(glyph) === false) {\n      if (glyph === '\\n' && !linear) {\n        y += 1;\n        x = -1;\n      }\n\n      x += 1;\n\n      if (x === opts.start.column && y === 0) {\n        inPoint = output.length;\n      }\n\n      output += glyph;\n\n      if (x === opts.end.column && y === height) {\n        outPoint = output.length;\n      }\n\n      return;\n    }\n\n    if (outsideOfMark()) {\n      output += glyph;\n    } else if (!outsideOfMark() && !opts.resetColor) {\n      output += glyph;\n    }\n  });\n  var pre = output.substr(0, inPoint);\n  var mark = opts.color(output.substr(inPoint, outPoint - inPoint));\n  var post = output.substr(outPoint);\n  var sectionMarked = pre + mark + post;\n  return sectionMarked;\n};\n\nvar mark2d = function mark2d(text, opts) {\n  realignOutOfBoundsCoords(text, opts);\n  var lines = text.split('\\n'); // Minus 1: because line and column numbers start at 1\n\n  var startLine = opts.start.line - 1;\n  var endLine = opts.end.line - 1; // Plus 1: because slice does not include the end indice\n\n  var unmarkedSection = lines.slice(startLine, endLine + 1).join('\\n');\n  var preSection = lines.slice(0, startLine);\n  var markedSection = markSection(unmarkedSection, opts);\n  var postSection = lines.slice(endLine + 1);\n  var result = preSection.concat([markedSection]).concat(postSection).join('\\n');\n  return result;\n};\n\nvar mark1d = function mark1d(text, opts, linear) {\n  var markedSection = markSection(text, opts, linear);\n  return markedSection;\n};\n\nvar mark = function mark(text, opts, linear) {\n  return linear ? mark1d(text, opts, linear) : mark2d(text, opts);\n};\n\nvar validMarkersNumbers = function validMarkersNumbers(opts) {\n  return typeof opts.start === 'number' && typeof opts.end === 'number';\n};\n\nvar validMarkersObject = function validMarkersObject(opts) {\n  return typeof opts.start === 'object' && typeof opts.end === 'object' && typeof opts.start.line === 'number' && typeof opts.start.column === 'number' && typeof opts.end.line === 'number' && typeof opts.end.column === 'number';\n};\n\nvar ansiMark = function ansiMark(text, opts) {\n  if (validMarkersObject(opts)) {\n    return mark(text, opts);\n  }\n\n  if (validMarkersNumbers(opts)) {\n    opts.start = {\n      line: 1,\n      column: opts.start\n    };\n    opts.end = {\n      line: 1,\n      column: opts.end\n    };\n    var linear = true;\n    return mark(text, opts, linear);\n  }\n\n  throw new Error('Invalid marker definition.');\n};\n\nmodule.exports = ansiMark;","map":null,"metadata":{},"sourceType":"script"}