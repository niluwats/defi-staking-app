{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.toBytes = exports.toHexString = exports.toBig = exports.toBigInt = exports.toSignedBN = exports.toBN = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:conversion\");\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar big_js_1 = __importDefault(require(\"big.js\"));\n/**\n * @param bytes - undefined | string | number | BN | Uint8Array | Big\n * @return {BN}\n */\n\n\nfunction toBN(bytes) {\n  if (bytes === undefined) {\n    return undefined;\n  } else if (typeof bytes == \"string\") {\n    return new bn_js_1.default(bytes, 16);\n  } else if (typeof bytes == \"number\" || bn_js_1.default.isBN(bytes)) {\n    return new bn_js_1.default(bytes);\n  } else if (bytes instanceof big_js_1.default) {\n    return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!\n    //note: going through string may seem silly but it's actually not terrible here,\n    //since BN is binary-based and Big is decimal-based\n    //[toFixed is like toString except it guarantees scientific notation is not used]\n  } else if (typeof bytes.reduce === \"function\") {\n    return bytes.reduce(function (num, byte) {\n      return num.shln(8).addn(byte);\n    }, new bn_js_1.default(0));\n  }\n}\n\nexports.toBN = toBN;\n/**\n * @param bytes - Uint8Array\n * @return {BN}\n */\n\nfunction toSignedBN(bytes) {\n  if (bytes[0] < 0x80) {\n    // if first bit is 0\n    return toBN(bytes);\n  } else {\n    return toBN(bytes.map(function (b) {\n      return 0xff - b;\n    })).addn(1).neg();\n  }\n}\n\nexports.toSignedBN = toSignedBN;\n\nfunction toBigInt(value) {\n  //BN is binary-based, so we convert by means of a hex string in order\n  //to avoid having to do a binary-decimal conversion and back :P\n  return !value.isNeg() ? BigInt(\"0x\" + value.toString(16)) : -BigInt(\"0x\" + value.neg().toString(16)); //can't directly make negative BigInt from hex string\n}\n\nexports.toBigInt = toBigInt;\n\nfunction toBig(value) {\n  //note: going through string may seem silly but it's actually not terrible here,\n  //since BN (& number) is binary-based and Big is decimal-based\n  return new big_js_1.default(value.toString());\n}\n\nexports.toBig = toBig;\n/**\n * @param bytes - Uint8Array | BN\n * @param padLength - number - minimum desired byte length (left-pad with zeroes)\n * @param padRight - boolean - causes padding to occur on right instead of left\n * @return {string}\n */\n\nfunction toHexString(bytes) {\n  var padLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var padRight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (bn_js_1.default.isBN(bytes)) {\n    bytes = toBytes(bytes);\n  }\n\n  var pad = function pad(s) {\n    return \"\".concat(\"00\".slice(0, 2 - s.length)).concat(s);\n  }; //                                          0  1  2  3  4\n  //                                 0  1  2  3  4  5  6  7\n  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )\n  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )\n  //                                `--.---'\n  //                                     offset 3\n\n\n  if (bytes.length < padLength) {\n    var prior = bytes;\n    bytes = new Uint8Array(padLength);\n\n    if (padRight) {\n      //unusual case: pad on right\n      bytes.set(prior);\n    } else {\n      //usual case\n      bytes.set(prior, padLength - prior.length);\n    }\n  }\n\n  debug(\"bytes: %o\", bytes);\n  var string = bytes.reduce(function (str, byte) {\n    return \"\".concat(str).concat(pad(byte.toString(16)));\n  }, \"\");\n  return \"0x\".concat(string);\n}\n\nexports.toHexString = toHexString;\n\nfunction toBytes(data) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  //note that length is a minimum output length\n  //strings will be 0-padded on left\n  //numbers/BNs will be sign-padded on left\n  //NOTE: if a number/BN is passed in that is too big for the given length,\n  //you will get an error!\n  //(note that strings passed in should be hex strings; this is not for converting\n  //generic strings to hex)\n  if (typeof data === \"string\") {\n    var hex = data; //renaming for clarity\n\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n\n    if (hex === \"\") {\n      //this special case is necessary because the match below will return null,\n      //not an empty array, when given an empty string\n      return new Uint8Array(0);\n    }\n\n    if (hex.length % 2 == 1) {\n      hex = \"0\".concat(hex);\n    }\n\n    var bytes = new Uint8Array(hex.match(/.{2}/g).map(function (byte) {\n      return parseInt(byte, 16);\n    }));\n\n    if (bytes.length < length) {\n      var prior = bytes;\n      bytes = new Uint8Array(length);\n      bytes.set(prior, length - prior.length);\n    }\n\n    return bytes;\n  } else {\n    // BN/Big/number case\n    if (typeof data === \"number\") {\n      data = new bn_js_1.default(data);\n    } else if (data instanceof big_js_1.default) {\n      //note: going through string may seem silly but it's actually not terrible here,\n      //since BN is binary-based and Big is decimal-based\n      data = new bn_js_1.default(data.toFixed()); //[toFixed is like toString except it guarantees scientific notation is not used]\n    } //note that the argument for toTwos is given in bits\n\n\n    return data.toTwos(length * 8).toArrayLike(Uint8Array, \"be\", length); //big-endian\n  }\n}\n\nexports.toBytes = toBytes; //computes value * 10**decimalPlaces\n\nfunction shiftBigUp(value, decimalPlaces) {\n  var newValue = new big_js_1.default(value);\n  newValue.e += decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigUp = shiftBigUp; //computes value * 10**-decimalPlaces\n\nfunction shiftBigDown(value, decimalPlaces) {\n  var newValue = new big_js_1.default(value);\n  newValue.e -= decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigDown = shiftBigDown; //we don't need this yet, but we will eventually\n\nfunction countDecimalPlaces(value) {\n  return Math.max(0, value.c.length - value.e - 1);\n}\n\nexports.countDecimalPlaces = countDecimalPlaces; //converts out of range booleans to true; something of a HACK\n//NOTE: does NOT do this recursively inside structs, arrays, etc!\n//I mean, those aren't elementary and therefore aren't in the domain\n//anyway, but still\n\nfunction cleanBool(result) {\n  switch (result.kind) {\n    case \"value\":\n      return result;\n\n    case \"error\":\n      switch (result.error.kind) {\n        case \"BoolOutOfRangeError\":\n          //return true\n          return {\n            type: result.type,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n\n        default:\n          return result;\n      }\n\n  }\n}\n\nexports.cleanBool = cleanBool;","map":null,"metadata":{},"sourceType":"script"}