{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(readSlot),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(readStorage);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readStorage = exports.readSlot = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:storage:read\");\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar errors_1 = require(\"../../errors\");\n\nfunction readSlot(storage, slot) {\n  var address, hexAddress, word;\n  return _regeneratorRuntime.wrap(function readSlot$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          address = Utils.slotAddress(slot); // debug(\"reading slot: %o\", Conversion.toHexString(address));\n\n          hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n          word = storage[hexAddress]; //if we can't find the word in the map, we place a request to the invoker to supply it\n          //(contract-decoder will look it up from the blockchain, while the debugger will just\n          //say 0)\n\n          if (!(word === undefined)) {\n            _context.next = 7;\n            break;\n          }\n\n          _context.next = 6;\n          return {\n            type: \"storage\",\n            slot: address\n          };\n\n        case 6:\n          word = _context.sent;\n\n        case 7:\n          return _context.abrupt(\"return\", word);\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.readSlot = readSlot;\n\nfunction readStorage(pointer, state) {\n  var storage, range, from, to, length, totalWordsAsBN, totalWords, data, i, offset, word;\n  return _regeneratorRuntime.wrap(function readStorage$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          storage = state.storage;\n          range = pointer.range;\n          debug(\"readRange %o\", range);\n          from = range.from, to = range.to, length = range.length;\n          from = {\n            slot: from.slot,\n            index: from.index || 0\n          };\n\n          if (length !== undefined) {\n            to = {\n              slot: {\n                path: from.slot.path || undefined,\n                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n              },\n              index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n            };\n          }\n\n          debug(\"normalized readRange %o\", {\n            from: from,\n            to: to\n          });\n          totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n          _context2.prev = 8;\n          totalWords = totalWordsAsBN.toNumber();\n          _context2.next = 15;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t0 = _context2[\"catch\"](8);\n          throw new errors_1.DecodingError({\n            kind: \"ReadErrorStorage\",\n            range: range\n          });\n\n        case 15:\n          data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n          i = 0;\n\n        case 17:\n          if (!(i < totalWords)) {\n            _context2.next = 25;\n            break;\n          }\n\n          offset = from.slot.offset.addn(i);\n          return _context2.delegateYield(readSlot(storage, Object.assign(Object.assign({}, from.slot), {\n            offset: offset\n          })), \"t1\", 20);\n\n        case 20:\n          word = _context2.t1;\n\n          if (typeof word !== \"undefined\") {\n            data.set(word, i * Evm.Utils.WORD_SIZE);\n          }\n\n        case 22:\n          i++;\n          _context2.next = 17;\n          break;\n\n        case 25:\n          debug(\"words %o\", data);\n          data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n          debug(\"data: %o\", data);\n          return _context2.abrupt(\"return\", data);\n\n        case 29:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[8, 12]]);\n}\n\nexports.readStorage = readStorage;","map":null,"metadata":{},"sourceType":"script"}