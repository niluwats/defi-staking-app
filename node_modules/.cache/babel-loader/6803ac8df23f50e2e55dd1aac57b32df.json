{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeMemory),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeMemoryReferenceByAddress);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:memory:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar errors_1 = require(\"../../errors\");\n\nfunction decodeMemory(dataType, pointer, info) {\n  var options,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function decodeMemory$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n          if (!Format.Types.isReferenceType(dataType)) {\n            _context.next = 10;\n            break;\n          }\n\n          if (!allocate_1.isSkippedInMemoryStructs(dataType)) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\", decodeMemorySkippedType(dataType));\n\n        case 6:\n          return _context.delegateYield(decodeMemoryReferenceByAddress(dataType, pointer, info, options), \"t0\", 7);\n\n        case 7:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 8:\n          _context.next = 12;\n          break;\n\n        case 10:\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), \"t1\", 11);\n\n        case 11:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.decodeMemory = decodeMemory;\n\nfunction decodeMemorySkippedType(dataType) {\n  switch (dataType.typeClass) {\n    case \"mapping\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n\n    case \"array\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    //other cases should not arise!\n  }\n}\n\nfunction decodeMemoryReferenceByAddress(dataType, pointer, info) {\n  var options,\n      state,\n      memoryVisited,\n      rawValue,\n      startPositionAsBN,\n      startPosition,\n      objectPosition,\n      rawLength,\n      lengthAsBN,\n      length,\n      seenPreviously,\n      childPointer,\n      memoryNowVisited,\n      baseType,\n      decodedChildren,\n      index,\n      allocations,\n      typeId,\n      structAllocation,\n      _memoryNowVisited,\n      decodedMembers,\n      _index,\n      memberAllocation,\n      memberPointer,\n      _childPointer,\n      memberName,\n      memberType,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeMemoryReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n          state = info.state;\n          memoryVisited = options.memoryVisited || [];\n          debug(\"pointer %o\", pointer);\n          _context2.prev = 4;\n          return _context2.delegateYield(read_1.default(pointer, state), \"t0\", 6);\n\n        case 6:\n          rawValue = _context2.t0;\n          _context2.next = 12;\n          break;\n\n        case 9:\n          _context2.prev = 9;\n          _context2.t1 = _context2[\"catch\"](4);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t1));\n\n        case 12:\n          startPositionAsBN = Conversion.toBN(rawValue);\n          _context2.prev = 13;\n          startPosition = startPositionAsBN.toNumber();\n          _context2.next = 20;\n          break;\n\n        case 17:\n          _context2.prev = 17;\n          _context2.t2 = _context2[\"catch\"](13);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlargePointersNotImplementedError\",\n              pointerAsBN: startPositionAsBN\n            }\n          });\n\n        case 20:\n          //startPosition may get modified later, so let's save the current\n          //value for circularity detection purposes\n          objectPosition = startPosition;\n          _context2.t3 = dataType.typeClass;\n          _context2.next = _context2.t3 === \"bytes\" ? 24 : _context2.t3 === \"string\" ? 24 : _context2.t3 === \"array\" ? 43 : _context2.t3 === \"struct\" ? 80 : 108;\n          break;\n\n        case 24:\n          _context2.prev = 24;\n          return _context2.delegateYield(read_1.default({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t4\", 26);\n\n        case 26:\n          rawLength = _context2.t4;\n          _context2.next = 32;\n          break;\n\n        case 29:\n          _context2.prev = 29;\n          _context2.t5 = _context2[\"catch\"](24);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t5));\n\n        case 32:\n          lengthAsBN = Conversion.toBN(rawLength);\n          _context2.prev = 33;\n          length = lengthAsBN.toNumber();\n          _context2.next = 40;\n          break;\n\n        case 37:\n          _context2.prev = 37;\n          _context2.t6 = _context2[\"catch\"](33);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 40:\n          childPointer = {\n            location: \"memory\",\n            start: startPosition + Evm.Utils.WORD_SIZE,\n            length: length\n          };\n          return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info), \"t7\", 42);\n\n        case 42:\n          return _context2.abrupt(\"return\", _context2.t7);\n\n        case 43:\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n\n          if (!(seenPreviously !== -1)) {\n            _context2.next = 46;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          });\n\n        case 46:\n          if (!(dataType.kind === \"dynamic\")) {\n            _context2.next = 59;\n            break;\n          }\n\n          _context2.prev = 47;\n          return _context2.delegateYield(read_1.default({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t8\", 49);\n\n        case 49:\n          rawLength = _context2.t8;\n          _context2.next = 55;\n          break;\n\n        case 52:\n          _context2.prev = 52;\n          _context2.t9 = _context2[\"catch\"](47);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t9));\n\n        case 55:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n\n          _context2.next = 60;\n          break;\n\n        case 59:\n          lengthAsBN = dataType.length;\n\n        case 60:\n          _context2.prev = 60;\n          length = lengthAsBN.toNumber();\n          _context2.next = 67;\n          break;\n\n        case 64:\n          _context2.prev = 64;\n          _context2.t10 = _context2[\"catch\"](60);\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 67:\n          memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));\n          baseType = dataType.baseType;\n          decodedChildren = [];\n          index = 0;\n\n        case 71:\n          if (!(index < length)) {\n            _context2.next = 79;\n            break;\n          }\n\n          _context2.t11 = decodedChildren;\n          return _context2.delegateYield(decodeMemory(baseType, {\n            location: \"memory\",\n            start: startPosition + index * Evm.Utils.WORD_SIZE,\n            length: Evm.Utils.WORD_SIZE\n          }, info, {\n            memoryVisited: memoryNowVisited\n          }), \"t12\", 74);\n\n        case 74:\n          _context2.t13 = _context2.t12;\n\n          _context2.t11.push.call(_context2.t11, _context2.t13);\n\n        case 76:\n          index++;\n          _context2.next = 71;\n          break;\n\n        case 79:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 80:\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n\n          if (!(seenPreviously !== -1)) {\n            _context2.next = 83;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          });\n\n        case 83:\n          //otherwise, decode as normal\n          allocations = info.allocations.memory;\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context2.next = 88;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          });\n\n        case 88:\n          debug(\"structAllocation %O\", structAllocation);\n          _memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));\n          decodedMembers = [];\n          _index = 0;\n\n        case 92:\n          if (!(_index < structAllocation.members.length)) {\n            _context2.next = 107;\n            break;\n          }\n\n          memberAllocation = structAllocation.members[_index];\n          memberPointer = memberAllocation.pointer;\n          _childPointer = {\n            location: \"memory\",\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length //always equals WORD_SIZE or 0\n\n          };\n          memberName = memberAllocation.name;\n          memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n          _context2.t14 = decodedMembers;\n          _context2.t15 = memberName;\n          return _context2.delegateYield(decodeMemory(memberType, _childPointer, info, {\n            memoryVisited: _memoryNowVisited\n          }), \"t16\", 101);\n\n        case 101:\n          _context2.t17 = _context2.t16;\n          _context2.t18 = {\n            name: _context2.t15,\n            value: _context2.t17\n          };\n\n          _context2.t14.push.call(_context2.t14, _context2.t18);\n\n        case 104:\n          _index++;\n          _context2.next = 92;\n          break;\n\n        case 107:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 108:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[4, 9], [13, 17], [24, 29], [33, 37], [47, 52], [60, 64]]);\n}\n\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;","map":null,"metadata":{},"sourceType":"script"}