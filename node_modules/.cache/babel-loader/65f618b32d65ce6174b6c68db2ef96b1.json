{"ast":null,"code":"import _classCallCheck from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Stream } from '../../stream/Stream.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nexport var FrequencyArbitrary = /*#__PURE__*/function (_NextArbitrary) {\n  _inherits(FrequencyArbitrary, _NextArbitrary);\n\n  function FrequencyArbitrary(warbs, constraints, context) {\n    var _this;\n\n    _classCallCheck(this, FrequencyArbitrary);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FrequencyArbitrary).call(this));\n    _this.warbs = warbs;\n    _this.constraints = constraints;\n    _this.context = context;\n    var currentWeight = 0;\n    _this.cumulatedWeights = [];\n\n    for (var idx = 0; idx !== warbs.length; ++idx) {\n      currentWeight += warbs[idx].weight;\n\n      _this.cumulatedWeights.push(currentWeight);\n    }\n\n    _this.totalWeight = currentWeight;\n    return _this;\n  }\n\n  _createClass(FrequencyArbitrary, [{\n    key: \"generate\",\n    value: function generate(mrng, biasFactor) {\n      if (this.mustGenerateFirst()) {\n        return this.safeGenerateForIndex(mrng, 0, biasFactor);\n      }\n\n      var selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n\n      for (var idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n        if (selected < this.cumulatedWeights[idx]) {\n          return this.safeGenerateForIndex(mrng, idx, biasFactor);\n        }\n      }\n\n      throw new Error(\"Unable to generate from fc.frequency\");\n    }\n  }, {\n    key: \"canShrinkWithoutContext\",\n    value: function canShrinkWithoutContext(value) {\n      return this.canShrinkWithoutContextIndex(value) !== -1;\n    }\n  }, {\n    key: \"shrink\",\n    value: function shrink(value, context) {\n      var _this2 = this;\n\n      if (context !== undefined) {\n        var safeContext = context;\n        var selectedIndex = safeContext.selectedIndex;\n        var originalBias = safeContext.originalBias;\n        var originalArbitrary = this.warbs[selectedIndex].arbitrary;\n        var originalShrinks = originalArbitrary.shrink(value, safeContext.originalContext).map(function (v) {\n          return _this2.mapIntoNextValue(selectedIndex, v, null, originalBias);\n        });\n\n        if (safeContext.clonedMrngForFallbackFirst !== null) {\n          if (safeContext.cachedGeneratedForFirst === undefined) {\n            safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n          }\n\n          var valueFromFirst = safeContext.cachedGeneratedForFirst;\n          return Stream.of(valueFromFirst).join(originalShrinks);\n        }\n\n        return originalShrinks;\n      }\n\n      var potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n\n      if (potentialSelectedIndex === -1) {\n        return Stream.nil();\n      }\n\n      return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value, undefined).map(function (v) {\n        return _this2.mapIntoNextValue(potentialSelectedIndex, v, null, undefined);\n      }));\n    }\n  }, {\n    key: \"defaultShrinkForFirst\",\n    value: function defaultShrinkForFirst(selectedIndex) {\n      ++this.context.depth;\n\n      try {\n        if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n          return Stream.nil();\n        }\n      } finally {\n        --this.context.depth;\n      }\n\n      var rawShrinkValue = new NextValue(this.warbs[0].fallbackValue.default, undefined);\n      return Stream.of(this.mapIntoNextValue(0, rawShrinkValue, null, undefined));\n    }\n  }, {\n    key: \"canShrinkWithoutContextIndex\",\n    value: function canShrinkWithoutContextIndex(value) {\n      if (this.mustGenerateFirst()) {\n        return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n      }\n\n      try {\n        ++this.context.depth;\n\n        for (var idx = 0; idx !== this.warbs.length; ++idx) {\n          var warb = this.warbs[idx];\n\n          if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n            return idx;\n          }\n        }\n\n        return -1;\n      } finally {\n        --this.context.depth;\n      }\n    }\n  }, {\n    key: \"mapIntoNextValue\",\n    value: function mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n      var context = {\n        selectedIndex: idx,\n        originalBias: biasFactor,\n        originalContext: value.context,\n        clonedMrngForFallbackFirst: clonedMrngForFallbackFirst\n      };\n      return new NextValue(value.value, context);\n    }\n  }, {\n    key: \"safeGenerateForIndex\",\n    value: function safeGenerateForIndex(mrng, idx, biasFactor) {\n      ++this.context.depth;\n\n      try {\n        var value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n        var clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n        return this.mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n      } finally {\n        --this.context.depth;\n      }\n    }\n  }, {\n    key: \"mustGenerateFirst\",\n    value: function mustGenerateFirst() {\n      return this.constraints.maxDepth !== undefined && this.constraints.maxDepth <= this.context.depth;\n    }\n  }, {\n    key: \"mustFallbackToFirstInShrink\",\n    value: function mustFallbackToFirstInShrink(idx) {\n      return idx !== 0 && !!this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n    }\n  }, {\n    key: \"computeNegDepthBenefit\",\n    value: function computeNegDepthBenefit() {\n      var depthFactor = this.constraints.depthFactor;\n\n      if (depthFactor === undefined || depthFactor <= 0) {\n        return 0;\n      }\n\n      var depthBenefit = Math.floor(Math.pow(1 + depthFactor, this.context.depth)) - 1;\n      return -Math.min(this.warbs[0].weight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n    }\n  }], [{\n    key: \"fromOld\",\n    value: function fromOld(warbs, constraints, label) {\n      return convertFromNext(FrequencyArbitrary.from(warbs.map(function (w) {\n        return Object.assign(Object.assign({}, w), {\n          arbitrary: convertToNext(w.arbitrary)\n        });\n      }), constraints, label));\n    }\n  }, {\n    key: \"from\",\n    value: function from(warbs, constraints, label) {\n      if (warbs.length === 0) {\n        throw new Error(\"\".concat(label, \" expects at least one weighted arbitrary\"));\n      }\n\n      var totalWeight = 0;\n\n      for (var idx = 0; idx !== warbs.length; ++idx) {\n        var currentArbitrary = warbs[idx].arbitrary;\n\n        if (currentArbitrary === undefined) {\n          throw new Error(\"\".concat(label, \" expects arbitraries to be specified\"));\n        }\n\n        var _currentWeight = warbs[idx].weight;\n        totalWeight += _currentWeight;\n\n        if (!Number.isInteger(_currentWeight)) {\n          throw new Error(\"\".concat(label, \" expects weights to be integer values\"));\n        }\n\n        if (_currentWeight < 0) {\n          throw new Error(\"\".concat(label, \" expects weights to be superior or equal to 0\"));\n        }\n      }\n\n      if (totalWeight <= 0) {\n        throw new Error(\"\".concat(label, \" expects the sum of weights to be strictly superior to 0\"));\n      }\n\n      return new FrequencyArbitrary(warbs, constraints, getDepthContextFor(constraints.depthIdentifier));\n    }\n  }]);\n\n  return FrequencyArbitrary;\n}(NextArbitrary);","map":null,"metadata":{},"sourceType":"module"}