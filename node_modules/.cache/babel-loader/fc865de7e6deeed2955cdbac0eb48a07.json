{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeVariable),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeCalldata),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeEvent),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeReturndata),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(decodeBytecode);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:core\");\n\nvar Ast = __importStar(require(\"./ast\"));\n\nvar AbiData = __importStar(require(\"./abi-data\"));\n\nvar Topic = __importStar(require(\"./topic\"));\n\nvar Evm = __importStar(require(\"./evm\"));\n\nvar Contexts = __importStar(require(\"./contexts\"));\n\nvar abify_1 = require(\"./abify\");\n\nvar Conversion = __importStar(require(\"./conversion\"));\n\nvar errors_1 = require(\"./errors\");\n\nvar read_1 = __importDefault(require(\"./read\"));\n\nvar decode_1 = __importDefault(require(\"./decode\")); // untyped import since no @types/web3-utils exists\n\n\nvar Web3Utils = require(\"web3-utils\");\n/**\n * @Category Decoding\n */\n\n\nfunction decodeVariable(definition, pointer, info, compilationId) {\n  var compiler, dataType;\n  return _regeneratorRuntime.wrap(function decodeVariable$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          compiler = info.currentContext.compiler;\n          dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n          return _context.delegateYield(decode_1.default(dataType, pointer, info), \"t0\", 3);\n\n        case 3:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\n\nfunction decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n  var context, contextHash, contractType, allocations, allocation, selector, rawSelector, abiEntry, decodingMode, decodedArguments, _iterator, _step, argumentAllocation, value, dataType, name;\n\n  return _regeneratorRuntime.wrap(function decodeCalldata$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          context = info.currentContext;\n\n          if (!(context === null)) {\n            _context2.next = 7;\n            break;\n          }\n\n          if (!isConstructor) {\n            _context2.next = 6;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            kind: \"create\",\n            decodingMode: \"full\",\n            bytecode: Conversion.toHexString(info.state.calldata)\n          });\n\n        case 6:\n          return _context2.abrupt(\"return\", {\n            kind: \"unknown\",\n            decodingMode: \"full\",\n            data: Conversion.toHexString(info.state.calldata)\n          });\n\n        case 7:\n          contextHash = context.context;\n          contractType = Contexts.Import.contextToType(context);\n          isConstructor = context.isConstructor;\n          allocations = info.allocations.calldata;\n\n          if (!isConstructor) {\n            _context2.next = 15;\n            break;\n          }\n\n          allocation = (allocations.constructorAllocations[contextHash] || {\n            input: undefined\n          }).input;\n          _context2.next = 19;\n          break;\n\n        case 15:\n          return _context2.delegateYield(read_1.default({\n            location: \"calldata\",\n            start: 0,\n            length: Evm.Utils.SELECTOR_SIZE\n          }, info.state), \"t0\", 16);\n\n        case 16:\n          rawSelector = _context2.t0;\n          selector = Conversion.toHexString(rawSelector);\n          allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {\n            input: undefined\n          }).input;\n\n        case 19:\n          if (!(allocation === undefined)) {\n            _context2.next = 23;\n            break;\n          }\n\n          abiEntry = null;\n\n          if (info.state.calldata.length === 0) {\n            //to hell with reads, let's just be direct\n            abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n          } else {\n            abiEntry = context.fallbackAbi.fallback;\n          }\n\n          return _context2.abrupt(\"return\", {\n            kind: \"message\",\n            class: contractType,\n            abi: abiEntry,\n            data: Conversion.toHexString(info.state.calldata),\n            decodingMode: \"full\"\n          });\n\n        case 23:\n          decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n\n          debug(\"calldata decoding mode: %s\", decodingMode); //you can't map with a generator, so we have to do this map manually\n\n          decodedArguments = [];\n          _iterator = _createForOfIteratorHelper(allocation.arguments);\n          _context2.prev = 27;\n\n          _iterator.s();\n\n        case 29:\n          if ((_step = _iterator.n()).done) {\n            _context2.next = 54;\n            break;\n          }\n\n          argumentAllocation = _step.value;\n          value = void 0;\n          dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n          _context2.prev = 33;\n          return _context2.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.offset,\n            allowRetry: decodingMode === \"full\"\n          }), \"t1\", 35);\n\n        case 35:\n          value = _context2.t1;\n          _context2.next = 50;\n          break;\n\n        case 38:\n          _context2.prev = 38;\n          _context2.t2 = _context2[\"catch\"](33);\n\n          if (!(_context2.t2 instanceof errors_1.StopDecodingError && _context2.t2.allowRetry && decodingMode === \"full\")) {\n            _context2.next = 49;\n            break;\n          }\n\n          debug(\"problem! retrying as ABI\");\n          debug(\"error: %O\", _context2.t2); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(function (argumentDecoding) {\n            return Object.assign(Object.assign({}, argumentDecoding), {\n              value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n            });\n          }); //3. retry this particular decode in ABI mode.\n          //(no try/catch on this one because we can't actually handle errors here!\n          //not that they should be occurring)\n\n          return _context2.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n          argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.offset\n          }), \"t3\", 46);\n\n        case 46:\n          value = _context2.t3;\n          _context2.next = 50;\n          break;\n\n        case 49:\n          throw _context2.t2;\n\n        case 50:\n          name = argumentAllocation.name;\n          decodedArguments.push(name //deliberate general falsiness test\n          ? {\n            name: name,\n            value: value\n          } : {\n            value: value\n          });\n\n        case 52:\n          _context2.next = 29;\n          break;\n\n        case 54:\n          _context2.next = 59;\n          break;\n\n        case 56:\n          _context2.prev = 56;\n          _context2.t4 = _context2[\"catch\"](27);\n\n          _iterator.e(_context2.t4);\n\n        case 59:\n          _context2.prev = 59;\n\n          _iterator.f();\n\n          return _context2.finish(59);\n\n        case 62:\n          if (!isConstructor) {\n            _context2.next = 66;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            kind: \"constructor\",\n            class: contractType,\n            arguments: decodedArguments,\n            abi: allocation.abi,\n            bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n            decodingMode: decodingMode\n          });\n\n        case 66:\n          return _context2.abrupt(\"return\", {\n            kind: \"function\",\n            class: contractType,\n            abi: allocation.abi,\n            arguments: decodedArguments,\n            selector: selector,\n            decodingMode: decodingMode\n          });\n\n        case 67:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[27, 56, 59, 62], [33, 38]]);\n}\n\nexports.decodeCalldata = decodeCalldata;\n/**\n * @Category Decoding\n */\n\nfunction decodeEvent(info, address) {\n  var _ref13, _ref14;\n\n  var options,\n      allocations,\n      extras,\n      rawSelector,\n      selector,\n      contractAllocations,\n      libraryAllocations,\n      contractAnonymousAllocations,\n      libraryAnonymousAllocations,\n      topicsCount,\n      _allocations$topicsCo,\n      _allocations$topicsCo2,\n      codeBytes,\n      codeAsHex,\n      contractContext,\n      possibleContractAllocations,\n      possibleContractAnonymousAllocations,\n      possibleExtraAllocations,\n      possibleExtraAnonymousAllocations,\n      emittingContextHash,\n      _ref,\n      _ref6,\n      contractAllocation,\n      contractAnonymousAllocation,\n      _ref11,\n      _ref12,\n      possibleLibraryAllocations,\n      possibleLibraryAnonymousAllocations,\n      possibleAllocations,\n      possibleAnonymousAllocations,\n      possibleAllocationsTotalMinusExtras,\n      possibleExtraAllocationsTotal,\n      possibleAllocationsTotal,\n      decodings,\n      _iterator2,\n      _step2,\n      allocation,\n      decodingMode,\n      contextHash,\n      attemptContext,\n      emittingContractType,\n      contractType,\n      decodedArguments,\n      _iterator3,\n      _step3,\n      argumentAllocation,\n      value,\n      dataType,\n      name,\n      indexed,\n      nonIndexedValues,\n      reEncodedData,\n      encodedData,\n      indexedValues,\n      reEncodedTopics,\n      encodedTopics,\n      selectorAdjustment,\n      i,\n      decoding,\n      _args3 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeEvent$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n          allocations = info.allocations.event;\n          extras = options.extras || \"off\";\n          topicsCount = info.state.eventtopics.length; //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n\n          if (!allocations[topicsCount]) {\n            _context3.next = 19;\n            break;\n          }\n\n          if (!(topicsCount > 0)) {\n            _context3.next = 12;\n            break;\n          }\n\n          return _context3.delegateYield(read_1.default({\n            location: \"eventtopic\",\n            topic: 0\n          }, info.state), \"t0\", 7);\n\n        case 7:\n          rawSelector = _context3.t0;\n          selector = Conversion.toHexString(rawSelector);\n\n          if (allocations[topicsCount].bySelector[selector]) {\n            _allocations$topicsCo = allocations[topicsCount].bySelector[selector];\n            contractAllocations = _allocations$topicsCo.contract;\n            libraryAllocations = _allocations$topicsCo.library;\n          } else {\n            debug(\"no allocations for that selector!\");\n            contractAllocations = {};\n            libraryAllocations = {};\n          }\n\n          _context3.next = 14;\n          break;\n\n        case 12:\n          //if we don't have a selector, it means we don't have any non-anonymous events\n          contractAllocations = {};\n          libraryAllocations = {};\n\n        case 14:\n          _allocations$topicsCo2 = allocations[topicsCount].anonymous;\n          contractAnonymousAllocations = _allocations$topicsCo2.contract;\n          libraryAnonymousAllocations = _allocations$topicsCo2.library;\n          _context3.next = 21;\n          break;\n\n        case 19:\n          //if there's not even an allocation for the topics count, we can't\n          //decode; we could do this the honest way of setting all four allocation\n          //objects to {}, but let's just short circuit\n          debug(\"no allocations for that topic count!\");\n          return _context3.abrupt(\"return\", []);\n\n        case 21:\n          _context3.next = 23;\n          return {\n            type: \"code\",\n            address: address\n          };\n\n        case 23:\n          codeBytes = _context3.sent;\n          codeAsHex = Conversion.toHexString(codeBytes);\n          contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);\n          emittingContextHash = (contractContext || {\n            context: undefined\n          }).context;\n\n          if (emittingContextHash) {\n            //if we found the contract, maybe it's from that contract\n            contractAllocation = contractAllocations[emittingContextHash];\n            contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];\n            possibleContractAllocations = contractAllocation || [];\n            possibleContractAnonymousAllocations = contractAnonymousAllocation || []; //also, we need to set up the extras (everything that's from a\n            //non-library contract but *not* this one)\n\n            possibleExtraAllocations = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.entries(contractAllocations).filter(function (_ref2) {\n              var _ref3 = _slicedToArray(_ref2, 2),\n                  key = _ref3[0],\n                  _ = _ref3[1];\n\n              return key !== emittingContextHash;\n            }).map(function (_ref4) {\n              var _ref5 = _slicedToArray(_ref4, 2),\n                  _ = _ref5[0],\n                  value = _ref5[1];\n\n              return value;\n            })));\n            possibleExtraAnonymousAllocations = (_ref6 = []).concat.apply(_ref6, _toConsumableArray(Object.entries(contractAnonymousAllocations).filter(function (_ref7) {\n              var _ref8 = _slicedToArray(_ref7, 2),\n                  key = _ref8[0],\n                  _ = _ref8[1];\n\n              return key !== emittingContextHash;\n            }).map(function (_ref9) {\n              var _ref10 = _slicedToArray(_ref9, 2),\n                  _ = _ref10[0],\n                  value = _ref10[1];\n\n              return value;\n            })));\n          } else {\n            //if we couldn't determine the contract, well, we have to assume it's from a library\n            debug(\"couldn't find context\");\n            possibleContractAllocations = [];\n            possibleContractAnonymousAllocations = []; //or it's an extra, which could be any of the contracts\n\n            possibleExtraAllocations = (_ref11 = []).concat.apply(_ref11, _toConsumableArray(Object.values(contractAllocations)));\n            possibleExtraAnonymousAllocations = (_ref12 = []).concat.apply(_ref12, _toConsumableArray(Object.values(contractAnonymousAllocations)));\n          } //now we get all the library allocations!\n\n\n          possibleLibraryAllocations = (_ref13 = []).concat.apply(_ref13, _toConsumableArray(Object.values(libraryAllocations)));\n          possibleLibraryAnonymousAllocations = (_ref14 = []).concat.apply(_ref14, _toConsumableArray(Object.values(libraryAnonymousAllocations))); //now we put it all together!\n\n          possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n          possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n          possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations); //...and also there's the extras\n\n          possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);\n          possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras\n          possibleExtraAllocationsTotal); //whew!\n\n          decodings = [];\n          _iterator2 = _createForOfIteratorHelper(possibleAllocationsTotal);\n          _context3.prev = 37;\n\n          _iterator2.s();\n\n        case 39:\n          if ((_step2 = _iterator2.n()).done) {\n            _context3.next = 130;\n            break;\n          }\n\n          allocation = _step2.value;\n          debug(\"trying allocation: %O\", allocation); //first: check for our sentinel value for extras (yeah, kind of HACKy)\n\n          if (!(allocation === null)) {\n            _context3.next = 53;\n            break;\n          }\n\n          _context3.t1 = extras;\n          _context3.next = _context3.t1 === \"on\" ? 46 : _context3.t1 === \"off\" ? 47 : _context3.t1 === \"necessary\" ? 48 : 53;\n          break;\n\n        case 46:\n          return _context3.abrupt(\"continue\", 128);\n\n        case 47:\n          return _context3.abrupt(\"break\", 130);\n\n        case 48:\n          if (!(decodings.length > 0)) {\n            _context3.next = 52;\n            break;\n          }\n\n          return _context3.abrupt(\"break\", 130);\n\n        case 52:\n          return _context3.abrupt(\"continue\", 128);\n\n        case 53:\n          if (!(options.name !== undefined && allocation.abi.name !== options.name)) {\n            _context3.next = 55;\n            break;\n          }\n\n          return _context3.abrupt(\"continue\", 128);\n\n        case 55:\n          //now: the main part!\n          decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n\n          contextHash = allocation.contextHash;\n          attemptContext = info.contexts[contextHash];\n          emittingContractType = Contexts.Import.contextToType(attemptContext);\n          contractType = allocation.definedIn; //you can't map with a generator, so we have to do this map manually\n\n          decodedArguments = [];\n          _iterator3 = _createForOfIteratorHelper(allocation.arguments);\n          _context3.prev = 62;\n\n          _iterator3.s();\n\n        case 64:\n          if ((_step3 = _iterator3.n()).done) {\n            _context3.next = 96;\n            break;\n          }\n\n          argumentAllocation = _step3.value;\n          value = void 0; //if in full mode, use the allocation's listed data type.\n          //if in ABI mode, abify it before use.\n\n          dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n          _context3.prev = 68;\n          return _context3.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {\n            strictAbiMode: true,\n            allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n          }), \"t2\", 70);\n\n        case 70:\n          value = _context3.t2;\n          _context3.next = 91;\n          break;\n\n        case 73:\n          _context3.prev = 73;\n          _context3.t3 = _context3[\"catch\"](68);\n\n          if (!(_context3.t3 instanceof errors_1.StopDecodingError && _context3.t3.allowRetry && decodingMode === \"full\")) {\n            _context3.next = 89;\n            break;\n          }\n\n          //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(function (argumentDecoding) {\n            return Object.assign(Object.assign({}, argumentDecoding), {\n              value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n            });\n          }); //3. retry this particular decode in ABI mode.\n\n          _context3.prev = 78;\n          return _context3.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n          argumentAllocation.pointer, info, {\n            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n            //retries no longer allowed, not that this has an effect\n\n          }), \"t4\", 80);\n\n        case 80:\n          value = _context3.t4;\n          _context3.next = 87;\n          break;\n\n        case 83:\n          _context3.prev = 83;\n          _context3.t5 = _context3[\"catch\"](78);\n          //if an error occurred on the retry, this isn't a valid decoding!\n          debug(\"rejected due to exception on retry\");\n          return _context3.abrupt(\"continue\", 128);\n\n        case 87:\n          _context3.next = 91;\n          break;\n\n        case 89:\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", _context3.t3);\n          return _context3.abrupt(\"continue\", 128);\n\n        case 91:\n          name = argumentAllocation.name;\n          indexed = argumentAllocation.pointer.location === \"eventtopic\";\n          decodedArguments.push(name //deliberate general falsiness test\n          ? {\n            name: name,\n            indexed: indexed,\n            value: value\n          } : {\n            indexed: indexed,\n            value: value\n          });\n\n        case 94:\n          _context3.next = 64;\n          break;\n\n        case 96:\n          _context3.next = 101;\n          break;\n\n        case 98:\n          _context3.prev = 98;\n          _context3.t6 = _context3[\"catch\"](62);\n\n          _iterator3.e(_context3.t6);\n\n        case 101:\n          _context3.prev = 101;\n\n          _iterator3.f();\n\n          return _context3.finish(101);\n\n        case 104:\n          //OK, so, having decoded the result, the question is: does it reencode to the original?\n          //first, we have to filter out the indexed arguments, and also get rid of the name information\n          nonIndexedValues = decodedArguments.filter(function (argument) {\n            return !argument.indexed;\n          }).map(function (argument) {\n            return argument.value;\n          }); //now, we can encode!\n\n          reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n          encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n          //are they equal?\n\n          if (Evm.Utils.equalData(reEncodedData, encodedData)) {\n            _context3.next = 110;\n            break;\n          }\n\n          //if not, this allocation doesn't work\n          debug(\"rejected due to [non-indexed] mismatch\");\n          return _context3.abrupt(\"continue\", 128);\n\n        case 110:\n          //one last check -- let's check that the indexed arguments match up, too\n          indexedValues = decodedArguments.filter(function (argument) {\n            return argument.indexed;\n          }).map(function (argument) {\n            return argument.value;\n          });\n          reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n          encodedTopics = info.state.eventtopics; //now: do *these* match?\n\n          selectorAdjustment = allocation.anonymous ? 0 : 1;\n          i = 0;\n\n        case 115:\n          if (!(i < reEncodedTopics.length)) {\n            _context3.next = 122;\n            break;\n          }\n\n          if (Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n            _context3.next = 119;\n            break;\n          }\n\n          debug(\"rejected due to indexed mismatch\");\n          return _context3.abrupt(\"continue\", 128);\n\n        case 119:\n          i++;\n          _context3.next = 115;\n          break;\n\n        case 122:\n          //if we've made it here, the allocation works!  hooray!\n          debug(\"allocation accepted!\");\n          decoding = void 0;\n\n          if (allocation.abi.anonymous) {\n            decoding = {\n              kind: \"anonymous\",\n              definedIn: contractType,\n              class: emittingContractType,\n              abi: allocation.abi,\n              arguments: decodedArguments,\n              decodingMode: decodingMode\n            };\n          } else {\n            decoding = {\n              kind: \"event\",\n              definedIn: contractType,\n              class: emittingContractType,\n              abi: allocation.abi,\n              arguments: decodedArguments,\n              selector: selector,\n              decodingMode: decodingMode\n            };\n          }\n\n          decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n          //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n          if (!(options.id && allocation.id === options.id)) {\n            _context3.next = 128;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", [decoding]);\n\n        case 128:\n          _context3.next = 39;\n          break;\n\n        case 130:\n          _context3.next = 135;\n          break;\n\n        case 132:\n          _context3.prev = 132;\n          _context3.t7 = _context3[\"catch\"](37);\n\n          _iterator2.e(_context3.t7);\n\n        case 135:\n          _context3.prev = 135;\n\n          _iterator2.f();\n\n          return _context3.finish(135);\n\n        case 138:\n          return _context3.abrupt(\"return\", decodings);\n\n        case 139:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[37, 132, 135, 138], [62, 98, 101, 104], [68, 73], [78, 83]]);\n}\n\nexports.decodeEvent = decodeEvent;\nvar errorSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n  type: \"string\",\n  value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nvar panicSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n  type: \"string\",\n  value: \"Panic(uint256)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nvar defaultRevertAllocations = [{\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: errorSelector,\n  abi: {\n    name: \"Error\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"string\",\n      internalType: \"string\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: errorSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"string\",\n      typeHint: \"string\"\n    }\n  }]\n}, {\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: panicSelector,\n  abi: {\n    name: \"Panic\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"uint256\",\n      internalType: \"uint256\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: panicSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"uint\",\n      bits: Evm.Utils.WORD_SIZE * 8,\n      typeHint: \"uint256\"\n    }\n  }]\n}];\nvar defaultEmptyAllocations = [{\n  kind: \"failure\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}, {\n  kind: \"selfdestruct\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode\n * Moreover, within \"revert\", builtin ones are put above custom ones\n * @Category Decoding\n */\n\nfunction decodeReturndata(info, successAllocation, //null here must be explicit\nstatus, //you can pass this to indicate that you know the status,\nid //useful when status = false\n) {\n  var possibleAllocations, selector, contextHash, customRevertAllocations, decodings, _iterator4, _step4, allocation, encodedData, encodedPrefix, successKinds, failKinds, _decoding, _decoding2, decodingMode, decodedArguments, _iterator5, _step5, argumentAllocation, value, dataType, name, decodedArgumentValues, reEncodedData, decoding;\n\n  return _regeneratorRuntime.wrap(function decodeReturndata$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          selector = Conversion.toHexString(info.state.returndata.slice(0, 4));\n          contextHash = (info.currentContext || {\n            context: \"\"\n          }).context; //HACK: \"\" is used to represent no context\n\n          customRevertAllocations = ((info.allocations.returndata || _defineProperty({}, contextHash, {}))[contextHash] || _defineProperty({}, selector, []))[selector] || [];\n\n          if (!(successAllocation === null)) {\n            _context4.next = 7;\n            break;\n          }\n\n          possibleAllocations = [].concat(defaultRevertAllocations, _toConsumableArray(customRevertAllocations), defaultEmptyAllocations);\n          _context4.next = 16;\n          break;\n\n        case 7:\n          _context4.t0 = successAllocation.kind;\n          _context4.next = _context4.t0 === \"return\" ? 10 : _context4.t0 === \"bytecode\" ? 12 : _context4.t0 === \"returnmessage\" ? 14 : 16;\n          break;\n\n        case 10:\n          possibleAllocations = [successAllocation].concat(defaultRevertAllocations, _toConsumableArray(customRevertAllocations), defaultEmptyAllocations);\n          return _context4.abrupt(\"break\", 16);\n\n        case 12:\n          possibleAllocations = [].concat(defaultRevertAllocations, _toConsumableArray(customRevertAllocations), defaultEmptyAllocations, [successAllocation]);\n          return _context4.abrupt(\"break\", 16);\n\n        case 14:\n          possibleAllocations = [].concat(defaultRevertAllocations, _toConsumableArray(customRevertAllocations), [successAllocation], defaultEmptyAllocations);\n          return _context4.abrupt(\"break\", 16);\n\n        case 16:\n          decodings = [];\n          _iterator4 = _createForOfIteratorHelper(possibleAllocations);\n          _context4.prev = 18;\n\n          _iterator4.s();\n\n        case 20:\n          if ((_step4 = _iterator4.n()).done) {\n            _context4.next = 118;\n            break;\n          }\n\n          allocation = _step4.value;\n          debug(\"trying allocation: %O\", allocation); //before we attempt to use this allocation, we check: does the selector match?\n\n          encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n\n          encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n\n          if (Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n            _context4.next = 27;\n            break;\n          }\n\n          return _context4.abrupt(\"continue\", 116);\n\n        case 27:\n          encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n          //also we check, does the status match?\n\n          if (!(status !== undefined)) {\n            _context4.next = 38;\n            break;\n          }\n\n          successKinds = [\"return\", \"selfdestruct\", \"bytecode\", \"returnmessage\"];\n          failKinds = [\"failure\", \"revert\"];\n\n          if (!status) {\n            _context4.next = 36;\n            break;\n          }\n\n          if (successKinds.includes(allocation.kind)) {\n            _context4.next = 34;\n            break;\n          }\n\n          return _context4.abrupt(\"continue\", 116);\n\n        case 34:\n          _context4.next = 38;\n          break;\n\n        case 36:\n          if (failKinds.includes(allocation.kind)) {\n            _context4.next = 38;\n            break;\n          }\n\n          return _context4.abrupt(\"continue\", 116);\n\n        case 38:\n          if (!(allocation.kind === \"bytecode\")) {\n            _context4.next = 43;\n            break;\n          }\n\n          return _context4.delegateYield(decodeBytecode(info), \"t1\", 40);\n\n        case 40:\n          _decoding = _context4.t1;\n\n          if (_decoding) {\n            decodings.push(_decoding);\n          }\n\n          return _context4.abrupt(\"continue\", 116);\n\n        case 43:\n          if (!(allocation.kind === \"returnmessage\")) {\n            _context4.next = 47;\n            break;\n          }\n\n          //this kind is also special, though thankfully it's easier\n          _decoding2 = {\n            kind: \"returnmessage\",\n            status: true,\n            data: Conversion.toHexString(info.state.returndata),\n            decodingMode: allocation.allocationMode\n          };\n          decodings.push(_decoding2);\n          return _context4.abrupt(\"continue\", 116);\n\n        case 47:\n          decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n          //you can't map with a generator, so we have to do this map manually\n\n          decodedArguments = [];\n          _iterator5 = _createForOfIteratorHelper(allocation.arguments);\n          _context4.prev = 50;\n\n          _iterator5.s();\n\n        case 52:\n          if ((_step5 = _iterator5.n()).done) {\n            _context4.next = 86;\n            break;\n          }\n\n          argumentAllocation = _step5.value;\n          value = void 0; //if in full mode, use the allocation's listed data type.\n          //if in ABI mode, abify it before use.\n\n          dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes); //now, let's decode!\n\n          _context4.prev = 56;\n          return _context4.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.selector.length,\n            strictAbiMode: true,\n            allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n          }), \"t2\", 58);\n\n        case 58:\n          value = _context4.t2;\n          debug(\"value on first try: %O\", value);\n          _context4.next = 82;\n          break;\n\n        case 62:\n          _context4.prev = 62;\n          _context4.t3 = _context4[\"catch\"](56);\n\n          if (!(_context4.t3 instanceof errors_1.StopDecodingError && _context4.t3.allowRetry && decodingMode === \"full\")) {\n            _context4.next = 80;\n            break;\n          }\n\n          debug(\"retry!\"); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(function (argumentDecoding) {\n            return Object.assign(Object.assign({}, argumentDecoding), {\n              value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n            });\n          }); //3. retry this particular decode in ABI mode.\n\n          _context4.prev = 68;\n          return _context4.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n          argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.selector.length,\n            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n            //retries no longer allowed, not that this has an effect\n\n          }), \"t4\", 70);\n\n        case 70:\n          value = _context4.t4;\n          debug(\"value on retry: %O\", value);\n          _context4.next = 78;\n          break;\n\n        case 74:\n          _context4.prev = 74;\n          _context4.t5 = _context4[\"catch\"](68);\n          //if an error occurred on the retry, this isn't a valid decoding!\n          debug(\"rejected due to exception on retry\");\n          return _context4.abrupt(\"continue\", 116);\n\n        case 78:\n          _context4.next = 82;\n          break;\n\n        case 80:\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", _context4.t3);\n          return _context4.abrupt(\"continue\", 116);\n\n        case 82:\n          name = argumentAllocation.name;\n          decodedArguments.push(name //deliberate general falsiness test\n          ? {\n            name: name,\n            value: value\n          } : {\n            value: value\n          });\n\n        case 84:\n          _context4.next = 52;\n          break;\n\n        case 86:\n          _context4.next = 91;\n          break;\n\n        case 88:\n          _context4.prev = 88;\n          _context4.t6 = _context4[\"catch\"](50);\n\n          _iterator5.e(_context4.t6);\n\n        case 91:\n          _context4.prev = 91;\n\n          _iterator5.f();\n\n          return _context4.finish(91);\n\n        case 94:\n          //OK, so, having decoded the result, the question is: does it reencode to the original?\n          //first, we have to filter out the indexed arguments, and also get rid of the name information\n          debug(\"decodedArguments: %O\", decodedArguments);\n          decodedArgumentValues = decodedArguments.map(function (argument) {\n            return argument.value;\n          });\n          reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi); //are they equal? note the selector has been stripped off encodedData!\n\n          if (Evm.Utils.equalData(reEncodedData, encodedData)) {\n            _context4.next = 100;\n            break;\n          }\n\n          //if not, this allocation doesn't work\n          debug(\"rejected due to mismatch\");\n          return _context4.abrupt(\"continue\", 116);\n\n        case 100:\n          //if we've made it here, the allocation works!  hooray!\n          debug(\"allocation accepted!\");\n          decoding = void 0;\n          _context4.t7 = allocation.kind;\n          _context4.next = _context4.t7 === \"return\" ? 105 : _context4.t7 === \"revert\" ? 107 : _context4.t7 === \"selfdestruct\" ? 109 : _context4.t7 === \"failure\" ? 111 : 113;\n          break;\n\n        case 105:\n          decoding = {\n            kind: \"return\",\n            status: true,\n            arguments: decodedArguments,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 113);\n\n        case 107:\n          decoding = {\n            kind: \"revert\",\n            abi: allocation.abi,\n            definedIn: allocation.definedIn,\n            status: false,\n            arguments: decodedArguments,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 113);\n\n        case 109:\n          decoding = {\n            kind: \"selfdestruct\",\n            status: true,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 113);\n\n        case 111:\n          decoding = {\n            kind: \"failure\",\n            status: false,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 113);\n\n        case 113:\n          decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n          //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n          if (!(id && allocation.kind === \"revert\" && allocation.id === id)) {\n            _context4.next = 116;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", [decoding]);\n\n        case 116:\n          _context4.next = 20;\n          break;\n\n        case 118:\n          _context4.next = 123;\n          break;\n\n        case 120:\n          _context4.prev = 120;\n          _context4.t8 = _context4[\"catch\"](18);\n\n          _iterator4.e(_context4.t8);\n\n        case 123:\n          _context4.prev = 123;\n\n          _iterator4.f();\n\n          return _context4.finish(123);\n\n        case 126:\n          return _context4.abrupt(\"return\", decodings);\n\n        case 127:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4, null, [[18, 120, 123, 126], [50, 88, 91, 94], [56, 62], [68, 74]]);\n}\n\nexports.decodeReturndata = decodeReturndata; //note: requires the bytecode to be in returndata, not code\n\nfunction decodeBytecode(info) {\n  var decodingMode, bytecode, context, contractType, allocation, immutables, _iterator6, _step6, variable, dataType, value, decoding;\n\n  return _regeneratorRuntime.wrap(function decodeBytecode$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          decodingMode = \"full\"; //as always, degrade as necessary\n\n          bytecode = Conversion.toHexString(info.state.returndata);\n          context = Contexts.Utils.findContext(info.contexts, bytecode);\n\n          if (context) {\n            _context5.next = 5;\n            break;\n          }\n\n          return _context5.abrupt(\"return\", {\n            kind: \"unknownbytecode\",\n            status: true,\n            decodingMode: \"full\",\n            bytecode: bytecode\n          });\n\n        case 5:\n          contractType = Contexts.Import.contextToType(context); //now: ignore original allocation (which we didn't even pass :) )\n          //and lookup allocation by context\n\n          allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n          debug(\"bytecode allocation: %O\", allocation); //now: add immutables if applicable\n\n          if (!allocation.immutables) {\n            _context5.next = 42;\n            break;\n          }\n\n          immutables = []; //NOTE: if we're in here, we can assume decodingMode === \"full\"\n\n          _iterator6 = _createForOfIteratorHelper(allocation.immutables);\n          _context5.prev = 11;\n\n          _iterator6.s();\n\n        case 13:\n          if ((_step6 = _iterator6.n()).done) {\n            _context5.next = 34;\n            break;\n          }\n\n          variable = _step6.value;\n          dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n\n          value = void 0;\n          _context5.prev = 17;\n          return _context5.delegateYield(decode_1.default(dataType, variable.pointer, info, {\n            allowRetry: true,\n            strictAbiMode: true,\n            paddingMode: \"defaultOrZero\"\n          }), \"t0\", 19);\n\n        case 19:\n          value = _context5.t0;\n          _context5.next = 31;\n          break;\n\n        case 22:\n          _context5.prev = 22;\n          _context5.t1 = _context5[\"catch\"](17);\n\n          if (!(_context5.t1 instanceof errors_1.StopDecodingError && _context5.t1.allowRetry)) {\n            _context5.next = 30;\n            break;\n          }\n\n          //we \"retry\" by... not bothering with immutables :P\n          //(but we do set the mode to ABI)\n          decodingMode = \"abi\";\n          immutables = undefined;\n          return _context5.abrupt(\"break\", 34);\n\n        case 30:\n          return _context5.abrupt(\"return\", null);\n\n        case 31:\n          immutables.push({\n            name: variable.name,\n            class: variable.definedIn,\n            value: value\n          });\n\n        case 32:\n          _context5.next = 13;\n          break;\n\n        case 34:\n          _context5.next = 39;\n          break;\n\n        case 36:\n          _context5.prev = 36;\n          _context5.t2 = _context5[\"catch\"](11);\n\n          _iterator6.e(_context5.t2);\n\n        case 39:\n          _context5.prev = 39;\n\n          _iterator6.f();\n\n          return _context5.finish(39);\n\n        case 42:\n          decoding = {\n            kind: \"bytecode\",\n            status: true,\n            decodingMode: decodingMode,\n            bytecode: bytecode,\n            immutables: immutables,\n            class: contractType\n          }; //finally: add address if applicable\n\n          if (allocation.delegatecallGuard) {\n            decoding.address = Web3Utils.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n            );\n          }\n\n          return _context5.abrupt(\"return\", decoding);\n\n        case 45:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5, null, [[11, 36, 39, 42], [17, 22]]);\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\n\n\nfunction decodeRevert(returndata) {\n  //coercing because TS doesn't know it'll finish in one go\n  return decodeReturndata({\n    allocations: {},\n    state: {\n      storage: {},\n      returndata: returndata\n    }\n  }, null, false).next().value;\n}\n\nexports.decodeRevert = decodeRevert;","map":null,"metadata":{},"sourceType":"script"}