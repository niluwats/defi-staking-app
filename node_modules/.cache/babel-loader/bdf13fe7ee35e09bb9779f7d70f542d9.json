{"ast":null,"code":"var _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar debug = require(\"debug\")(\"contract:utils\");\n\nvar web3Utils = require(\"web3-utils\");\n\nvar _require = require(\"ethers/utils/bignumber\"),\n    bigNumberify = _require.bigNumberify;\n\nvar abi = require(\"web3-eth-abi\");\n\nvar BlockchainUtils = require(\"@truffle/blockchain-utils\");\n\nvar reformat = require(\"../reformat\");\n\nvar ens = require(\"./ens\");\n\nvar allowedTxParams = new Set([\"from\", \"to\", \"gas\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\", \"data\", \"nonce\", \"accessList\", \"type\", \"privateFor\", \"overwrite\"]);\nvar Utils = {\n  is_object: function is_object(val) {\n    return typeof val === \"object\" && !Array.isArray(val);\n  },\n  is_big_number: function is_big_number(val) {\n    if (typeof val !== \"object\") return false; //NOTE: For some reason, contrary to the docs,\n    //web3Utils.isBigNumber returns true not only for\n    //bignumber.js BigNumbers, but also for ethers BigNumbers,\n    //even though these are totally different things.\n\n    return web3Utils.isBN(val) || web3Utils.isBigNumber(val);\n  },\n  isTxParams: function isTxParams(val) {\n    if (!Utils.is_object(val)) return false;\n    if (Utils.is_big_number(val)) return false;\n    return Object.keys(val).some(function (fieldName) {\n      return allowedTxParams.has(fieldName);\n    });\n  },\n  decodeLogs: function decodeLogs(_logs, isSingle) {\n    var constructor = this;\n    var logs = Utils.toTruffleLog(_logs, isSingle);\n    return logs.map(function (log) {\n      var logABI = constructor.events[log.topics[0]];\n      if (logABI == null) return null;\n      var copy = Utils.merge({}, log);\n      copy.event = logABI.name;\n      copy.topics = logABI.anonymous ? copy.topics : copy.topics.slice(1);\n      if (copy.data === \"0x\") copy.data = \"\";\n      var logArgs;\n\n      try {\n        logArgs = abi.decodeLog(logABI.inputs, copy.data, copy.topics);\n        copy.args = reformat.numbers.call(constructor, logArgs, logABI.inputs);\n      } catch (_) {\n        return null;\n      }\n\n      delete copy.data;\n      delete copy.topics;\n      return copy;\n    }).filter(function (log) {\n      return log != null;\n    });\n  },\n  toTruffleLog: function toTruffleLog(events, isSingle) {\n    // Transform singletons (from event listeners) to the kind of\n    // object we find on the receipt\n    if (isSingle && typeof isSingle === \"boolean\") {\n      var temp = [];\n      temp.push(events);\n      return temp.map(function (log) {\n        log.data = log.raw.data;\n        log.topics = log.raw.topics;\n        return log;\n      });\n    } // Or reformat items in the existing array\n\n\n    events.forEach(function (event) {\n      if (event.raw) {\n        event.data = event.raw.data;\n        event.topics = event.raw.topics;\n      }\n    });\n    return events;\n  },\n  merge: function merge() {\n    var merged = {};\n    var args = Array.prototype.slice.call(arguments);\n\n    for (var i = 0; i < args.length; i++) {\n      var object = args[i];\n      var keys = Object.keys(object);\n\n      for (var j = 0; j < keys.length; j++) {\n        var key = keys[j];\n        var value = object[key];\n        merged[key] = value;\n      }\n    }\n\n    return merged;\n  },\n  linkBytecode: function linkBytecode(bytecode, links) {\n    Object.keys(links).forEach(function (library_name) {\n      var library_address = links[library_name];\n      var regex = new RegExp(\"__\".concat(library_name, \"_+\"), \"g\");\n      bytecode = bytecode.replace(regex, library_address.replace(\"0x\", \"\"));\n    });\n    return bytecode;\n  },\n  // Extracts optional tx params from a list of fn arguments\n  getTxParams: function getTxParams(methodABI, args) {\n    var ignoreDefaultGasPriceParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var constructor = this;\n    var expectedArgCount = methodABI ? methodABI.inputs.length : 0;\n    var txParams = {};\n    var lastArg = args[args.length - 1];\n\n    if (args.length === expectedArgCount + 1 && Utils.isTxParams(lastArg)) {\n      txParams = args.pop();\n    }\n\n    var defaultParams = constructor.class_defaults;\n\n    if (ignoreDefaultGasPriceParams) {\n      //this parameter is set when making calls (as opposed to transactions)\n      //gas price params can cause problems with those on some networks, so\n      //we ignore any defaults, and only include them if they were explicitly\n      //specified\n      defaultParams = _objectSpread({}, constructor.class_defaults); //clone\n\n      delete defaultParams.gasPrice;\n      delete defaultParams.maxFeePerGas;\n      delete defaultParams.maxPriorityFeePerGas;\n    }\n\n    return Utils.merge(defaultParams, txParams);\n  },\n  // Verifies that a contracts libraries have been linked correctly.\n  // Throws on error\n  checkLibraries: function checkLibraries() {\n    var constructor = this;\n    var regex = /__[^_]+_+/g;\n    var unlinkedLibraries = constructor.binary.match(regex);\n\n    if (unlinkedLibraries !== null) {\n      unlinkedLibraries = unlinkedLibraries.map(function (name // Remove underscores\n      ) {\n        return name.replace(/_/g, \"\");\n      }).sort().filter(function (name, index, arr) {\n        // Remove duplicates\n        if (index + 1 >= arr.length) {\n          return true;\n        }\n\n        return name !== arr[index + 1];\n      }).join(\", \");\n      var error = \"\".concat(constructor.contractName, \" contains unresolved libraries. You must deploy and link the following libraries before you can deploy a new version of \").concat(constructor.contractName, \": \").concat(unlinkedLibraries);\n      throw new Error(error);\n    }\n  },\n  convertToEthersBN: function convertToEthersBN(original) {\n    var converted = [];\n    original.forEach(function (item) {\n      // Recurse for arrays\n      if (Array.isArray(item)) {\n        converted.push(Utils.convertToEthersBN(item)); // Convert Web3 BN / BigNumber\n      } else if (Utils.is_big_number(item)) {\n        //HACK: Since we can't rely on web3Utils.isBigNumber to tell\n        //whether we have a bignumber.js BigNumber, we'll just check\n        //whether it has the toFixed method\n        var stringValue = item.toFixed ? item.toFixed() //prevents use of scientific notation\n        : item.toString();\n        var ethersBN = bigNumberify(stringValue);\n        converted.push(ethersBN);\n      } else {\n        converted.push(item);\n      }\n    });\n    return converted;\n  },\n\n  /**\n   * Multiplies an ethers.js BigNumber and a number with decimal places using\n   * integer math rather than using an arbitrary floating-point library like\n   * `bignumber.js`.\n   * @param  {BigNumber} bignum            an ethers.js BigNumber (use bigNumberify)\n   * @param  {Number}    decimal           a number which has 0+ decimal places\n   * @param  {Number}    [maxPrecision=5]  the max number of signficant figures\n   *                                       `decimal` can have. (default: 5)\n   * @return {BigNumber}                   floor(bignum * decimal)\n   */\n  multiplyBigNumberByDecimal: function multiplyBigNumberByDecimal(bignum, decimal, maxPrecision) {\n    if (typeof maxPrecision === \"undefined\") {\n      maxPrecision = 5;\n    }\n\n    var significantFigures = Math.min(decimal.toString().length - 1, // length less one because `.`\n    maxPrecision);\n    var denominator = bigNumberify(10).pow(significantFigures);\n    var multiplier = Math.round(decimal * denominator);\n    var numerator = bigNumberify(multiplier).mul(bignum);\n    return numerator.div(denominator);\n  },\n  // checks if given contract instance has a set provider\n  checkProvider: function checkProvider(_ref) {\n    var currentProvider = _ref.currentProvider,\n        contractName = _ref.contractName;\n    if (!currentProvider) throw new Error(\"\".concat(contractName, \" error: Please call setProvider() first before calling new().\"));\n  },\n  // verifies current network has been assigned to contract instance\n  checkNetworkArtifactMatch: function checkNetworkArtifactMatch(_ref2) {\n    var networks = _ref2.networks,\n        network_id = _ref2.network_id,\n        contractName = _ref2.contractName;\n    if (networks[network_id] == null) throw new Error(\"\".concat(contractName, \" has not been deployed to detected network (network/artifact mismatch)\"));\n  },\n  // verifies contract instance has been deployed\n  checkDeployment: function checkDeployment(_ref3) {\n    var isDeployed = _ref3.isDeployed,\n        contractName = _ref3.contractName,\n        network_id = _ref3.network_id;\n    if (!isDeployed()) throw new Error(\"\".concat(contractName, \" has not been deployed to detected network (\").concat(network_id, \")\"));\n  },\n  // checks if provided contract address has on-chain code\n  checkCode: function checkCode(onChainCode, contractName, address) {\n    if (!onChainCode || onChainCode.replace(\"0x\", \"\").replace(/0/g, \"\") === \"\") throw new Error(\"Cannot create instance of \".concat(contractName, \"; no code at address \").concat(address));\n  },\n  // parses known contract instance networks\n  parseKnownNetworks: function () {\n    var _parseKnownNetworks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref4, gasLimit) {\n      var networks, currentProvider, setNetwork, network_id, network, networkMatches;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              networks = _ref4.networks, currentProvider = _ref4.currentProvider, setNetwork = _ref4.setNetwork, network_id = _ref4.network_id;\n\n              if (!(!networks && Object.keys(networks).length === 0)) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\", false);\n\n            case 3:\n              _context.t0 = _regeneratorRuntime.keys(networks);\n\n            case 4:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              network = _context.t1.value;\n\n              if (!network.startsWith(\"blockchain://\")) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 9;\n              return BlockchainUtils.matches(network, currentProvider);\n\n            case 9:\n              networkMatches = _context.sent;\n\n              if (!networkMatches) {\n                _context.next = 13;\n                break;\n              }\n\n              setNetwork(network);\n              return _context.abrupt(\"return\", {\n                id: network_id,\n                blockLimit: gasLimit\n              });\n\n            case 13:\n              _context.next = 4;\n              break;\n\n            case 15:\n              return _context.abrupt(\"return\", false);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function parseKnownNetworks(_x, _x2) {\n      return _parseKnownNetworks.apply(this, arguments);\n    }\n\n    return parseKnownNetworks;\n  }(),\n  // sets a contract instance network ID\n  setInstanceNetworkID: function () {\n    var _setInstanceNetworkID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(TruffleContractInstance, chainNetworkID, gasLimit) {\n      var matchedNetwork;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!TruffleContractInstance.hasNetwork(chainNetworkID)) {\n                _context2.next = 3;\n                break;\n              }\n\n              TruffleContractInstance.setNetwork(chainNetworkID);\n              return _context2.abrupt(\"return\", {\n                id: TruffleContractInstance.network_id,\n                blockLimit: gasLimit\n              });\n\n            case 3:\n              _context2.next = 5;\n              return Utils.parseKnownNetworks(TruffleContractInstance, gasLimit);\n\n            case 5:\n              matchedNetwork = _context2.sent;\n\n              if (!matchedNetwork) {\n                _context2.next = 8;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", matchedNetwork);\n\n            case 8:\n              // network unknown, trust the provider and use given chainNetworkID\n              TruffleContractInstance.setNetwork(chainNetworkID);\n              return _context2.abrupt(\"return\", {\n                id: TruffleContractInstance.network_id,\n                blockLimit: gasLimit\n              });\n\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function setInstanceNetworkID(_x3, _x4, _x5) {\n      return _setInstanceNetworkID.apply(this, arguments);\n    }\n\n    return setInstanceNetworkID;\n  }()\n};\nUtils.ens = ens;\nUtils.bigNumberify = bigNumberify;\nmodule.exports = Utils;","map":null,"metadata":{},"sourceType":"script"}