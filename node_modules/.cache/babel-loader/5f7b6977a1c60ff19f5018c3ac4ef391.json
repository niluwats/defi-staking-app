{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeStorage),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeStorageReferenceByAddress),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeStorageReference);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:storage:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar errors_1 = require(\"../../errors\");\n\nfunction decodeStorage(dataType, pointer, info) {\n  return _regeneratorRuntime.wrap(function decodeStorage$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!Format.Types.isReferenceType(dataType)) {\n            _context.next = 5;\n            break;\n          }\n\n          return _context.delegateYield(decodeStorageReference(dataType, pointer, info), \"t0\", 2);\n\n        case 2:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 5:\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info), \"t1\", 6);\n\n        case 6:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.decodeStorage = decodeStorage; //decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\n\nfunction decodeStorageReferenceByAddress(dataType, pointer, info) {\n  var allocations, rawValue, startOffset, rawSize, size, newPointer;\n  return _regeneratorRuntime.wrap(function decodeStorageReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          allocations = info.allocations.storage;\n          _context2.prev = 1;\n          return _context2.delegateYield(read_1.default(pointer, info.state), \"t0\", 3);\n\n        case 3:\n          rawValue = _context2.t0;\n          _context2.next = 9;\n          break;\n\n        case 6:\n          _context2.prev = 6;\n          _context2.t1 = _context2[\"catch\"](1);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t1));\n\n        case 9:\n          startOffset = Conversion.toBN(rawValue);\n          _context2.prev = 10;\n          rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n          _context2.next = 17;\n          break;\n\n        case 14:\n          _context2.prev = 14;\n          _context2.t2 = _context2[\"catch\"](10);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t2));\n\n        case 17:\n          //we *know* the type being decoded must be sized in words, because it's a\n          //reference type, but TypeScript doesn't, so we'll have to use a type\n          //coercion\n          size = rawSize.words; //now, construct the storage pointer\n\n          newPointer = {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  offset: startOffset\n                },\n                index: 0\n              },\n              to: {\n                slot: {\n                  offset: startOffset.addn(size - 1)\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n              }\n            }\n          }; //dispatch to decodeStorageReference\n\n          return _context2.delegateYield(decodeStorageReference(dataType, newPointer, info), \"t3\", 20);\n\n        case 20:\n          return _context2.abrupt(\"return\", _context2.t3);\n\n        case 21:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[1, 6], [10, 14]]);\n}\n\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\n\nfunction decodeStorageReference(dataType, pointer, info) {\n  var data, length, state, allocations, lengthAsBN, baseSize, ranges, currentSlot, i, childRange, perWord, currentPosition, _i, _childRange, decodedChildren, _i2, _ranges, _childRange2, lengthByte, _lengthAsBN, typeId, structAllocation, decodedMembers, members, index, memberAllocation, memberPointer, _childRange3, storedType, storedMemberType, memberType, valueType, valueSize, decodedEntries, baseSlot, keySlots, _iterator, _step, key, valuePointer;\n\n  return _regeneratorRuntime.wrap(function decodeStorageReference$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          state = info.state;\n          allocations = info.allocations.storage;\n          _context3.t0 = dataType.typeClass;\n          _context3.next = _context3.t0 === \"array\" ? 5 : _context3.t0 === \"bytes\" ? 55 : _context3.t0 === \"string\" ? 55 : _context3.t0 === \"struct\" ? 82 : _context3.t0 === \"mapping\" ? 109 : 147;\n          break;\n\n        case 5:\n          debug(\"storage array! %o\", pointer);\n          _context3.t1 = dataType.kind;\n          _context3.next = _context3.t1 === \"dynamic\" ? 9 : _context3.t1 === \"static\" ? 21 : 24;\n          break;\n\n        case 9:\n          debug(\"dynamic array\");\n          debug(\"type %O\", dataType);\n          _context3.prev = 11;\n          return _context3.delegateYield(read_1.default(pointer, state), \"t2\", 13);\n\n        case 13:\n          data = _context3.t2;\n          _context3.next = 19;\n          break;\n\n        case 16:\n          _context3.prev = 16;\n          _context3.t3 = _context3[\"catch\"](11);\n          return _context3.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context3.t3));\n\n        case 19:\n          lengthAsBN = Conversion.toBN(data);\n          return _context3.abrupt(\"break\", 24);\n\n        case 21:\n          debug(\"static array\");\n          lengthAsBN = dataType.length;\n          return _context3.abrupt(\"break\", 24);\n\n        case 24:\n          _context3.prev = 24;\n          length = lengthAsBN.toNumber();\n          _context3.next = 31;\n          break;\n\n        case 28:\n          _context3.prev = 28;\n          _context3.t4 = _context3[\"catch\"](24);\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 31:\n          debug(\"length %o\", length);\n          debug(\"about to determine baseSize\");\n          _context3.prev = 33;\n          baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n          _context3.next = 40;\n          break;\n\n        case 37:\n          _context3.prev = 37;\n          _context3.t5 = _context3[\"catch\"](33);\n          return _context3.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context3.t5));\n\n        case 40:\n          debug(\"baseSize %o\", baseSize); //we are going to make a list of child ranges, pushing them one by one onto\n          //this list, and then decode them; the first part will vary based on whether\n          //we're in the words case or the bytes case, the second will not\n\n          ranges = [];\n\n          if (Utils.isWordsLength(baseSize)) {\n            //currentSlot will point to the start of the entry being decoded\n            currentSlot = {\n              path: pointer.range.from.slot,\n              offset: new bn_js_1.default(0),\n              hashPath: dataType.kind === \"dynamic\"\n            };\n\n            for (i = 0; i < length; i++) {\n              childRange = {\n                from: {\n                  slot: {\n                    path: currentSlot.path,\n                    offset: currentSlot.offset.clone(),\n                    hashPath: currentSlot.hashPath\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    path: currentSlot.path,\n                    offset: currentSlot.offset.addn(baseSize.words - 1),\n                    hashPath: currentSlot.hashPath\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              };\n              ranges.push(childRange);\n              currentSlot.offset.iaddn(baseSize.words);\n            }\n          } else {\n            perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n            debug(\"perWord %d\", perWord); //currentPosition will point to the start of the entry being decoded\n            //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n\n            currentPosition = {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: new bn_js_1.default(0),\n                hashPath: dataType.kind === \"dynamic\"\n              },\n              index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n\n            };\n\n            for (_i = 0; _i < length; _i++) {\n              _childRange = {\n                from: {\n                  slot: {\n                    path: currentPosition.slot.path,\n                    offset: currentPosition.slot.offset.clone(),\n                    hashPath: currentPosition.slot.hashPath\n                  },\n                  index: currentPosition.index\n                },\n                length: baseSize.bytes\n              };\n              ranges.push(_childRange);\n              currentPosition.index -= baseSize.bytes;\n\n              if (currentPosition.index < 0) {\n                currentPosition.slot.offset.iaddn(1);\n                currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n              }\n            }\n          }\n\n          decodedChildren = [];\n          _i2 = 0, _ranges = ranges;\n\n        case 45:\n          if (!(_i2 < _ranges.length)) {\n            _context3.next = 54;\n            break;\n          }\n\n          _childRange2 = _ranges[_i2];\n          _context3.t6 = decodedChildren;\n          return _context3.delegateYield(decodeStorage(dataType.baseType, {\n            location: \"storage\",\n            range: _childRange2\n          }, info), \"t7\", 49);\n\n        case 49:\n          _context3.t8 = _context3.t7;\n\n          _context3.t6.push.call(_context3.t6, _context3.t8);\n\n        case 51:\n          _i2++;\n          _context3.next = 45;\n          break;\n\n        case 54:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 55:\n          _context3.prev = 55;\n          return _context3.delegateYield(read_1.default(pointer, state), \"t9\", 57);\n\n        case 57:\n          data = _context3.t9;\n          _context3.next = 63;\n          break;\n\n        case 60:\n          _context3.prev = 60;\n          _context3.t10 = _context3[\"catch\"](55);\n          return _context3.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context3.t10));\n\n        case 63:\n          lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n\n          if (!(lengthByte % 2 == 0)) {\n            _context3.next = 71;\n            break;\n          }\n\n          // string lives in word, length is last byte / 2\n          length = lengthByte / 2;\n          debug(\"in-word; length %o\", length);\n          return _context3.delegateYield(Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: pointer.range.from.slot,\n                index: 0\n              },\n              to: {\n                slot: pointer.range.from.slot,\n                index: length - 1\n              }\n            }\n          }, info), \"t11\", 68);\n\n        case 68:\n          return _context3.abrupt(\"return\", _context3.t11);\n\n        case 71:\n          _lengthAsBN = Conversion.toBN(data).subn(1).divn(2);\n          _context3.prev = 72;\n          length = _lengthAsBN.toNumber();\n          _context3.next = 79;\n          break;\n\n        case 76:\n          _context3.prev = 76;\n          _context3.t12 = _context3[\"catch\"](72);\n          return _context3.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: _lengthAsBN\n            }\n          });\n\n        case 79:\n          debug(\"new-word, length %o\", length);\n          return _context3.delegateYield(Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  path: pointer.range.from.slot,\n                  offset: new bn_js_1.default(0),\n                  hashPath: true\n                },\n                index: 0\n              },\n              length: length\n            }\n          }, info), \"t13\", 81);\n\n        case 81:\n          return _context3.abrupt(\"return\", _context3.t13);\n\n        case 82:\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context3.next = 86;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          });\n\n        case 86:\n          decodedMembers = [];\n          members = structAllocation.members;\n          index = 0;\n\n        case 89:\n          if (!(index < members.length)) {\n            _context3.next = 108;\n            break;\n          }\n\n          memberAllocation = members[index];\n          memberPointer = memberAllocation.pointer; //the type system thinks memberPointer might also be a constant\n          //definition pointer.  However, structs can't contain constants,\n          //so *we* know it's not, and can safely coerce it.\n\n          debug(\"pointer %O\", pointer);\n          _childRange3 = {\n            from: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.from.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.from.index\n            },\n            to: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.to.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.to.index\n            }\n          };\n          storedType = info.userDefinedTypes[typeId];\n\n          if (storedType) {\n            _context3.next = 97;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          });\n\n        case 97:\n          storedMemberType = storedType.memberTypes[index].type;\n          memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n          _context3.t14 = decodedMembers;\n          _context3.t15 = memberAllocation.name;\n          return _context3.delegateYield(decodeStorage(memberType, {\n            location: \"storage\",\n            range: _childRange3\n          }, info), \"t16\", 102);\n\n        case 102:\n          _context3.t17 = _context3.t16;\n          _context3.t18 = {\n            name: _context3.t15,\n            value: _context3.t17\n          };\n\n          _context3.t14.push.call(_context3.t14, _context3.t18);\n\n        case 105:\n          index++;\n          _context3.next = 89;\n          break;\n\n        case 108:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 109:\n          debug(\"decoding mapping\");\n          valueType = dataType.valueType;\n          _context3.prev = 111;\n          valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n          _context3.next = 118;\n          break;\n\n        case 115:\n          _context3.prev = 115;\n          _context3.t19 = _context3[\"catch\"](111);\n          return _context3.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context3.t19));\n\n        case 118:\n          decodedEntries = [];\n          baseSlot = pointer.range.from.slot;\n          debug(\"baseSlot %o\", baseSlot);\n          debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n          keySlots = info.mappingKeys.filter(function (_ref) {\n            var path = _ref.path;\n            return Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path));\n          });\n          _iterator = _createForOfIteratorHelper(keySlots);\n          _context3.prev = 124;\n\n          _iterator.s();\n\n        case 126:\n          if ((_step = _iterator.n()).done) {\n            _context3.next = 138;\n            break;\n          }\n\n          key = _step.value.key;\n          valuePointer = void 0;\n\n          if (Utils.isWordsLength(valueSize)) {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(valueSize.words - 1)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          } else {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                },\n                to: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          }\n\n          _context3.t20 = decodedEntries;\n          _context3.t21 = key;\n          return _context3.delegateYield(decodeStorage(valueType, valuePointer, info), \"t22\", 133);\n\n        case 133:\n          _context3.t23 = _context3.t22;\n          _context3.t24 = {\n            key: _context3.t21,\n            value: _context3.t23\n          };\n\n          _context3.t20.push.call(_context3.t20, _context3.t24);\n\n        case 136:\n          _context3.next = 126;\n          break;\n\n        case 138:\n          _context3.next = 143;\n          break;\n\n        case 140:\n          _context3.prev = 140;\n          _context3.t25 = _context3[\"catch\"](124);\n\n          _iterator.e(_context3.t25);\n\n        case 143:\n          _context3.prev = 143;\n\n          _iterator.f();\n\n          return _context3.finish(143);\n\n        case 146:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedEntries\n          });\n\n        case 147:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[11, 16], [24, 28], [33, 37], [55, 60], [72, 76], [111, 115], [124, 140, 143, 146]]);\n}\n\nexports.decodeStorageReference = decodeStorageReference;","map":null,"metadata":{},"sourceType":"script"}