{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Decoder = require('./decoder');\n\nvar Simple = require('./simple');\n\nvar utils = require('./utils');\n\nvar constants = require('./constants');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar NoFilter = require('nofilter');\n\nvar MT = constants.MT;\nvar SYMS = constants.SYMS;\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\n\nvar Diagnose = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(Diagnose, _stream$Transform);\n\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  function Diagnose(options) {\n    var _this;\n\n    _classCallCheck(this, Diagnose);\n\n    var opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    var separator = opts.separator;\n    delete opts.separator;\n    var stream_errors = opts.stream_errors;\n    delete opts.stream_errors;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Diagnose).call(this, opts));\n    _this.float_bytes = -1;\n    _this.separator = separator;\n    _this.stream_errors = stream_errors;\n    _this.parser = new Decoder(opts);\n\n    _this.parser.on('more-bytes', _this._on_more.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('value', _this._on_value.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('start', _this._on_start.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('stop', _this._on_stop.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('data', _this._on_data.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.parser.on('error', _this._on_error.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    return _this;\n  }\n\n  _createClass(Diagnose, [{\n    key: \"_transform\",\n    value: function _transform(fresh, encoding, cb) {\n      return this.parser.write(fresh, encoding, cb);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(cb) {\n      var _this2 = this;\n\n      return this.parser._flush(function (er) {\n        if (_this2.stream_errors) {\n          if (er) {\n            _this2._on_error(er);\n          }\n\n          return cb();\n        } else {\n          return cb(er);\n        }\n      });\n    }\n    /**\n     * Convenience function to return a string in diagnostic format.\n     *\n     * @param {(Buffer|string)} input - the CBOR bytes to format\n     * @param {string} [encoding='hex'] - the encoding of input, ignored if\n     *   input is Buffer\n     * @param {function(Error, string): undefined} cb - callback\n     * @returns {Promise} if callback not specified\n     */\n\n  }, {\n    key: \"_on_error\",\n    value: function _on_error(er) {\n      if (this.stream_errors) {\n        return this.push(er.toString());\n      } else {\n        return this.emit('error', er);\n      }\n    }\n  }, {\n    key: \"_on_more\",\n    value: function _on_more(mt, len, parent_mt, pos) {\n      if (mt === MT.SIMPLE_FLOAT) {\n        return this.float_bytes = {\n          2: 1,\n          4: 2,\n          8: 3\n        }[len];\n      }\n    }\n  }, {\n    key: \"_fore\",\n    value: function _fore(parent_mt, pos) {\n      switch (parent_mt) {\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n        case MT.ARRAY:\n          if (pos > 0) {\n            return this.push(', ');\n          }\n\n          break;\n\n        case MT.MAP:\n          if (pos > 0) {\n            if (pos % 2) {\n              return this.push(': ');\n            } else {\n              return this.push(', ');\n            }\n          }\n\n      }\n    }\n  }, {\n    key: \"_on_value\",\n    value: function _on_value(val, parent_mt, pos) {\n      var _this3 = this;\n\n      if (val === SYMS.BREAK) {\n        return;\n      }\n\n      this._fore(parent_mt, pos);\n\n      return this.push(function () {\n        switch (false) {\n          case val !== SYMS.NULL:\n            return 'null';\n\n          case val !== SYMS.UNDEFINED:\n            return 'undefined';\n\n          case typeof val !== 'string':\n            return JSON.stringify(val);\n\n          case !(_this3.float_bytes > 0):\n            var fb = _this3.float_bytes;\n            _this3.float_bytes = -1;\n            return util.inspect(val) + '_' + fb;\n\n          case !Buffer.isBuffer(val):\n            return 'h\\'' + val.toString('hex') + '\\'';\n\n          case !(val instanceof bignumber):\n            return val.toString();\n\n          default:\n            return util.inspect(val);\n        }\n      }());\n    }\n  }, {\n    key: \"_on_start\",\n    value: function _on_start(mt, tag, parent_mt, pos) {\n      this._fore(parent_mt, pos);\n\n      switch (mt) {\n        case MT.TAG:\n          this.push(\"\".concat(tag, \"(\"));\n          break;\n\n        case MT.ARRAY:\n          this.push('[');\n          break;\n\n        case MT.MAP:\n          this.push('{');\n          break;\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          this.push('(');\n          break;\n      }\n\n      if (tag === SYMS.STREAM) {\n        return this.push('_ ');\n      }\n    }\n  }, {\n    key: \"_on_stop\",\n    value: function _on_stop(mt) {\n      switch (mt) {\n        case MT.TAG:\n          return this.push(')');\n\n        case MT.ARRAY:\n          return this.push(']');\n\n        case MT.MAP:\n          return this.push('}');\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          return this.push(')');\n      }\n    }\n  }, {\n    key: \"_on_data\",\n    value: function _on_data() {\n      return this.push(this.separator);\n    }\n  }], [{\n    key: \"diagnose\",\n    value: function diagnose(input, encoding, cb) {\n      if (input == null) {\n        throw new Error('input required');\n      }\n\n      var opts = {};\n      var encod = 'hex';\n\n      switch (typeof encoding) {\n        case 'function':\n          cb = encoding;\n          encod = utils.guessEncoding(input);\n          break;\n\n        case 'object':\n          opts = utils.extend({}, encoding);\n          encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n          delete opts.encoding;\n          break;\n\n        default:\n          encod = encoding != null ? encoding : 'hex';\n      }\n\n      var bs = new NoFilter();\n      var d = new Diagnose(opts);\n      var p = null;\n\n      if (typeof cb === 'function') {\n        d.on('end', function () {\n          return cb(null, bs.toString('utf8'));\n        });\n        d.on('error', cb);\n      } else {\n        p = new Promise(function (resolve, reject) {\n          d.on('end', function () {\n            return resolve(bs.toString('utf8'));\n          });\n          return d.on('error', reject);\n        });\n      }\n\n      d.pipe(bs);\n      d.end(input, encod);\n      return p;\n    }\n  }]);\n\n  return Diagnose;\n}(stream.Transform);\n\nmodule.exports = Diagnose;","map":null,"metadata":{},"sourceType":"script"}