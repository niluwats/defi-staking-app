{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.unsafeNativize = exports.ResultInspector = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:export\");\n\nvar Conversion = __importStar(require(\"./conversion\"));\n\nvar inspect_1 = require(\"./format/utils/inspect\");\n\nObject.defineProperty(exports, \"ResultInspector\", {\n  enumerable: true,\n  get: function get() {\n    return inspect_1.ResultInspector;\n  }\n});\nObject.defineProperty(exports, \"unsafeNativize\", {\n  enumerable: true,\n  get: function get() {\n    return inspect_1.unsafeNativize;\n  }\n});\n/**\n * This function is similar to\n * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to\n * be safe, and also allows for different output formats.  The only currently\n * supported format is \"ethers\", which is intended to match the way that\n * Truffle Contract currently returns values (based on the Ethers decoder).  As\n * such, it only handles ABI types, and in addition does not handle the types\n * fixed, ufixed, or function.  Note that in these cases it returns `undefined`\n * rather than throwing, as we want this function to be used in contexts where\n * it had better not throw.  It also does not handle circularities, for similar\n * reasons.\n *\n * To handle numeric types, this function takes an optional numberFormatter\n * option that tells it how to handle numbers; this function should take a\n * BigInt as input.  By default, this function will be the identity, and so\n * numbers will be represented as BigInts.\n *\n * Note that this function begins by calling abify, so out-of-range enums (that\n * aren't so out-of-range as to be padding errors) will not return `undefined`.\n * Out-of-range booleans similarly will return true rather than `undefined`.\n * However, other range errors may return `undefined`; this may technically be a\n * slight incompatibility with existing behavior, but should not be relevant\n * except in quite unusual cases.\n *\n * In order to match the behavior for tuples, tuples will be transformed into\n * arrays, but named entries will additionally be keyed by name.  Moreover,\n * indexed variables of reference type will be nativized to an undecoded hex\n * string.\n */\n\nfunction nativize(result) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var numberFormatter = options.numberFormatter || function (x) {\n    return x;\n  };\n\n  var format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativize(result, numberFormatter);\n  }\n}\n\nexports.nativize = nativize;\n\nfunction ethersCompatibleNativize(result) {\n  var numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {\n    return x;\n  };\n\n  //note: the original version of this function began by calling abify,\n  //but we don't do that here because abify requires a userDefinedTypes\n  //parameter and we don't want that.\n  //However, it only needs that to handle getting the types right.  Since\n  //we don't care about that here, we instead do away with abify and handle\n  //such matters ourselves (which is less convenient, yeah).\n  switch (result.kind) {\n    case \"error\":\n      switch (result.error.kind) {\n        case \"IndexedReferenceTypeError\":\n          //strictly speaking for arrays ethers will fail to decode\n          //rather than do this, but, eh\n          return result.error.raw;\n\n        case \"EnumOutOfRangeError\":\n          return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));\n\n        default:\n          return undefined;\n      }\n\n    case \"value\":\n      switch (result.type.typeClass) {\n        case \"uint\":\n        case \"int\":\n          var asBN = result.value.asBN;\n          return numberFormatter(Conversion.toBigInt(asBN));\n\n        case \"enum\":\n          var numericAsBN = result.value.numericAsBN;\n          return numberFormatter(Conversion.toBigInt(numericAsBN));\n\n        case \"bool\":\n          return result.value.asBoolean;\n\n        case \"bytes\":\n          var asHex = result.value.asHex;\n          return asHex !== \"0x\" ? asHex : null;\n\n        case \"address\":\n          return result.value.asAddress;\n\n        case \"contract\":\n          return result.value.address;\n\n        case \"string\":\n          {\n            var coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"valid\":\n                return coercedResult.value.asString;\n\n              case \"malformed\":\n                // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                // note we need to cut off the 0x prefix\n                return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n            }\n          }\n\n        case \"userDefinedValueType\":\n          return ethersCompatibleNativize(result.value, numberFormatter);\n\n        case \"array\":\n          return result.value.map(function (value) {\n            return ethersCompatibleNativize(value, numberFormatter);\n          });\n\n        case \"tuple\":\n        case \"struct\":\n          //in this case, we need the result to be an array, but also\n          //to have the field names (where extant) as keys\n          var nativized = [];\n          var pairs = result.value;\n\n          var _iterator = _createForOfIteratorHelper(pairs),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _step.value,\n                  name = _step$value.name,\n                  value = _step$value.value;\n              var nativizedValue = ethersCompatibleNativize(value, numberFormatter);\n              nativized.push(nativizedValue);\n\n              if (name) {\n                nativized[name] = nativizedValue;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          return nativized;\n\n        case \"function\":\n          switch (result.type.visibility) {\n            case \"external\":\n              var _coercedResult = result; //ethers per se doesn't handle this, but web3's hacked version will\n              //sometimes decode these as just a bytes24, so let's do that\n\n              return _coercedResult.value.contract.address.toLowerCase() + _coercedResult.value.selector.slice(2);\n\n            case \"internal\":\n              return undefined;\n          }\n\n        case \"fixed\":\n        case \"ufixed\":\n        default:\n          return undefined;\n      }\n\n  }\n}\n/**\n * This function is similar to [[nativize]], but takes\n * a [[ReturndataDecoding]].  If there's only one returned value, it\n * will be run through compatibleNativize but otherwise unaltered;\n * otherwise the results will be put in an object.\n *\n * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],\n * this will just return `undefined`.\n */\n\n\nfunction nativizeReturn(decoding) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var numberFormatter = options.numberFormatter || function (x) {\n    return x;\n  };\n\n  var format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeReturn(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeReturn = nativizeReturn;\n\nfunction ethersCompatibleNativizeReturn(decoding) {\n  var numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {\n    return x;\n  };\n\n  if (decoding.kind !== \"return\") {\n    return undefined;\n  }\n\n  if (decoding.arguments.length === 1) {\n    return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);\n  }\n\n  var result = {};\n\n  for (var i = 0; i < decoding.arguments.length; i++) {\n    var _decoding$arguments$i = decoding.arguments[i],\n        name = _decoding$arguments$i.name,\n        value = _decoding$arguments$i.value;\n    var nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  }\n\n  return result;\n}\n/**\n * This function is similar to [[compatibleNativize]], but takes\n * a [[LogDecoding]], and puts the results in an object.  Note\n * that this does not return the entire event info, but just the\n * `args` for the event.\n */\n\n\nfunction nativizeEventArgs(decoding) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var numberFormatter = options.numberFormatter || function (x) {\n    return x;\n  };\n\n  var format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeEventArgs = nativizeEventArgs;\n\nfunction ethersCompatibleNativizeEventArgs(decoding) {\n  var numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {\n    return x;\n  };\n  var result = {};\n\n  for (var i = 0; i < decoding.arguments.length; i++) {\n    var _decoding$arguments$i2 = decoding.arguments[i],\n        name = _decoding$arguments$i2.name,\n        value = _decoding$arguments$i2.value;\n    var nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  } //note: if you have an argument named __length__, what ethers\n  //actually does is... weird.  we're just going to do this instead,\n  //which is simpler and probably more useful, even if it's not strictly\n  //the same (I *seriously* doubt anyone was relying on the old behavior,\n  //because it's, uh, not very useful)\n\n\n  result.__length__ = decoding.arguments.length;\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}