{"ast":null,"code":"import _classCallCheck from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { integerLogLike, biasNumericRange } from './helpers/BiasNumericRange.js';\nimport { shrinkInteger } from './helpers/ShrinkInteger.js';\nexport var IntegerArbitrary = /*#__PURE__*/function (_NextArbitrary) {\n  _inherits(IntegerArbitrary, _NextArbitrary);\n\n  function IntegerArbitrary(min, max) {\n    var _this;\n\n    _classCallCheck(this, IntegerArbitrary);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(IntegerArbitrary).call(this));\n    _this.min = min;\n    _this.max = max;\n    return _this;\n  }\n\n  _createClass(IntegerArbitrary, [{\n    key: \"generate\",\n    value: function generate(mrng, biasFactor) {\n      var range = this.computeGenerateRange(mrng, biasFactor);\n      return new NextValue(mrng.nextInt(range.min, range.max), undefined);\n    }\n  }, {\n    key: \"canShrinkWithoutContext\",\n    value: function canShrinkWithoutContext(value) {\n      return typeof value === 'number' && Number.isInteger(value) && !Object.is(value, -0) && this.min <= value && value <= this.max;\n    }\n  }, {\n    key: \"shrink\",\n    value: function shrink(current, context) {\n      if (!IntegerArbitrary.isValidContext(current, context)) {\n        var target = this.defaultTarget();\n        return shrinkInteger(current, target, true);\n      }\n\n      if (this.isLastChanceTry(current, context)) {\n        return Stream.of(new NextValue(context, undefined));\n      }\n\n      return shrinkInteger(current, context, false);\n    }\n  }, {\n    key: \"defaultTarget\",\n    value: function defaultTarget() {\n      if (this.min <= 0 && this.max >= 0) {\n        return 0;\n      }\n\n      return this.min < 0 ? this.max : this.min;\n    }\n  }, {\n    key: \"computeGenerateRange\",\n    value: function computeGenerateRange(mrng, biasFactor) {\n      if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n        return {\n          min: this.min,\n          max: this.max\n        };\n      }\n\n      var ranges = biasNumericRange(this.min, this.max, integerLogLike);\n\n      if (ranges.length === 1) {\n        return ranges[0];\n      }\n\n      var id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n      return id < 0 ? ranges[0] : ranges[id + 1];\n    }\n  }, {\n    key: \"isLastChanceTry\",\n    value: function isLastChanceTry(current, context) {\n      if (current > 0) return current === context + 1 && current > this.min;\n      if (current < 0) return current === context - 1 && current < this.max;\n      return false;\n    }\n  }], [{\n    key: \"isValidContext\",\n    value: function isValidContext(current, context) {\n      if (context === undefined) {\n        return false;\n      }\n\n      if (typeof context !== 'number') {\n        throw new Error(\"Invalid context type passed to IntegerArbitrary (#1)\");\n      }\n\n      if (context !== 0 && Math.sign(current) !== Math.sign(context)) {\n        throw new Error(\"Invalid context value passed to IntegerArbitrary (#2)\");\n      }\n\n      return true;\n    }\n  }]);\n\n  return IntegerArbitrary;\n}(NextArbitrary);","map":null,"metadata":{},"sourceType":"module"}