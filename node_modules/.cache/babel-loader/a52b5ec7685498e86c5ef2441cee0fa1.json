{"ast":null,"code":"var _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar debug = require(\"debug\")(\"contract:execute\");\n\nvar PromiEvent = require(\"./promievent\");\n\nvar EventEmitter = require(\"events\");\n\nvar utils = require(\"./utils\");\n\nvar StatusError = require(\"./statuserror\");\n\nvar Reason = require(\"./reason\");\n\nvar handlers = require(\"./handlers\");\n\nvar override = require(\"./override\");\n\nvar reformat = require(\"./reformat\");\n\nvar _require = require(\"./manual-send\"),\n    sendTransactionManual = _require.sendTransactionManual;\n\nvar execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function getGasEstimate(params, blockLimit) {\n    var stacktrace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var constructor = this;\n    var interfaceAdapter = this.interfaceAdapter;\n    return new Promise(function (accept) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n      interfaceAdapter.estimateGas(params, stacktrace).then(function (gas) {\n        // there are situations where the web3 gas estimation function in interfaceAdapter\n        // fails, specifically when a transaction will revert; we still want to continue\n        // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n        // default gas for that situation, equal to half of the blockLimit for the latest block\n        //\n        // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n        // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n        if (gas === null) {\n          var defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));\n          accept(defaultGas.toHexString());\n        } else {\n          var limit = utils.bigNumberify(blockLimit); // if we did get a numerical gas estimate from interfaceAdapter, we\n          // multiply that estimate by the gasMultiplier to help ensure we\n          // have enough gas for the transaction\n\n          var bestEstimate = utils.multiplyBigNumberByDecimal(utils.bigNumberify(gas), constructor.gasMultiplier); // Check that we don't go over blockLimit\n\n          bestEstimate.gte(limit) ? accept(limit.sub(1).toHexString()) : accept(bestEstimate.toHexString());\n        }\n      }).catch(function () {\n        return accept();\n      });\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @param  {Boolean}  isCall      Used when preparing a call as opposed to a tx;\n   *                                  skips network checks and ignores default gas prices\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: function () {\n    var _prepareCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(constructor, methodABI, _arguments, isCall) {\n      var args, params, web3, processedValues, network;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              args = Array.prototype.slice.call(_arguments);\n              params = utils.getTxParams.call(constructor, methodABI, args, isCall);\n              args = utils.convertToEthersBN(args);\n\n              if (!(constructor.ens && constructor.ens.enabled)) {\n                _context.next = 10;\n                break;\n              }\n\n              web3 = constructor.web3;\n              _context.next = 7;\n              return utils.ens.convertENSNames({\n                networkId: constructor.network_id,\n                ens: constructor.ens,\n                inputArgs: args,\n                inputParams: params,\n                methodABI: methodABI,\n                web3: web3\n              });\n\n            case 7:\n              processedValues = _context.sent;\n              args = processedValues.args;\n              params = processedValues.params;\n\n            case 10:\n              if (!isCall) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\", {\n                args: args,\n                params: params\n              });\n\n            case 12:\n              _context.next = 14;\n              return constructor.detectNetwork();\n\n            case 14:\n              network = _context.sent;\n              return _context.abrupt(\"return\", {\n                args: args,\n                params: params,\n                network: network\n              });\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function prepareCall(_x, _x2, _x3, _x4) {\n      return _prepareCall.apply(this, arguments);\n    }\n\n    return prepareCall;\n  }(),\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function hasTxParams(arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  inputs     ABI segment defining method arguments\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function hasDefaultBlock(args, lastArg, inputs) {\n    var hasDefaultBlock = !execute.hasTxParams(lastArg) && args.length > inputs.length;\n    var hasDefaultBlockWithParams = execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function call(fn, methodABI, address) {\n    var constructor = this;\n    return function () {\n      var defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      var args = Array.prototype.slice.call(arguments);\n      var lastArg = args[args.length - 1];\n      var promiEvent = new PromiEvent(); // Extract defaultBlock parameter\n\n      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {\n        defaultBlock = args.pop();\n      } //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation\n\n\n      var skipNetworkCheck = true;\n      execute.prepareCall(constructor, methodABI, args, skipNetworkCheck).then( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n          var args, params, result;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  args = _ref.args, params = _ref.params;\n                  params.to = address;\n                  promiEvent.eventEmitter.emit(\"execute:call:method\", {\n                    fn: fn,\n                    args: args,\n                    address: address,\n                    abi: methodABI,\n                    contract: constructor\n                  });\n                  _context2.next = 5;\n                  return fn.apply(void 0, _toConsumableArray(args)).call(params, defaultBlock);\n\n                case 5:\n                  result = _context2.sent;\n                  result = reformat.numbers.call(constructor, result, methodABI.outputs);\n                  return _context2.abrupt(\"return\", promiEvent.resolve(result));\n\n                case 8:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function (_x5) {\n          return _ref2.apply(this, arguments);\n        };\n      }()).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function send(fn, methodABI, address) {\n    var constructor = this;\n    var web3 = constructor.web3;\n    return function () {\n      var promiEvent = new PromiEvent(false, constructor.debugger);\n      execute.prepareCall(constructor, methodABI, arguments).then( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3) {\n          var args, params, network, context, stacktrace;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  args = _ref3.args, params = _ref3.params, network = _ref3.network;\n                  context = {\n                    contract: constructor,\n                    // Can't name this field `constructor` or `_constructor`\n                    promiEvent: promiEvent,\n                    params: params\n                  };\n                  params.to = address;\n                  params.data = fn ? fn.apply(void 0, _toConsumableArray(args)).encodeABI() : params.data;\n                  promiEvent.eventEmitter.emit(\"execute:send:method\", {\n                    fn: fn,\n                    args: args,\n                    address: address,\n                    abi: methodABI,\n                    contract: constructor\n                  });\n                  stacktrace = promiEvent.debug ? promiEvent.debug : false;\n                  _context3.prev = 6;\n                  _context3.next = 9;\n                  return execute.getGasEstimate.call(constructor, params, network.blockLimit, stacktrace);\n\n                case 9:\n                  params.gas = _context3.sent;\n                  _context3.next = 16;\n                  break;\n\n                case 12:\n                  _context3.prev = 12;\n                  _context3.t0 = _context3[\"catch\"](6);\n                  promiEvent.reject(_context3.t0);\n                  return _context3.abrupt(\"return\");\n\n                case 16:\n                  execute.sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n                  .then(function (receipt) {\n                    if (promiEvent.debug) {\n                      // in this case, we need to manually invoke the handler since it\n                      // hasn't been set up (hack?)\n                      handlers.receipt(context, receipt);\n                    } //otherwise, just let the handlers handle things\n\n                  }).catch(override.start.bind(constructor, context));\n\n                case 17:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, null, [[6, 12]]);\n        }));\n\n        return function (_x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }()).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function deploy(constructorABI) {\n    var constructor = this;\n    var web3 = constructor.web3;\n    return function () {\n      var deferred;\n      var promiEvent = new PromiEvent(false, constructor.debugger, true);\n      execute.prepareCall(constructor, constructorABI, arguments).then( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n          var args, params, network, blockLimit, context, options, contract, stacktrace, receipt, reason, error, web3Instance;\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  args = _ref5.args, params = _ref5.params, network = _ref5.network;\n                  blockLimit = network.blockLimit;\n                  utils.checkLibraries.apply(constructor); // Promievent and flag that allows instance to resolve (rather than just receipt)\n\n                  context = {\n                    contract: constructor,\n                    promiEvent: promiEvent,\n                    onlyEmitReceipt: true\n                  };\n                  options = {\n                    data: constructor.binary,\n                    arguments: args\n                  };\n                  contract = new web3.eth.Contract(constructor.abi);\n                  params.data = contract.deploy(options).encodeABI();\n                  stacktrace = promiEvent.debug ? promiEvent.debug : false;\n                  _context4.next = 10;\n                  return execute.getGasEstimate.call(constructor, params, blockLimit, stacktrace);\n\n                case 10:\n                  params.gas = _context4.sent;\n                  context.params = params;\n                  promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n                    args: args,\n                    abi: constructorABI,\n                    contract: constructor\n                  });\n                  deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n                  _context4.prev = 14;\n                  _context4.next = 17;\n                  return deferred;\n\n                case 17:\n                  receipt = _context4.sent;\n\n                  if (!(receipt.status !== undefined && !receipt.status)) {\n                    _context4.next = 24;\n                    break;\n                  }\n\n                  _context4.next = 21;\n                  return Reason.get(params, web3);\n\n                case 21:\n                  reason = _context4.sent;\n                  error = new StatusError(params, context.transactionHash, receipt, reason);\n                  return _context4.abrupt(\"return\", context.promiEvent.reject(error));\n\n                case 24:\n                  web3Instance = new web3.eth.Contract(constructor.abi, receipt.contractAddress);\n                  web3Instance.transactionHash = context.transactionHash;\n                  context.promiEvent.resolve(new constructor(web3Instance));\n                  _context4.next = 33;\n                  break;\n\n                case 29:\n                  _context4.prev = 29;\n                  _context4.t0 = _context4[\"catch\"](14);\n                  _context4.next = 33;\n                  return override.start.call(constructor, context, _context4.t0);\n\n                case 33:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[14, 29]]);\n        }));\n\n        return function (_x7) {\n          return _ref6.apply(this, arguments);\n        };\n      }()).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function event(fn) {\n    var constructor = this;\n    var decode = utils.decodeLogs;\n    var currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      } // As callback\n\n\n      if (callback !== undefined) {\n        var intermediary = function intermediary(err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n\n        return constructor.detectNetwork().then(function () {\n          return fn.call(constructor.events, params, intermediary);\n        });\n      } // As EventEmitter\n\n\n      var emitter = new EventEmitter();\n      constructor.detectNetwork().then(function () {\n        var event = fn(params);\n        event.on(\"data\", function (e) {\n          return dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]);\n        });\n        event.on(\"changed\", function (e) {\n          return dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]);\n        });\n        event.on(\"error\", function (e) {\n          return emitter.emit(\"error\", e);\n        });\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function allEvents(web3Instance) {\n    var constructor = this;\n    var decode = utils.decodeLogs;\n    var currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params) {\n      var emitter = new EventEmitter();\n      constructor.detectNetwork().then(function () {\n        var event = web3Instance.events.allEvents(params);\n        event.on(\"data\", function (e) {\n          return dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]);\n        });\n        event.on(\"changed\", function (e) {\n          return dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]);\n        });\n        event.on(\"error\", function (e) {\n          return emitter.emit(\"error\", e);\n        });\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function getPastEvents(web3Instance) {\n    var constructor = this;\n    var decode = utils.decodeLogs;\n    return function (event, options) {\n      return web3Instance.getPastEvents(event, options).then(function (events) {\n        return decode.call(constructor, events, false);\n      });\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function estimate(fn, methodABI) {\n    var constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(function (res) {\n        return fn.apply(void 0, _toConsumableArray(res.args)).estimateGas(res.params);\n      });\n    };\n  },\n\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function request(fn, methodABI, address) {\n    var constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(function (res) {\n        //clone res.params\n        var tx = {};\n\n        for (var key in res.params) {\n          tx[key] = res.params[key];\n        } //set to\n\n\n        tx.to = address; //set data\n\n        tx.data = fn.apply(void 0, _toConsumableArray(res.args)).encodeABI();\n        return tx;\n      });\n    };\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function estimateDeployment() {\n    var constructor = this;\n    var constructorABI = constructor.abi.filter(function (i) {\n      return i.type === \"constructor\";\n    })[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(function (res) {\n      var options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      delete res.params[\"data\"]; // Is this necessary?\n\n      var instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      return instance.deploy(options).estimateGas(res.params);\n    });\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function requestDeployment() {\n    var constructor = this;\n    var constructorABI = constructor.abi.filter(function (i) {\n      return i.type === \"constructor\";\n    })[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(function (res) {\n      //clone res.params\n      var tx = {};\n\n      for (var key in res.params) {\n        tx[key] = res.params[key];\n      }\n\n      var options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      var instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      tx.data = instance.deploy(options).encodeABI();\n      return tx;\n    });\n  },\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: function () {\n    var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(web3, params, promiEvent, context) {\n      var deferred;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(!promiEvent || !promiEvent.debug)) {\n                _context5.next = 4;\n                break;\n              }\n\n              deferred = web3.eth.sendTransaction(params);\n              handlers.setup(deferred, context);\n              return _context5.abrupt(\"return\", deferred);\n\n            case 4:\n              return _context5.abrupt(\"return\", sendTransactionManual(web3, params, promiEvent));\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    function sendTransaction(_x8, _x9, _x10, _x11) {\n      return _sendTransaction.apply(this, arguments);\n    }\n\n    return sendTransaction;\n  }()\n};\nmodule.exports = execute;","map":null,"metadata":{},"sourceType":"script"}