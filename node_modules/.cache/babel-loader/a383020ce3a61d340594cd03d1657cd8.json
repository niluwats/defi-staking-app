{"ast":null,"code":"import _toConsumableArray from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { escapeForTemplateString } from '../helpers/TextEscaper.js';\nimport { cloneMethod } from '../../../check/symbols.js';\nimport { stringify } from '../../../utils/stringify.js';\nexport var SchedulerImplem = /*#__PURE__*/function () {\n  function SchedulerImplem(act, taskSelector) {\n    _classCallCheck(this, SchedulerImplem);\n\n    this.act = act;\n    this.taskSelector = taskSelector;\n    this.lastTaskId = 0;\n    this.sourceTaskSelector = taskSelector.clone();\n    this.scheduledTasks = [];\n    this.triggeredTasks = [];\n  }\n\n  _createClass(SchedulerImplem, [{\n    key: \"log\",\n    value: function log(schedulingType, taskId, label, metadata, status, data) {\n      this.triggeredTasks.push({\n        status: status,\n        schedulingType: schedulingType,\n        taskId: taskId,\n        label: label,\n        metadata: metadata,\n        outputValue: data !== undefined ? stringify(data) : undefined\n      });\n    }\n  }, {\n    key: \"scheduleInternal\",\n    value: function scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {\n      var _this = this;\n\n      var trigger = null;\n      var taskId = ++this.lastTaskId;\n      var scheduledPromise = new Promise(function (resolve, reject) {\n        trigger = function trigger() {\n          (thenTaskToBeAwaited ? task.then(function () {\n            return thenTaskToBeAwaited();\n          }) : task).then(function (data) {\n            _this.log(schedulingType, taskId, label, metadata, 'resolved', data);\n\n            return resolve(data);\n          }, function (err) {\n            _this.log(schedulingType, taskId, label, metadata, 'rejected', err);\n\n            return reject(err);\n          });\n        };\n      });\n      this.scheduledTasks.push({\n        original: task,\n        scheduled: scheduledPromise,\n        trigger: trigger,\n        schedulingType: schedulingType,\n        taskId: taskId,\n        label: label,\n        metadata: metadata\n      });\n      return scheduledPromise;\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule(task, label, metadata) {\n      return this.scheduleInternal('promise', label || '', task, metadata);\n    }\n  }, {\n    key: \"scheduleFunction\",\n    value: function scheduleFunction(asyncFunction) {\n      var _this2 = this;\n\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return _this2.scheduleInternal('function', \"\".concat(asyncFunction.name, \"(\").concat(args.map(stringify).join(','), \")\"), asyncFunction.apply(void 0, args), undefined);\n      };\n    }\n  }, {\n    key: \"scheduleSequence\",\n    value: function scheduleSequence(sequenceBuilders) {\n      var _this3 = this;\n\n      var status = {\n        done: false,\n        faulty: false\n      };\n      var dummyResolvedPromise = {\n        then: function then(f) {\n          return f();\n        }\n      };\n\n      var resolveSequenceTask = function resolveSequenceTask() {};\n\n      var sequenceTask = new Promise(function (resolve) {\n        return resolveSequenceTask = resolve;\n      });\n      sequenceBuilders.reduce(function (previouslyScheduled, item) {\n        var _ref = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata],\n            _ref2 = _slicedToArray(_ref, 3),\n            builder = _ref2[0],\n            label = _ref2[1],\n            metadata = _ref2[2];\n\n        return previouslyScheduled.then(function () {\n          var scheduled = _this3.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, function () {\n            return builder();\n          });\n\n          scheduled.catch(function () {\n            status.faulty = true;\n            resolveSequenceTask();\n          });\n          return scheduled;\n        });\n      }, dummyResolvedPromise).then(function () {\n        status.done = true;\n        resolveSequenceTask();\n      }, function () {});\n      return Object.assign(status, {\n        task: Promise.resolve(sequenceTask).then(function () {\n          return {\n            done: status.done,\n            faulty: status.faulty\n          };\n        })\n      });\n    }\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.scheduledTasks.length;\n    }\n  }, {\n    key: \"internalWaitOne\",\n    value: function () {\n      var _internalWaitOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var taskIndex, _this$scheduledTasks$, _this$scheduledTasks$2, scheduledTask;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.scheduledTasks.length === 0)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('No task scheduled');\n\n              case 2:\n                taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);\n                _this$scheduledTasks$ = this.scheduledTasks.splice(taskIndex, 1), _this$scheduledTasks$2 = _slicedToArray(_this$scheduledTasks$, 1), scheduledTask = _this$scheduledTasks$2[0];\n                scheduledTask.trigger();\n                _context.prev = 5;\n                _context.next = 8;\n                return scheduledTask.scheduled;\n\n              case 8:\n                _context.next = 12;\n                break;\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](5);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 10]]);\n      }));\n\n      function internalWaitOne() {\n        return _internalWaitOne.apply(this, arguments);\n      }\n\n      return internalWaitOne;\n    }()\n  }, {\n    key: \"waitOne\",\n    value: function () {\n      var _waitOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.act( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.next = 2;\n                          return _this4.internalWaitOne();\n\n                        case 2:\n                          return _context2.abrupt(\"return\", _context2.sent);\n\n                        case 3:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function waitOne() {\n        return _waitOne.apply(this, arguments);\n      }\n\n      return waitOne;\n    }()\n  }, {\n    key: \"waitAll\",\n    value: function () {\n      var _waitAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.scheduledTasks.length > 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                _context4.next = 3;\n                return this.waitOne();\n\n              case 3:\n                _context4.next = 0;\n                break;\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function waitAll() {\n        return _waitAll.apply(this, arguments);\n      }\n\n      return waitAll;\n    }()\n  }, {\n    key: \"report\",\n    value: function report() {\n      return [].concat(_toConsumableArray(this.triggeredTasks), _toConsumableArray(this.scheduledTasks.map(function (t) {\n        return {\n          status: 'pending',\n          schedulingType: t.schedulingType,\n          taskId: t.taskId,\n          label: t.label,\n          metadata: t.metadata\n        };\n      })));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'schedulerFor()`\\n' + this.report().map(SchedulerImplem.buildLog).map(function (log) {\n        return \"-> \".concat(log);\n      }).join('\\n') + '`';\n    }\n  }, {\n    key: cloneMethod,\n    value: function value() {\n      return new SchedulerImplem(this.act, this.sourceTaskSelector);\n    }\n  }], [{\n    key: \"buildLog\",\n    value: function buildLog(reportItem) {\n      return \"[task${\".concat(reportItem.taskId, \"}] \").concat(reportItem.label.length !== 0 ? \"\".concat(reportItem.schedulingType, \"::\").concat(reportItem.label) : reportItem.schedulingType, \" \").concat(reportItem.status).concat(reportItem.outputValue !== undefined ? \" with value \".concat(escapeForTemplateString(reportItem.outputValue)) : '');\n    }\n  }]);\n\n  return SchedulerImplem;\n}();","map":null,"metadata":{},"sourceType":"module"}