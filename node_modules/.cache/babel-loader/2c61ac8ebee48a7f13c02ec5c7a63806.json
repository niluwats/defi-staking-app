{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeBasic),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeContract),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeContractAndContext),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeExternalFunction);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:basic:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Contexts = __importStar(require(\"../../contexts\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar errors_1 = require(\"../../errors\");\n\nvar allocate_1 = require(\"../allocate\");\n\nfunction decodeBasic(dataType, pointer, info) {\n  var options,\n      state,\n      strict,\n      paddingMode,\n      bytes,\n      rawBytes,\n      _fullType,\n      error,\n      underlyingResult,\n      _error,\n      numeric,\n      _error2,\n      _error3,\n      _error4,\n      _error5,\n      _error6,\n      fullType,\n      contractValueInfo,\n      coercedDataType,\n      _error7,\n      _error8,\n      address,\n      selector,\n      _error9,\n      deployedPc,\n      constructorPc,\n      _numeric,\n      _fullType2,\n      _error10,\n      numOptions,\n      numBytes,\n      paddingType,\n      _error11,\n      name,\n      _error12,\n      _error13,\n      asBN,\n      rawAsBN,\n      asBig,\n      rawAsBig,\n      _error14,\n      _asBN,\n      _rawAsBN,\n      _asBig,\n      _rawAsBig,\n      _args = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeBasic$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n          state = info.state;\n          strict = options.strictAbiMode; //if this is undefined it'll still be falsy so it's OK\n\n          paddingMode = options.paddingMode || \"default\";\n          _context.prev = 4;\n          return _context.delegateYield(read_1.default(pointer, state), \"t0\", 6);\n\n        case 6:\n          bytes = _context.t0;\n          _context.next = 13;\n          break;\n\n        case 9:\n          _context.prev = 9;\n          _context.t1 = _context[\"catch\"](4);\n          debug(\"segfault, pointer %o, state: %O\", pointer, state);\n          return _context.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context.t1, strict));\n\n        case 13:\n          rawBytes = bytes;\n          debug(\"type %O\", dataType);\n          debug(\"pointer %o\", pointer);\n          _context.t2 = dataType.typeClass;\n          _context.next = _context.t2 === \"userDefinedValueType\" ? 19 : _context.t2 === \"bool\" ? 33 : _context.t2 === \"uint\" ? 52 : _context.t2 === \"int\" ? 59 : _context.t2 === \"address\" ? 66 : _context.t2 === \"contract\" ? 73 : _context.t2 === \"bytes\" ? 83 : _context.t2 === \"function\" ? 91 : _context.t2 === \"enum\" ? 116 : _context.t2 === \"fixed\" ? 142 : _context.t2 === \"ufixed\" ? 153 : 164;\n          break;\n\n        case 19:\n          _fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n          if (_fullType.underlyingType) {\n            _context.next = 25;\n            break;\n          }\n\n          error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: _fullType\n          };\n\n          if (!(strict || options.allowRetry)) {\n            _context.next = 24;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error, true);\n\n        case 24:\n          return _context.abrupt(\"return\", {\n            type: _fullType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 25:\n          return _context.delegateYield(decodeBasic(_fullType.underlyingType, pointer, info, options), \"t3\", 26);\n\n        case 26:\n          underlyingResult = _context.t3;\n          _context.t4 = underlyingResult.kind;\n          _context.next = _context.t4 === \"value\" ? 30 : _context.t4 === \"error\" ? 31 : 32 //yes this switch is a little unnecessary :P\n          ;\n          break;\n\n        case 30:\n          return _context.abrupt(\"return\", {\n            //no idea why need coercion here\n            type: _fullType,\n            kind: \"value\",\n            value: underlyingResult\n          });\n\n        case 31:\n          return _context.abrupt(\"return\", {\n            //TS is being bad again :-/\n            type: _fullType,\n            kind: \"error\",\n            error: {\n              kind: \"WrappedError\",\n              error: underlyingResult\n            }\n          });\n\n        case 32:\n          return _context.abrupt(\"break\", 164);\n\n        case 33:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 38;\n            break;\n          }\n\n          _error = {\n            kind: \"BoolPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 37;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error);\n\n        case 37:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error\n          });\n\n        case 38:\n          bytes = removePadding(bytes, dataType, paddingMode); //note: the use of the BN is a little silly here,\n          //but, kind of stuck with it for now\n\n          numeric = Conversion.toBN(bytes);\n\n          if (!numeric.eqn(0)) {\n            _context.next = 44;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: false\n            }\n          });\n\n        case 44:\n          if (!numeric.eqn(1)) {\n            _context.next = 48;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          });\n\n        case 48:\n          _error2 = {\n            kind: \"BoolOutOfRangeError\",\n            rawAsBN: numeric\n          };\n\n          if (!strict) {\n            _context.next = 51;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error2);\n\n        case 51:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error2\n          });\n\n        case 52:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 57;\n            break;\n          }\n\n          _error3 = {\n            kind: \"UintPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 56;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error3);\n\n        case 56:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error3\n          });\n\n        case 57:\n          //now, truncate to appropriate length\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBN: Conversion.toBN(bytes),\n              rawAsBN: Conversion.toBN(rawBytes)\n            }\n          });\n\n        case 59:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 64;\n            break;\n          }\n\n          _error4 = {\n            kind: \"IntPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 63;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error4);\n\n        case 63:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error4\n          });\n\n        case 64:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBN: Conversion.toSignedBN(bytes),\n              rawAsBN: Conversion.toSignedBN(rawBytes)\n            }\n          });\n\n        case 66:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 71;\n            break;\n          }\n\n          _error5 = {\n            kind: \"AddressPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 70;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error5);\n\n        case 70:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error5\n          });\n\n        case 71:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asAddress: Evm.Utils.toAddress(bytes),\n              rawAsHex: Conversion.toHexString(rawBytes)\n            }\n          });\n\n        case 73:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 78;\n            break;\n          }\n\n          _error6 = {\n            kind: \"ContractPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 77;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error6);\n\n        case 77:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error6\n          });\n\n        case 78:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n          return _context.delegateYield(decodeContract(bytes, info), \"t5\", 81);\n\n        case 81:\n          contractValueInfo = _context.t5;\n          return _context.abrupt(\"return\", {\n            type: fullType,\n            kind: \"value\",\n            value: contractValueInfo\n          });\n\n        case 83:\n          //NOTE: we assume this is a *static* bytestring,\n          //because this is decodeBasic! dynamic ones should\n          //go to decodeBytes!\n          coercedDataType = dataType; //first, check padding (if needed)\n\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 89;\n            break;\n          }\n\n          _error7 = {\n            kind: \"BytesPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 88;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error7);\n\n        case 88:\n          return _context.abrupt(\"return\", {\n            type: coercedDataType,\n            kind: \"error\",\n            error: _error7\n          });\n\n        case 89:\n          //now, truncate to appropriate length\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: coercedDataType,\n            kind: \"value\",\n            value: {\n              asHex: Conversion.toHexString(bytes),\n              rawAsHex: Conversion.toHexString(rawBytes)\n            }\n          });\n\n        case 91:\n          _context.t6 = dataType.visibility;\n          _context.next = _context.t6 === \"external\" ? 94 : _context.t6 === \"internal\" ? 106 : 115;\n          break;\n\n        case 94:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 99;\n            break;\n          }\n\n          _error8 = {\n            kind: \"FunctionExternalNonStackPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 98;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error8);\n\n        case 98:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error8\n          });\n\n        case 99:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n          selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n          _context.t7 = dataType;\n          return _context.delegateYield(decodeExternalFunction(address, selector, info), \"t8\", 104);\n\n        case 104:\n          _context.t9 = _context.t8;\n          return _context.abrupt(\"return\", {\n            type: _context.t7,\n            kind: \"value\",\n            value: _context.t9\n          });\n\n        case 106:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 111;\n            break;\n          }\n\n          _error9 = {\n            kind: \"FunctionInternalPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 110;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error9);\n\n        case 110:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error9\n          });\n\n        case 111:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n          constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n          return _context.abrupt(\"return\", decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict));\n\n        case 115:\n          return _context.abrupt(\"break\", 164);\n\n        case 116:\n          _numeric = Conversion.toBN(bytes);\n          _fullType2 = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n          if (_fullType2.options) {\n            _context.next = 123;\n            break;\n          }\n\n          _error10 = {\n            kind: \"EnumNotFoundDecodingError\",\n            type: _fullType2,\n            rawAsBN: _numeric\n          };\n\n          if (!(strict || options.allowRetry)) {\n            _context.next = 122;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error10, true);\n\n        case 122:\n          return _context.abrupt(\"return\", {\n            type: _fullType2,\n            kind: \"error\",\n            error: _error10\n          });\n\n        case 123:\n          //note: I'm doing the padding checks a little more manually on this one\n          //so that we can have the right type of error\n          numOptions = _fullType2.options.length;\n          numBytes = Math.ceil(Math.log2(numOptions) / 8);\n          paddingType = getPaddingType(dataType, paddingMode);\n\n          if (checkPaddingDirect(bytes, numBytes, paddingType)) {\n            _context.next = 131;\n            break;\n          }\n\n          _error11 = {\n            kind: \"EnumPaddingError\",\n            type: _fullType2,\n            paddingType: paddingType,\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 130;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error11);\n\n        case 130:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error11\n          });\n\n        case 131:\n          bytes = removePaddingDirect(bytes, numBytes, paddingType);\n          _numeric = Conversion.toBN(bytes); //alter numeric!\n\n          if (!_numeric.ltn(numOptions)) {\n            _context.next = 138;\n            break;\n          }\n\n          name = _fullType2.options[_numeric.toNumber()]; //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n          //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n          //an enum with that many options in the first place, we have bigger problems!\n\n          return _context.abrupt(\"return\", {\n            type: _fullType2,\n            kind: \"value\",\n            value: {\n              name: name,\n              numericAsBN: _numeric\n            }\n          });\n\n        case 138:\n          _error12 = {\n            kind: \"EnumOutOfRangeError\",\n            type: _fullType2,\n            rawAsBN: _numeric\n          };\n\n          if (!strict) {\n            _context.next = 141;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error12);\n\n        case 141:\n          return _context.abrupt(\"return\", {\n            type: _fullType2,\n            kind: \"error\",\n            error: _error12\n          });\n\n        case 142:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 147;\n            break;\n          }\n\n          _error13 = {\n            kind: \"FixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 146;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error13);\n\n        case 146:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error13\n          });\n\n        case 147:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          asBN = Conversion.toSignedBN(bytes);\n          rawAsBN = Conversion.toSignedBN(rawBytes);\n          asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n          rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig: asBig,\n              rawAsBig: rawAsBig\n            }\n          });\n\n        case 153:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 158;\n            break;\n          }\n\n          _error14 = {\n            kind: \"UfixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 157;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error14);\n\n        case 157:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error14\n          });\n\n        case 158:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          _asBN = Conversion.toBN(bytes);\n          _rawAsBN = Conversion.toBN(rawBytes);\n          _asBig = Conversion.shiftBigDown(Conversion.toBig(_asBN), dataType.places);\n          _rawAsBig = Conversion.shiftBigDown(Conversion.toBig(_rawAsBN), dataType.places);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig: _asBig,\n              rawAsBig: _rawAsBig\n            }\n          });\n\n        case 164:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[4, 9]]);\n}\n\nexports.decodeBasic = decodeBasic; //NOTE that this function returns a ContractValueInfo, not a ContractResult\n\nfunction decodeContract(addressBytes, info) {\n  return _regeneratorRuntime.wrap(function decodeContract$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.delegateYield(decodeContractAndContext(addressBytes, info), \"t0\", 1);\n\n        case 1:\n          return _context2.abrupt(\"return\", _context2.t0.contractInfo);\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nexports.decodeContract = decodeContract;\n\nfunction decodeContractAndContext(addressBytes, info) {\n  var address, rawAddress, codeBytes, code, context;\n  return _regeneratorRuntime.wrap(function decodeContractAndContext$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          address = Evm.Utils.toAddress(addressBytes);\n          rawAddress = Conversion.toHexString(addressBytes);\n          _context3.next = 4;\n          return {\n            type: \"code\",\n            address: address\n          };\n\n        case 4:\n          codeBytes = _context3.sent;\n          code = Conversion.toHexString(codeBytes);\n          context = Contexts.Utils.findContext(info.contexts, code);\n\n          if (!(context !== null)) {\n            _context3.next = 11;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            context: context,\n            contractInfo: {\n              kind: \"known\",\n              address: address,\n              rawAddress: rawAddress,\n              class: Contexts.Import.contextToType(context)\n            }\n          });\n\n        case 11:\n          return _context3.abrupt(\"return\", {\n            context: context,\n            contractInfo: {\n              kind: \"unknown\",\n              address: address,\n              rawAddress: rawAddress\n            }\n          });\n\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n} //note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\n\n\nfunction decodeExternalFunction(addressBytes, selectorBytes, info) {\n  var _yield$decodeContract, contract, context, selector, abiEntry;\n\n  return _regeneratorRuntime.wrap(function decodeExternalFunction$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.delegateYield(decodeContractAndContext(addressBytes, info), \"t0\", 1);\n\n        case 1:\n          _yield$decodeContract = _context4.t0;\n          contract = _yield$decodeContract.contractInfo;\n          context = _yield$decodeContract.context;\n          selector = Conversion.toHexString(selectorBytes);\n\n          if (!(contract.kind === \"unknown\")) {\n            _context4.next = 7;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", {\n            kind: \"unknown\",\n            contract: contract,\n            selector: selector\n          });\n\n        case 7:\n          abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n\n          if (!(abiEntry === undefined)) {\n            _context4.next = 10;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", {\n            kind: \"invalid\",\n            contract: contract,\n            selector: selector\n          });\n\n        case 10:\n          return _context4.abrupt(\"return\", {\n            kind: \"known\",\n            contract: contract,\n            selector: selector,\n            abi: abiEntry\n          });\n\n        case 11:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}\n\nexports.decodeExternalFunction = decodeExternalFunction; //this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {\n  var deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  var constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  var context = Contexts.Import.contextToType(info.currentContext); //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //also before we continue: is the PC zero? if so let's just return that\n\n\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //another check: is only the deployed PC zero?\n\n\n  if (deployedPc === 0 && constructorPc !== 0) {\n    var error = {\n      kind: \"MalformedInternalFunctionError\",\n      context: context,\n      deployedProgramCounter: 0,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: error\n    };\n  } //one last pre-check: is this a deployed-format pointer in a constructor?\n\n\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    var _error15 = {\n      kind: \"DeployedFunctionInConstructorError\",\n      context: context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: 0\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(_error15);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: _error15\n    };\n  } //otherwise, we get our function\n\n\n  var pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  var functionEntry = info.internalFunctionsTable[pc];\n\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    var _error16 = {\n      kind: \"NoSuchInternalFunctionError\",\n      context: context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(_error16);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: _error16\n    };\n  }\n\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  var name = functionEntry.name;\n  var mutability = functionEntry.mutability;\n  var definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n\n  var id = Evm.Import.makeInternalFunctionId(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context: context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name: name,\n      id: id,\n      definedIn: definedIn,\n      mutability: mutability\n    }\n  };\n}\n\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  var length = allocate_1.byteLength(dataType, userDefinedTypes);\n  var paddingType = getPaddingType(dataType, paddingMode);\n\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\n\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  var length = allocate_1.byteLength(dataType, userDefinedTypes);\n  var paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\n\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"right\":\n      return bytes.slice(0, length);\n\n    default:\n      return bytes.slice(-length);\n  }\n}\n\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n\n    case \"signedOrLeft\":\n      return checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length);\n  }\n}\n\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n\n    case \"zero\":\n      {\n        var defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"left\" : defaultType;\n      }\n\n    case \"defaultOrZero\":\n      {\n        var _defaultType = defaultPaddingType(dataType);\n\n        return _defaultType === \"signed\" ? \"signedOrLeft\" : _defaultType;\n      }\n  }\n}\n\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n\n    //otherwise, fall through to default\n\n    default:\n      return \"left\";\n  }\n}\n\nfunction checkPaddingRight(bytes, length) {\n  var padding = bytes.slice(length); //cut off the first length bytes\n\n  return padding.every(function (paddingByte) {\n    return paddingByte === 0;\n  });\n} //exporting this one for use in stack.ts\n\n\nfunction checkPaddingLeft(bytes, length) {\n  var padding = bytes.slice(0, -length); //cut off the last length bytes\n\n  return padding.every(function (paddingByte) {\n    return paddingByte === 0;\n  });\n}\n\nexports.checkPaddingLeft = checkPaddingLeft;\n\nfunction checkPaddingSigned(bytes, length) {\n  var padding = bytes.slice(0, -length); //padding is all but the last length bytes\n\n  var value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n\n  var signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(function (paddingByte) {\n    return paddingByte === signByte;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}