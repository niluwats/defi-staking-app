{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeContext = exports.normalizeContexts = exports.matchContext = exports.findContext = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:contexts:utils\");\n\nvar Evm = __importStar(require(\"../evm\"));\n\nvar Conversion = __importStar(require(\"../conversion\"));\n\nvar lodash_escaperegexp_1 = __importDefault(require(\"lodash.escaperegexp\"));\n\nvar cbor = __importStar(require(\"cbor\"));\n\nvar compile_common_1 = require(\"@truffle/compile-common\");\n\nvar Abi = __importStar(require(\"@truffle/abi-utils\"));\n\nvar AbiDataUtils = __importStar(require(\"../abi-data/utils\"));\n\nfunction findContext(contexts, binary) {\n  var matchingContexts = Object.values(contexts).filter(function (context) {\n    return matchContext(context, binary);\n  }); //rather than just pick an arbitrary matching context, we're going\n  //to pick one that isn't a descendant of any of the others.\n  //(if there are multiple of *those*, then yeah it's arbitrary.)\n\n  var context = matchingContexts.find(function (descendant) {\n    return !matchingContexts.some(function (ancestor) {\n      return descendant.compilationId === ancestor.compilationId && descendant.linearizedBaseContracts && ancestor.contractId !== undefined && descendant.linearizedBaseContracts.slice(1).includes(ancestor.contractId);\n    } //we do slice one because everything is an an ancestor of itself; we only\n    //care about *proper* ancestors\n    );\n  });\n  return context || null;\n}\n\nexports.findContext = findContext;\n\nfunction matchContext(context, givenBinary) {\n  var binary = context.binary,\n      compiler = context.compiler,\n      isConstructor = context.isConstructor;\n  var lengthDifference = givenBinary.length - binary.length; //first: if it's not a constructor, and it's not Vyper,\n  //they'd better be equal in length.\n  //if it is a constructor, or is Vyper,\n  //the given binary must be at least as long,\n  //and the difference must be a multiple of 32 bytes (64 hex digits)\n\n  var additionalAllowed = isConstructor || compiler != undefined && compiler.name === \"vyper\";\n\n  if (!additionalAllowed && lengthDifference !== 0 || lengthDifference < 0 || lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {\n    return false;\n  }\n\n  for (var i = 0; i < binary.length; i++) {\n    //note: using strings like arrays is kind of dangerous in general in JS,\n    //but everything here is ASCII so it's fine\n    //note that we need to compare case-insensitive, since Solidity will\n    //put addresses in checksum case in the compiled source\n    //(we don't actually need that second toLowerCase(), but whatever)\n    if (binary[i] !== \".\" && binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.matchContext = matchContext;\n\nfunction normalizeContexts(contexts) {\n  //unfortunately, due to our current link references format, we can't\n  //really use the binary from the artifact directly -- neither for purposes\n  //of matching, nor for purposes of decoding internal functions.  So, we\n  //need to perform this normalization step on our contexts before using\n  //them.  Once we have truffle-db, this step should largely go away.\n  debug(\"normalizing contexts\"); //first, let's clone the input\n  //(let's do a 2-deep clone because we'll be altering binary & compiler)\n\n  var newContexts = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(contexts).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        contextHash = _ref2[0],\n        context = _ref2[1];\n\n    return _defineProperty({}, contextHash, Object.assign({}, context));\n  }))));\n  debug(\"contexts cloned\"); //next, we get all the library names and sort them descending by length.\n  //We're going to want to go in descending order of length so that we\n  //don't run into problems when one name is a substring of another.\n  //For simplicity, we'll exclude names of length <38, because we can\n  //handle these with our more general check for link references at the end\n\n  var fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;\n  var names = Object.values(newContexts).filter(function (context) {\n    return context.contractKind === \"library\";\n  }).map(function (context) {\n    return context.contractName;\n  }).filter(function (name) {\n    return name.length >= fillerLength - 3;\n  }) //the -3 is for 2 leading underscores and 1 trailing\n  .sort(function (name1, name2) {\n    return name2.length - name1.length;\n  });\n  debug(\"names sorted\"); //now, we need to turn all these names into regular expressions, because,\n  //unfortunately, str.replace() will only replace all if you use a /g regexp;\n  //note that because names may contain '$', we need to escape them\n  //(also we prepend \"__\" because that's the placeholder format)\n\n  var regexps = names.map(function (name) {\n    return new RegExp(lodash_escaperegexp_1.default(\"__\" + name), \"g\");\n  });\n  debug(\"regexps prepared\"); //having done so, we can do the replace for these names!\n\n  var replacement = \".\".repeat(fillerLength);\n\n  var _iterator = _createForOfIteratorHelper(regexps),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var regexp = _step.value;\n\n      for (var _i8 = 0, _Object$values6 = Object.values(newContexts); _i8 < _Object$values6.length; _i8++) {\n        var _context6 = _Object$values6[_i8];\n        _context6.binary = _context6.binary.replace(regexp, replacement);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  debug(\"long replacements complete\"); //now we can do a generic replace that will catch all names of length\n  //<40, while also catching the Solidity compiler's link reference format\n  //as well as Truffle's.  Hooray!\n\n  var genericRegexp = new RegExp(\"_.{\" + (fillerLength - 2) + \"}_\", \"g\"); //we're constructing the regexp /_.{38}_/g, but I didn't want to use a\n  //literal 38 :P\n\n  for (var _i = 0, _Object$values = Object.values(newContexts); _i < _Object$values.length; _i++) {\n    var context = _Object$values[_i];\n    context.binary = context.binary.replace(genericRegexp, replacement);\n  }\n\n  debug(\"short replacements complete\"); //now we must handle the delegatecall guard -- libraries' deployedBytecode will include\n  //0s in place of their own address instead of a link reference at the\n  //beginning, so we need to account for that too\n\n  var pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n  for (var _i2 = 0, _Object$values2 = Object.values(newContexts); _i2 < _Object$values2.length; _i2++) {\n    var _context = _Object$values2[_i2];\n\n    if (_context.contractKind === \"library\" && !_context.isConstructor) {\n      _context.binary = _context.binary.replace(\"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE), \"0x\" + pushAddressInstruction + replacement);\n    }\n  }\n\n  debug(\"extra library replacements complete\"); //now let's handle immutable references\n  //(these are much nicer than link references due to not having to deal with the old format)\n\n  for (var _i3 = 0, _Object$values3 = Object.values(newContexts); _i3 < _Object$values3.length; _i3++) {\n    var _context2 = _Object$values3[_i3];\n\n    if (_context2.immutableReferences) {\n      for (var _i4 = 0, _Object$values4 = Object.values(_context2.immutableReferences); _i4 < _Object$values4.length; _i4++) {\n        var variable = _Object$values4[_i4];\n\n        var _iterator2 = _createForOfIteratorHelper(variable),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _step2.value,\n                start = _step2$value.start,\n                length = _step2$value.length;\n            //Goddammit TS\n            var lowerStringIndex = 2 + 2 * start;\n            var upperStringIndex = 2 + 2 * (start + length);\n            _context2.binary = _context2.binary.slice(0, lowerStringIndex) + \"..\".repeat(length) + _context2.binary.slice(upperStringIndex);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }\n\n  debug(\"immutables complete\"); //now: extract & decode all the cbor's.  we're going to use these for\n  //two different purposes, so let's just get them all upfront.\n\n  var cborInfos = {};\n  var decodedCbors = {}; //note: invalid cbor will be indicated in decodedCbors by the lack of an entry,\n  //*not* by undefined or null, since there exists cbor for those :P\n\n  for (var _i5 = 0, _Object$entries = Object.entries(newContexts); _i5 < _Object$entries.length; _i5++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),\n        contextHash = _Object$entries$_i[0],\n        _context3 = _Object$entries$_i[1];\n\n    var cborInfo = extractCborInfo(_context3.binary);\n    cborInfos[contextHash] = cborInfo;\n\n    if (cborInfo) {\n      try {\n        //note this *will* throw if there's data left over,\n        //which is what we want it to do\n        var decoded = cbor.decodeFirstSync(cborInfo.cbor);\n        decodedCbors[contextHash] = decoded;\n      } catch (_a) {//just don't add it\n      }\n    }\n  }\n\n  debug(\"intial cbor processing complete\"); //now: if a context lacks a compiler, but a version can be found in the\n  //cbor, add it.\n\n  for (var _i6 = 0, _Object$entries2 = Object.entries(newContexts); _i6 < _Object$entries2.length; _i6++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i6], 2),\n        _contextHash2 = _Object$entries2$_i[0],\n        _context4 = _Object$entries2$_i[1];\n\n    if (!_context4.compiler && _contextHash2 in decodedCbors) {\n      _context4.compiler = detectCompilerInfo(decodedCbors[_contextHash2]);\n    }\n  }\n\n  debug(\"versions complete\"); //one last step: where there's CBOR with a metadata hash, we'll allow the\n  //CBOR to vary, aside from the length (note: ideally here we would *only*\n  //dot-out the metadata hash part of the CBOR, but, well, it's not worth the\n  //trouble to detect that; doing that could potentially get pretty involved)\n  //note that if the code isn't Solidity, that's fine -- we just won't get\n  //valid CBOR and will not end up adding to our list of regular expressions\n\n  var externalCborInfos = Object.entries(cborInfos).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        contextHash = _ref5[0],\n        _cborInfo = _ref5[1];\n\n    return contextHash in decodedCbors && isObjectWithHash(decodedCbors[contextHash]);\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        _contextHash = _ref7[0],\n        cborInfo = _ref7[1];\n\n    return cborInfo;\n  });\n  var cborRegexps = externalCborInfos.map(function (cborInfo) {\n    return {\n      input: new RegExp(cborInfo.cborSegment, \"g\"),\n      output: \"..\".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex\n    };\n  }); //HACK: we will replace *every* occurrence of *every* external CBOR occurring\n  //in *every* context, in order to cover created contracts (including if there\n  //are multiple or recursive ones)\n\n  for (var _i7 = 0, _Object$values5 = Object.values(newContexts); _i7 < _Object$values5.length; _i7++) {\n    var _context5 = _Object$values5[_i7];\n\n    var _iterator3 = _createForOfIteratorHelper(cborRegexps),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _step3.value,\n            input = _step3$value.input,\n            output = _step3$value.output;\n        _context5.binary = _context5.binary.replace(input, output);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  debug(\"external wildcards complete\"); //finally, return this mess!\n\n  return newContexts;\n}\n\nexports.normalizeContexts = normalizeContexts;\n\nfunction extractCborInfo(binary) {\n  debug(\"extracting cbor segement of %s\", binary);\n  var lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex\n  //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract\n  //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be\n  //certain)\n\n  if (lastTwoBytes.length < 2 * 2) {\n    return null; //don't try to handle this case!\n  }\n\n  var cborLength = parseInt(lastTwoBytes, 16);\n  var cborEnd = binary.length - 2 * 2;\n  var cborStart = cborEnd - cborLength * 2; //sanity check\n\n  if (cborStart < 2) {\n    //\"0x\"\n    return null; //don't try to handle this case!\n  }\n\n  var cbor = binary.slice(cborStart, cborEnd);\n  return {\n    cborStart: cborStart,\n    cborLength: cborLength,\n    cborEnd: cborEnd,\n    cborLengthHex: lastTwoBytes,\n    cbor: cbor,\n    cborSegment: cbor + lastTwoBytes\n  };\n}\n\nfunction isObjectWithHash(decoded) {\n  if (typeof decoded !== \"object\" || decoded === null) {\n    return false;\n  } //cbor sometimes returns maps and sometimes objects,\n  //so let's make things consistent by converting to a map\n  //(actually, is this true? borc did this, I think cbor\n  //does too, but I haven't checked recently)\n\n\n  if (!(decoded instanceof Map)) {\n    decoded = new Map(Object.entries(decoded));\n  }\n\n  var hashKeys = [\"bzzr0\", \"bzzr1\", \"ipfs\"];\n  return hashKeys.some(function (key) {\n    return decoded.has(key);\n  });\n} //returns undefined if no valid compiler info detected\n//(if it detects solc but no version, it will not return\n//a partial result, just undefined)\n\n\nfunction detectCompilerInfo(decoded) {\n  if (typeof decoded !== \"object\" || decoded === null) {\n    return undefined;\n  } //cbor sometimes returns maps and sometimes objects,\n  //so let's make things consistent by converting to a map\n  //(although see note above?)\n\n\n  if (!(decoded instanceof Map)) {\n    decoded = new Map(Object.entries(decoded));\n  }\n\n  if (!decoded.has(\"solc\")) {\n    //return undefined if the solc version field is not present\n    //(this occurs if version <0.5.9)\n    //currently no other language attaches cbor info, so, yeah\n    return undefined;\n  }\n\n  var rawVersion = decoded.get(\"solc\");\n\n  if (typeof rawVersion === \"string\") {\n    //for prerelease versions, the version is stored as a string.\n    return {\n      name: \"solc\",\n      version: rawVersion\n    };\n  } else if (rawVersion instanceof Uint8Array && rawVersion.length === 3) {\n    //for release versions, it's stored as a bytestring of length 3, with the\n    //bytes being major, minor, patch. so we just join them with \".\" to form\n    //a version string (although it's missing precise commit & etc).\n    return {\n      name: \"solc\",\n      version: rawVersion.join(\".\")\n    };\n  } else {\n    //return undefined on anything else\n    return undefined;\n  }\n}\n\nfunction makeContext(contract, node, compilation) {\n  var isConstructor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var abi = Abi.normalize(contract.abi);\n  var bytecode = isConstructor ? contract.bytecode : contract.deployedBytecode;\n  var binary = compile_common_1.Shims.NewToLegacy.forBytecode(bytecode);\n  var hash = Conversion.toHexString(Evm.Utils.keccak256({\n    type: \"string\",\n    value: binary\n  }));\n  debug(\"hash: %s\", hash);\n  var fallback = abi.find(function (abiEntry) {\n    return abiEntry.type === \"fallback\";\n  }) || null; //TS is failing at inference here\n\n  var receive = abi.find(function (abiEntry) {\n    return abiEntry.type === \"receive\";\n  }) || null; //and here\n\n  return {\n    context: hash,\n    contractName: contract.contractName,\n    binary: binary,\n    contractId: node ? node.id : undefined,\n    linearizedBaseContracts: node ? node.linearizedBaseContracts : undefined,\n    contractKind: contractKind(contract, node),\n    immutableReferences: isConstructor ? undefined : contract.immutableReferences,\n    isConstructor: isConstructor,\n    abi: AbiDataUtils.computeSelectors(abi),\n    payable: AbiDataUtils.abiHasPayableFallback(abi),\n    fallbackAbi: {\n      fallback: fallback,\n      receive: receive\n    },\n    compiler: compilation.compiler || contract.compiler,\n    compilationId: compilation.id\n  };\n}\n\nexports.makeContext = makeContext; //attempts to determine if the given contract is a library or not\n\nfunction contractKind(contract, node) {\n  //first: if we have a node, use its listed contract kind\n  if (node) {\n    return node.contractKind;\n  } //next: check the contract kind field on the contract object itself, if it exists.\n  //however this isn't implemented yet so we'll skip it.\n  //next: if we have no direct info on the contract kind, but we do\n  //have the deployed bytecode, we'll use a HACK:\n  //we'll assume it's an ordinary contract, UNLESS its deployed bytecode begins with\n  //PUSH20 followed by 20 0s, in which case we'll assume it's a library\n  //(note: this will fail to detect libraries from before Solidity 0.4.20)\n\n\n  if (contract.deployedBytecode) {\n    var deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n    var pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n    var libraryString = \"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE);\n    return deployedBytecode.startsWith(libraryString) ? \"library\" : \"contract\";\n  } //finally, in the absence of anything to go on, we'll assume it's an ordinary contract\n\n\n  return \"contract\";\n}","map":null,"metadata":{},"sourceType":"script"}