{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tie = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:format:utils:circularity\");\n\nfunction tie(untied) {\n  return tieWithTable(untied, []);\n}\n\nexports.tie = tie;\n\nfunction tieWithTable(untied, seenSoFar) {\n  if (untied.kind === \"error\") {\n    return untied;\n  }\n\n  var reference;\n\n  switch (untied.type.typeClass) {\n    case \"array\":\n      var untiedAsArray = untied; //dammit TS\n\n      reference = untiedAsArray.reference;\n\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        var _tied = Object.assign(Object.assign({}, untiedAsArray), {\n          value: _toConsumableArray(untiedAsArray.value)\n        }); //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n\n\n        for (var index in _tied.value) {\n          _tied.value[index] = tieWithTable(_tied.value[index], [_tied].concat(_toConsumableArray(seenSoFar)));\n        }\n\n        return _tied;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference: reference\n        });\n      }\n\n    case \"struct\":\n      var untiedAsStruct = untied; //dammit TS\n\n      reference = untiedAsStruct.reference;\n\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        var _tied2 = Object.assign(Object.assign({}, untiedAsStruct), {\n          value: untiedAsStruct.value.map(function (component) {\n            return Object.assign({}, component);\n          })\n        }); //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n\n\n        for (var _index in _tied2.value) {\n          _tied2.value[_index] = Object.assign(Object.assign({}, _tied2.value[_index]), {\n            value: tieWithTable(_tied2.value[_index].value, [_tied2].concat(_toConsumableArray(seenSoFar)))\n          });\n        }\n\n        return _tied2;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference: reference\n        });\n      }\n\n    case \"tuple\":\n      //currently there are no memory tuples, but may as well\n      //can't be circular, just recurse\n      //note we can just recurse with a straight tie here; don't need tieWithTable\n      var untiedAsTuple = untied; //dammit TS\n      //we need to do some pointer stuff here, so let's first create our new\n      //object we'll be pointing to\n\n      var tied = Object.assign({}, untiedAsTuple);\n      tied.value = tied.value.map(function (component) {\n        return Object.assign(Object.assign({}, component), {\n          value: tie(component.value)\n        });\n      });\n      return tied;\n\n    default:\n      //other types either:\n      //1. aren't containers and so need no recursion\n      //2. are containers but can't go in or contain memory things\n      //and so still need no recursion\n      //(or, in the case of mappings, can't contain *nontrivial* memory\n      //things)\n      return untied;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}