{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar stream = require('stream');\n\nvar url = require('url');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar NoFilter = require('nofilter');\n\nvar Tagged = require('./tagged');\n\nvar Simple = require('./simple');\n\nvar utils = require('./utils');\n\nvar constants = require('./constants');\n\nvar MT = constants.MT;\nvar NUMBYTES = constants.NUMBYTES;\nvar SHIFT32 = constants.SHIFT32;\nvar SYMS = constants.SYMS;\nvar TAG = constants.TAG;\nvar HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;\nvar FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;\nvar DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;\nvar TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;\nvar FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;\nvar UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;\nvar NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;\nvar BREAK = Buffer.from([0xff]);\nvar BI = utils.bigIntize(constants.BI);\nvar BN = constants.BN;\nvar BUF_NAN = Buffer.from('f97e00', 'hex');\nvar BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nvar BUF_INF_POS = Buffer.from('f97c00', 'hex');\nvar BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\nvar LOOP_DETECT = Symbol('CBOR_LOOP_DETECT');\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\n\nvar Encoder = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(Encoder, _stream$Transform);\n\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the\n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   * @param {boolean} [options.collapseBigIntegers=false] - Should integers\n   *   that come in as BigNumber integers and ECMAscript bigint's be encoded\n   *   as normal CBOR integers if they fit, discarding type information?\n   */\n  function Encoder(options) {\n    var _this;\n\n    _classCallCheck(this, Encoder);\n\n    var opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    });\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Encoder).call(this, opts));\n    _this.canonical = opts.canonical;\n    _this.encodeUndefined = opts.encodeUndefined;\n    _this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys;\n    _this.dateType = opts.dateType != null ? opts.dateType.toLowerCase() : 'number';\n    _this.collapseBigIntegers = !!opts.collapseBigIntegers; // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n\n    if (typeof opts.detectLoops === 'symbol') {\n      _this.detectLoops = opts.detectLoops;\n    } else {\n      _this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null;\n    }\n\n    _this.semanticTypes = {\n      Array: _this._pushArray,\n      Date: _this._pushDate,\n      Buffer: _this._pushBuffer,\n      Map: _this._pushMap,\n      NoFilter: _this._pushNoFilter,\n      RegExp: _this._pushRegexp,\n      Set: _this._pushSet,\n      BigNumber: _this._pushBigNumber,\n      ArrayBuffer: _this._pushUint8Array,\n      Uint8ClampedArray: _this._pushUint8Array,\n      Uint8Array: _this._pushUint8Array,\n      Uint16Array: _this._pushArray,\n      Uint32Array: _this._pushArray,\n      Int8Array: _this._pushArray,\n      Int16Array: _this._pushArray,\n      Int32Array: _this._pushArray,\n      Float32Array: _this._pushFloat32Array,\n      Float64Array: _this._pushFloat64Array\n    }; // tsc doesn't know about old Url\n\n    if (url['Url']) {\n      _this.addSemanticType('Url', _this._pushUrl);\n    }\n\n    if (url['URL']) {\n      _this.addSemanticType('URL', _this._pushURL);\n    }\n\n    var addTypes = opts.genTypes || [];\n\n    for (var i = 0, len = addTypes.length; i < len; i += 2) {\n      _this.addSemanticType(addTypes[i], addTypes[i + 1]);\n    }\n\n    return _this;\n  }\n\n  _createClass(Encoder, [{\n    key: \"_transform\",\n    value: function _transform(fresh, encoding, cb) {\n      var ret = this.pushAny(fresh); // Old transformers might not return bool.  undefined !== false\n\n      return cb(ret === false ? new Error('Push Error') : undefined);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(cb) {\n      return cb();\n    }\n    /**\n     * @callback encodeFunction\n     * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n     *   on the encoder as needed.\n     * @return {bool} - true on success, else false\n     */\n\n    /**\n     * Add an encoding function to the list of supported semantic types.  This is\n     * useful for objects for which you can't add an encodeCBOR method\n     *\n     * @param {any} type\n     * @param {any} fun\n     * @returns {encodeFunction}\n     */\n\n  }, {\n    key: \"addSemanticType\",\n    value: function addSemanticType(type, fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function');\n      }\n\n      var typeName = typeof type === 'string' ? type : type.name;\n      var old = this.semanticTypes[typeName];\n      this.semanticTypes[typeName] = fun;\n      return old;\n    }\n  }, {\n    key: \"_pushUInt8\",\n    value: function _pushUInt8(val) {\n      var b = Buffer.allocUnsafe(1);\n      b.writeUInt8(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushUInt16BE\",\n    value: function _pushUInt16BE(val) {\n      var b = Buffer.allocUnsafe(2);\n      b.writeUInt16BE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushUInt32BE\",\n    value: function _pushUInt32BE(val) {\n      var b = Buffer.allocUnsafe(4);\n      b.writeUInt32BE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushFloatBE\",\n    value: function _pushFloatBE(val) {\n      var b = Buffer.allocUnsafe(4);\n      b.writeFloatBE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushDoubleBE\",\n    value: function _pushDoubleBE(val) {\n      var b = Buffer.allocUnsafe(8);\n      b.writeDoubleBE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushNaN\",\n    value: function _pushNaN() {\n      return this.push(BUF_NAN);\n    }\n  }, {\n    key: \"_pushInfinity\",\n    value: function _pushInfinity(obj) {\n      var half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n      return this.push(half);\n    }\n  }, {\n    key: \"_pushFloat\",\n    value: function _pushFloat(obj) {\n      if (this.canonical) {\n        // TODO: is this enough slower to hide behind canonical?\n        // It's certainly enough of a hack (see utils.parseHalf)\n        // From section 3.9:\n        // If a protocol allows for IEEE floats, then additional canonicalization\n        // rules might need to be added.  One example rule might be to have all\n        // floats start as a 64-bit float, then do a test conversion to a 32-bit\n        // float; if the result is the same numeric value, use the shorter value\n        // and repeat the process with a test conversion to a 16-bit float.  (This\n        // rule selects 16-bit float for positive and negative Infinity as well.)\n        // which seems pretty much backwards to me.\n        var b2 = Buffer.allocUnsafe(2);\n\n        if (utils.writeHalf(b2, obj)) {\n          // I have convinced myself that there are no cases where writeHalf\n          // will return true but `utils.parseHalf(b2) !== obj)`\n          return this._pushUInt8(HALF) && this.push(b2);\n        }\n      }\n\n      if (Math.fround(obj) === obj) {\n        return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n      }\n\n      return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n    }\n  }, {\n    key: \"_pushInt\",\n    value: function _pushInt(obj, mt, orig) {\n      var m = mt << 5;\n\n      switch (false) {\n        case !(obj < 24):\n          return this._pushUInt8(m | obj);\n\n        case !(obj <= 0xff):\n          return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n\n        case !(obj <= 0xffff):\n          return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n\n        case !(obj <= 0xffffffff):\n          return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n\n        case !(obj <= Number.MAX_SAFE_INTEGER):\n          return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n\n        default:\n          if (mt === MT.NEG_INT) {\n            return this._pushFloat(orig);\n          } else {\n            return this._pushFloat(obj);\n          }\n\n      }\n    }\n  }, {\n    key: \"_pushIntNum\",\n    value: function _pushIntNum(obj) {\n      if (Object.is(obj, -0)) {\n        return this.push(BUF_NEG_ZERO);\n      }\n\n      if (obj < 0) {\n        return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n      } else {\n        return this._pushInt(obj, MT.POS_INT);\n      }\n    }\n  }, {\n    key: \"_pushNumber\",\n    value: function _pushNumber(obj) {\n      switch (false) {\n        case !isNaN(obj):\n          return this._pushNaN();\n\n        case isFinite(obj):\n          return this._pushInfinity(obj);\n\n        case Math.round(obj) !== obj:\n          return this._pushIntNum(obj);\n\n        default:\n          return this._pushFloat(obj);\n      }\n    }\n  }, {\n    key: \"_pushString\",\n    value: function _pushString(obj) {\n      var len = Buffer.byteLength(obj, 'utf8');\n      return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n    }\n  }, {\n    key: \"_pushBoolean\",\n    value: function _pushBoolean(obj) {\n      return this._pushUInt8(obj ? TRUE : FALSE);\n    }\n  }, {\n    key: \"_pushUndefined\",\n    value: function _pushUndefined(obj) {\n      switch (typeof this.encodeUndefined) {\n        case 'undefined':\n          return this._pushUInt8(UNDEFINED);\n\n        case 'function':\n          return this.pushAny(this.encodeUndefined.call(this, obj));\n\n        case 'object':\n          if (Buffer.isBuffer(this.encodeUndefined)) {\n            return this.push(this.encodeUndefined);\n          }\n\n      }\n\n      return this.pushAny(this.encodeUndefined);\n    }\n  }, {\n    key: \"_pushNull\",\n    value: function _pushNull(obj) {\n      return this._pushUInt8(NULL);\n    }\n  }, {\n    key: \"_pushArray\",\n    value: function _pushArray(gen, obj, opts) {\n      opts = Object.assign({\n        indefinite: false\n      }, opts);\n      var len = obj.length;\n\n      if (opts.indefinite) {\n        if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {\n          return false;\n        }\n      } else if (!gen._pushInt(len, MT.ARRAY)) {\n        return false;\n      }\n\n      for (var j = 0; j < len; j++) {\n        if (!gen.pushAny(obj[j])) {\n          return false;\n        }\n      }\n\n      if (opts.indefinite) {\n        if (!gen.push(BREAK)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushTag\",\n    value: function _pushTag(tag) {\n      return this._pushInt(tag, MT.TAG);\n    }\n  }, {\n    key: \"_pushDate\",\n    value: function _pushDate(gen, obj) {\n      switch (gen.dateType) {\n        case 'string':\n          return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());\n\n        case 'int':\n        case 'integer':\n          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj / 1000));\n\n        case 'float':\n          // force float\n          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj / 1000);\n\n        case 'number':\n        default:\n          // if we happen to have an integral number of seconds,\n          // use integer.  Otherwise, use float.\n          return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1000);\n      }\n    }\n  }, {\n    key: \"_pushBuffer\",\n    value: function _pushBuffer(gen, obj) {\n      return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n    }\n  }, {\n    key: \"_pushNoFilter\",\n    value: function _pushNoFilter(gen, obj) {\n      return gen._pushBuffer(gen, obj.slice());\n    }\n  }, {\n    key: \"_pushRegexp\",\n    value: function _pushRegexp(gen, obj) {\n      return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n    }\n  }, {\n    key: \"_pushSet\",\n    value: function _pushSet(gen, obj) {\n      if (!gen._pushInt(obj.size, MT.ARRAY)) {\n        return false;\n      }\n\n      var _iterator = _createForOfIteratorHelper(obj),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var x = _step.value;\n\n          if (!gen.pushAny(x)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushUrl\",\n    value: function _pushUrl(gen, obj) {\n      return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());\n    }\n  }, {\n    key: \"_pushURL\",\n    value: function _pushURL(gen, obj) {\n      return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n    }\n    /**\n     * @param {bignumber} obj\n     * @private\n     */\n\n  }, {\n    key: \"_pushBigint\",\n    value: function _pushBigint(obj) {\n      var m = MT.POS_INT;\n      var tag = TAG.POS_BIGINT;\n\n      if (obj.isNegative()) {\n        obj = obj.negated().minus(1);\n        m = MT.NEG_INT;\n        tag = TAG.NEG_BIGINT;\n      }\n\n      if (this.collapseBigIntegers && obj.lte(BN.MAXINT64)) {\n        //  special handiling for 64bits\n        if (obj.lte(BN.MAXINT32)) {\n          return this._pushInt(obj.toNumber(), m);\n        }\n\n        return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) && this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber());\n      }\n\n      var str = obj.toString(16);\n\n      if (str.length % 2) {\n        str = '0' + str;\n      }\n\n      var buf = Buffer.from(str, 'hex');\n      return this._pushTag(tag) && this._pushBuffer(this, buf);\n    }\n    /**\n     * @param {bigint} obj\n     * @private\n     */\n\n  }, {\n    key: \"_pushJSBigint\",\n    value: function _pushJSBigint(obj) {\n      var m = MT.POS_INT;\n      var tag = TAG.POS_BIGINT; // BigInt doesn't have -0\n\n      if (obj < 0) {\n        obj = -obj + BI.MINUS_ONE;\n        m = MT.NEG_INT;\n        tag = TAG.NEG_BIGINT;\n      }\n\n      if (this.collapseBigIntegers && obj <= BI.MAXINT64) {\n        //  special handiling for 64bits\n        if (obj <= 0xffffffff) {\n          return this._pushInt(Number(obj), m);\n        }\n\n        return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));\n      }\n\n      var str = obj.toString(16);\n\n      if (str.length % 2) {\n        str = '0' + str;\n      }\n\n      var buf = Buffer.from(str, 'hex');\n      return this._pushTag(tag) && this._pushBuffer(this, buf);\n    }\n  }, {\n    key: \"_pushBigNumber\",\n    value: function _pushBigNumber(gen, obj) {\n      if (obj.isNaN()) {\n        return gen._pushNaN();\n      }\n\n      if (!obj.isFinite()) {\n        return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);\n      }\n\n      if (obj.isInteger()) {\n        return gen._pushBigint(obj);\n      }\n\n      if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {\n        return false;\n      }\n\n      var dec = obj.decimalPlaces();\n      var slide = obj.shiftedBy(dec);\n\n      if (!gen._pushIntNum(-dec)) {\n        return false;\n      }\n\n      if (slide.abs().isLessThan(BN.MAXINT)) {\n        return gen._pushIntNum(slide.toNumber());\n      } else {\n        return gen._pushBigint(slide);\n      }\n    }\n  }, {\n    key: \"_pushMap\",\n    value: function _pushMap(gen, obj, opts) {\n      opts = Object.assign({\n        indefinite: false\n      }, opts);\n\n      if (opts.indefinite) {\n        if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n          return false;\n        }\n      } else if (!gen._pushInt(obj.size, MT.MAP)) {\n        return false;\n      } // memoizing the cbor only helps in certain cases, and hurts in most\n      // others.  Just avoid it.\n\n\n      if (gen.canonical) {\n        // keep the key/value pairs together, so we don't have to do odd\n        // gets with object keys later\n        var entries = _toConsumableArray(obj.entries());\n\n        var enc = new Encoder(this); // TODO: fix genTypes\n\n        var bs = new NoFilter({\n          highWaterMark: this.readableHighWaterMark\n        });\n        enc.pipe(bs);\n        entries.sort(function (_ref, _ref2) {\n          var _ref3 = _slicedToArray(_ref, 1),\n              a = _ref3[0];\n\n          var _ref4 = _slicedToArray(_ref2, 1),\n              b = _ref4[0];\n\n          // a, b are the keys\n          enc.pushAny(a);\n          var a_cbor = bs.read();\n          enc.pushAny(b);\n          var b_cbor = bs.read();\n          return a_cbor.compare(b_cbor);\n        });\n\n        var _iterator2 = _createForOfIteratorHelper(entries),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n                k = _step2$value[0],\n                v = _step2$value[1];\n\n            if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n              throw new Error('Invalid Map key: undefined');\n            }\n\n            if (!(gen.pushAny(k) && gen.pushAny(v))) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(obj),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n                _k = _step3$value[0],\n                _v = _step3$value[1];\n\n            if (gen.disallowUndefinedKeys && typeof _k === 'undefined') {\n              throw new Error('Invalid Map key: undefined');\n            }\n\n            if (!(gen.pushAny(_k) && gen.pushAny(_v))) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      if (opts.indefinite) {\n        if (!gen.push(BREAK)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushUint8Array\",\n    value: function _pushUint8Array(gen, obj) {\n      return gen._pushBuffer(gen, Buffer.from(obj));\n    }\n  }, {\n    key: \"_pushFloat32Array\",\n    value: function _pushFloat32Array(gen, obj) {\n      var len = obj.length;\n\n      if (!gen._pushInt(len, MT.ARRAY)) {\n        return false;\n      }\n\n      for (var j = 0; j < len; j++) {\n        if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushFloat64Array\",\n    value: function _pushFloat64Array(gen, obj) {\n      var len = obj.length;\n\n      if (!gen._pushInt(len, MT.ARRAY)) {\n        return false;\n      }\n\n      for (var j = 0; j < len; j++) {\n        if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Remove all of the loop detector additions to the given object.\n     *\n     * @param {Object} obj - object to clean\n     * @returns {bool} - true when the object was cleaned, else false\n     */\n\n  }, {\n    key: \"removeLoopDetectors\",\n    value: function removeLoopDetectors(obj) {\n      if (!this.detectLoops) {\n        return false;\n      }\n\n      return Encoder.removeLoopDetectors(obj, this.detectLoops);\n    }\n    /**\n     * Remove all of the loop detector additions to the given object.\n     * The static version is easier to call when you don't have a full\n     * encoder instance available; it uses a good heuristic to figure\n     * out the loop detector symbol.\n     *\n     * @param {Object} obj - object to clean\n     * @param {Symbol} [detector=null] - the symbol to clean, or null\n     *   to use the first detected symbol\n     * @returns {bool} - true when the object was cleaned, else false\n     */\n\n  }, {\n    key: \"_pushObject\",\n    value: function _pushObject(obj, opts) {\n      if (!obj) {\n        return this._pushNull(obj);\n      }\n\n      opts = Object.assign({\n        indefinite: false,\n        skipTypes: false\n      }, opts);\n\n      if (!opts.indefinite) {\n        // this will only happen the first time through for indefinite encoding\n        if (this.detectLoops) {\n          if (obj[LOOP_DETECT] === this.detectLoops) {\n            throw new Error('Loop detected while CBOR encoding');\n          } else {\n            obj[LOOP_DETECT] = this.detectLoops;\n          }\n        }\n      }\n\n      if (!opts.skipTypes) {\n        var f = obj.encodeCBOR;\n\n        if (typeof f === 'function') {\n          return f.call(obj, this);\n        }\n\n        var converter = this.semanticTypes[obj.constructor.name];\n\n        if (converter) {\n          return converter.call(obj, this, obj);\n        }\n      }\n\n      var keys = Object.keys(obj).filter(function (k) {\n        return typeof obj[k] !== 'function';\n      });\n      var cbor_keys = {};\n\n      if (this.canonical) {\n        // note: this can't be a normal sort, because 'b' needs to sort before\n        // 'aa'\n        keys.sort(function (a, b) {\n          // Always strings, so don't bother to pass options.\n          // hold on to the cbor versions, since there's no need\n          // to encode more than once\n          var a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n          var b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n          return a_cbor.compare(b_cbor);\n        });\n      }\n\n      if (opts.indefinite) {\n        if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n          return false;\n        }\n      } else if (!this._pushInt(keys.length, MT.MAP)) {\n        return false;\n      }\n\n      var ck;\n\n      for (var j = 0, len2 = keys.length; j < len2; j++) {\n        var k = keys[j];\n\n        if (this.canonical && (ck = cbor_keys[k])) {\n          if (!this.push(ck)) {\n            // already a Buffer\n            return false;\n          }\n        } else {\n          if (!this._pushString(k)) {\n            return false;\n          }\n        }\n\n        if (!this.pushAny(obj[k])) {\n          return false;\n        }\n      }\n\n      if (opts.indefinite) {\n        if (!this.push(BREAK)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Push any supported type onto the encoded stream\n     *\n     * @param {any} obj\n     * @returns {boolean} true on success\n     */\n\n  }, {\n    key: \"pushAny\",\n    value: function pushAny(obj) {\n      switch (typeof obj) {\n        case 'number':\n          return this._pushNumber(obj);\n\n        case 'bigint':\n          return this._pushJSBigint(obj);\n\n        case 'string':\n          return this._pushString(obj);\n\n        case 'boolean':\n          return this._pushBoolean(obj);\n\n        case 'undefined':\n          return this._pushUndefined(obj);\n\n        case 'object':\n          return this._pushObject(obj);\n\n        case 'symbol':\n          switch (obj) {\n            case SYMS.NULL:\n              return this._pushNull(null);\n\n            case SYMS.UNDEFINED:\n              return this._pushUndefined(void 0);\n            // TODO: Add pluggable support for other symbols\n\n            default:\n              throw new Error('Unknown symbol: ' + obj.toString());\n          }\n\n        default:\n          throw new Error('Unknown type: ' + typeof obj + ', ' + (!!obj.toString ? obj.toString() : ''));\n      }\n    }\n    /* backwards-compat wrapper */\n\n  }, {\n    key: \"_pushAny\",\n    value: function _pushAny(obj) {\n      // TODO: write deprecation warning\n      return this.pushAny(obj);\n    }\n  }, {\n    key: \"_encodeAll\",\n    value: function _encodeAll(objs) {\n      var bs = new NoFilter({\n        highWaterMark: this.readableHighWaterMark\n      });\n      this.pipe(bs);\n\n      var _iterator4 = _createForOfIteratorHelper(objs),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var o = _step4.value;\n          this.pushAny(o);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.end();\n      return bs.read();\n    }\n    /**\n     * Encode the given object with indefinite length.  There are apparently\n     * some (IMO) broken implementations of poorly-specified protocols that\n     * REQUIRE indefinite-encoding.  Add this to an object or class as the\n     * `encodeCBOR` function to get indefinite encoding:\n     * @example\n     * const o = {\n     *   a: true,\n     *   encodeCBOR: cbor.Encoder.encodeIndefinite\n     * }\n     * const m = []\n     * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n     * cbor.encodeOne([o, m])\n     *\n     * @param {Encoder} - the encoder to use\n     * @param {String|Buffer|Array|Map|Object} [obj] - the object to encode.  If\n     *   null, use \"this\" instead.\n     * @param {Object} [opts=null] - Options for encoding\n     * @param {boolean} [opts.chunkSize=4096] - Number of characters or bytes\n     *  for each chunk, if obj is a string or Buffer\n     * @returns {boolean} - true on success\n     */\n\n  }], [{\n    key: \"removeLoopDetectors\",\n    value: function removeLoopDetectors(obj) {\n      var detector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (typeof obj !== 'object' || !obj) {\n        return false;\n      }\n\n      var dl = obj[LOOP_DETECT];\n\n      if (!dl) {\n        // ironically, use loop marking to detect loops on removal as well\n        return false;\n      }\n\n      if (detector == null) {\n        detector = dl;\n      } else {\n        if (detector !== dl) {\n          return false;\n        }\n      }\n\n      delete obj[LOOP_DETECT];\n\n      if (Array.isArray(obj)) {\n        var _iterator5 = _createForOfIteratorHelper(obj),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var i = _step5.value;\n            this.removeLoopDetectors(i, detector);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else {\n        for (var k in obj) {\n          this.removeLoopDetectors(obj[k], detector);\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"encodeIndefinite\",\n    value: function encodeIndefinite(gen, obj, opts) {\n      if (obj == null) {\n        if (this == null) {\n          throw new Error('No object to encode');\n        }\n\n        obj = this;\n      }\n\n      opts = Object.assign({\n        chunkSize: 4096\n      }, opts);\n      var ret = true;\n      var objType = typeof obj;\n\n      if (objType === 'string') {\n        // TODO: make sure not to split surrogate pairs at the edges of chunks,\n        // since such half-surrogates cannot be legally encoded as UTF-8.\n        ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);\n        var offset = 0;\n\n        while (offset < obj.length) {\n          var endIndex = offset + opts.chunkSize;\n          ret = ret && gen._pushString(obj.slice(offset, endIndex));\n          offset = endIndex;\n        }\n\n        ret = ret && gen.push(BREAK);\n      } else if (Buffer.isBuffer(obj)) {\n        ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);\n        var _offset = 0;\n\n        while (_offset < obj.length) {\n          var _endIndex = _offset + opts.chunkSize;\n\n          ret = ret && gen._pushBuffer(gen, obj.slice(_offset, _endIndex));\n          _offset = _endIndex;\n        }\n\n        ret = ret && gen.push(BREAK);\n      } else if (Array.isArray(obj)) {\n        ret = ret && gen._pushArray(gen, obj, {\n          indefinite: true\n        });\n      } else if (obj instanceof Map) {\n        ret = ret && gen._pushMap(gen, obj, {\n          indefinite: true\n        });\n      } else {\n        if (objType !== 'object') {\n          throw new Error('Invalid indefinite encoding');\n        }\n\n        ret = ret && gen._pushObject(obj, {\n          indefinite: true,\n          skipTypes: true\n        });\n      }\n\n      return ret;\n    }\n    /**\n     * Encode one or more JavaScript objects, and return a Buffer containing the\n     * CBOR bytes.\n     *\n     * @param {...any} objs - the objects to encode\n     * @returns {Buffer} - the encoded objects\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n        objs[_key] = arguments[_key];\n      }\n\n      return new Encoder()._encodeAll(objs);\n    }\n    /**\n     * Encode one or more JavaScript objects canonically (slower!), and return\n     * a Buffer containing the CBOR bytes.\n     *\n     * @param {...any} objs - the objects to encode\n     * @returns {Buffer} - the encoded objects\n     */\n\n  }, {\n    key: \"encodeCanonical\",\n    value: function encodeCanonical() {\n      for (var _len2 = arguments.length, objs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        objs[_key2] = arguments[_key2];\n      }\n\n      return new Encoder({\n        canonical: true\n      })._encodeAll(objs);\n    }\n    /**\n     * Encode one JavaScript object using the given options.\n     *\n     * @static\n     * @param {any} obj - the object to encode\n     * @param {Object?} options - passed to the Encoder constructor\n     * @returns {Buffer} - the encoded objects\n     */\n\n  }, {\n    key: \"encodeOne\",\n    value: function encodeOne(obj, options) {\n      return new Encoder(options)._encodeAll([obj]);\n    }\n    /**\n     * Encode one JavaScript object using the given options in a way that\n     * is more resilient to objects being larger than the highWaterMark\n     * number of bytes.  As with the other static encode functions, this \n     * will still use a large amount of memory.  Use a stream-based approach\n     * directly if you need to process large and complicated inputs.\n     *\n     * @param {any} obj - the object to encode\n     * @param {Object?} options - passed to the Encoder constructor\n     */\n\n  }, {\n    key: \"encodeAsync\",\n    value: function encodeAsync(obj, options) {\n      return new Promise(function (resolve, reject) {\n        var bufs = [];\n        var enc = new Encoder(options);\n        enc.on('data', function (buf) {\n          return bufs.push(buf);\n        });\n        enc.on('error', reject);\n        enc.on('finish', function () {\n          return resolve(Buffer.concat(bufs));\n        });\n        enc.pushAny(obj);\n        enc.end();\n      });\n    }\n  }]);\n\n  return Encoder;\n}(stream.Transform);\n\nmodule.exports = Encoder;","map":null,"metadata":{},"sourceType":"script"}