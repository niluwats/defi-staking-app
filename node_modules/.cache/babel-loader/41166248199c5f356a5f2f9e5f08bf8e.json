{"ast":null,"code":"var _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar debug = require(\"debug\")(\"contract:promievent\");\n\nvar DebugUtils = require(\"@truffle/debug-utils\");\n\nvar Web3PromiEvent = require(\"web3-core-promievent\");\n\nfunction PromiEvent(justPromise) {\n  var bugger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var isDeploy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _Web3PromiEvent = new Web3PromiEvent(justPromise),\n      resolve = _Web3PromiEvent.resolve,\n      reject = _Web3PromiEvent.reject,\n      eventEmitter = _Web3PromiEvent.eventEmitter;\n\n  var originalStackTrace = new Error().stack;\n\n  function rejectHijacker(e) {\n    var _this = this;\n\n    debug(\"hijacking!\");\n    debug(\"hash: %s\", this.txHash);\n    var getSolidityStackTrace;\n\n    if (bugger && this.txHash) {\n      debug(\"debugging time!\");\n\n      getSolidityStackTrace = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var report;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return bugger.load(_this.txHash);\n\n                case 3:\n                  _context.next = 5;\n                  return bugger.runToEnd();\n\n                case 5:\n                  report = bugger.stacktrace();\n                  _context.next = 8;\n                  return bugger.unload();\n\n                case 8:\n                  return _context.abrupt(\"return\", DebugUtils.formatStacktrace(report, 4));\n\n                case 11:\n                  _context.prev = 11;\n                  _context.t0 = _context[\"catch\"](0);\n                  return _context.abrupt(\"return\", undefined);\n\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 11]]);\n        }));\n\n        return function getSolidityStackTrace() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    } else {\n      getSolidityStackTrace = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  return _context2.abrupt(\"return\", undefined);\n\n                case 1:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function getSolidityStackTrace() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n    }\n\n    getSolidityStackTrace().then(function (solidityStackTrace) {\n      debug(\"e.stack: %s\", e.stack);\n      debug(\"originalStackTrace: %s\", originalStackTrace);\n      debug(\"solidityStackTrace: %s\", solidityStackTrace);\n      var initialLinesRegexp = isDeploy ? /^.*\\n.*\\n.*\\n.*/ //first 4 lines (note . does not include \\n)\n      : /^.*\\n.*\\n.*/; //first 3 lines\n      //we replace not just the first line but also the next 2 as they contain\n      //useless stuff users shouldn't see; in case of deployments there's one\n      //additional to remove\n\n      try {\n        var stackTrace = originalStackTrace.replace(initialLinesRegexp, e.stack.split(\"\\n\")[0]);\n\n        if (solidityStackTrace) {\n          //let's split the solidity stack trace into first line & rest\n          var _solidityStackTrace$m = solidityStackTrace.match(/^(.*?)\\r?\\n((.|\\r|\\n)*)$/),\n              _solidityStackTrace$m2 = _slicedToArray(_solidityStackTrace$m, 3),\n              _ = _solidityStackTrace$m2[0],\n              solidityFirstLine = _solidityStackTrace$m2[1],\n              solidityRemaining = _solidityStackTrace$m2[2];\n\n          stackTrace = stackTrace.replace(/^.*/, //note that . does not include \\n\n          solidityRemaining //note: this does not end in \\n, so no modification needed\n          );\n          e.hijackedMessage = e.message;\n          e.message = solidityFirstLine;\n        }\n\n        e.hijackedStack = e.stack;\n        e.stack = stackTrace;\n      } catch (_) {//again, ignore errors\n        //(not sure how this can happen here but I'll leave this block here)\n      }\n\n      reject(e);\n    });\n  }\n\n  this.resolve = resolve;\n  this.reject = rejectHijacker.bind(this);\n  this.eventEmitter = eventEmitter;\n\n  if (bugger) {\n    this.debug = true;\n  }\n}\n\nPromiEvent.resolve = Web3PromiEvent.resolve;\n\nPromiEvent.prototype.setTransactionHash = function (txHash) {\n  debug(\"setting!\");\n  debug(\"hash: %s\", txHash);\n  this.txHash = txHash;\n};\n\nmodule.exports = PromiEvent;","map":null,"metadata":{},"sourceType":"script"}