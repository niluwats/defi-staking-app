{"ast":null,"code":"var _defineProperty = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"D:\\\\truff\\\\defi-staking-app-starter\\\\defi-staking-app-starter\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar pkgVersion = require(\"./package.json\").version;\n\nvar Ajv = require(\"ajv\");\n\nvar util = require(\"util\");\n\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\n\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\n\nvar abiSchema = require(\"./spec/abi.spec.json\");\n/**\n * Property definitions for Contract Objects\n *\n * Describes canonical output properties as sourced from some \"dirty\" input\n * object. Describes normalization process to account for deprecated and/or\n * nonstandard keys and values.\n *\n * Maps (key -> property) where:\n *  - `key` is the top-level output key matching up with those in the schema\n *  - `property` is an object with optional values:\n *      - `sources`: list of sources (see below); default `key`\n *      - `transform`: function(value) -> transformed value; default x -> x\n *\n * Each source represents a means to select a value from dirty object.\n * Allows:\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\n *    object\n *  - function(dirtyObj) -> (cleanValue | undefined)\n *\n * The optional `transform` parameter standardizes value regardless of source,\n * for purposes of ensuring data type and/or string schemas.\n */\n// helper that ensures abi's do not contain function signatures\n\n\nvar sanitizedValue = function sanitizedValue(dirtyValueArray) {\n  var sanitizedValueArray = [];\n  dirtyValueArray.forEach(function (item) {\n    var sanitizedItem = Object.assign({}, item);\n    delete sanitizedItem.signature;\n    sanitizedValueArray.push(sanitizedItem);\n  });\n  return sanitizedValueArray;\n}; // filter `signature` property from an event\n\n\nvar sanitizeEvent = function sanitizeEvent(dirtyEvent) {\n  return Object.entries(dirtyEvent).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        property = _ref2[0],\n        value = _ref2[1];\n\n    return property === \"signature\" ? acc : Object.assign(acc, _defineProperty({}, property, value));\n  }, {});\n}; // sanitize aggregrate events given a `network-object.spec.json#events` object\n\n\nvar sanitizeAllEvents = function sanitizeAllEvents(dirtyEvents) {\n  return Object.entries(dirtyEvents).reduce(function (acc, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        property = _ref4[0],\n        event = _ref4[1];\n\n    return Object.assign(acc, _defineProperty({}, property, sanitizeEvent(event)));\n  }, {});\n};\n\nvar properties = {\n  contractName: {\n    sources: [\"contractName\", \"contract_name\"]\n  },\n  abi: {\n    sources: [\"abi\", \"interface\"],\n    transform: function transform(value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (_) {\n          value = undefined;\n        }\n      }\n\n      if (Array.isArray(value)) {\n        return sanitizedValue(value);\n      }\n\n      return value;\n    }\n  },\n  metadata: {\n    sources: [\"metadata\"]\n  },\n  bytecode: {\n    sources: [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\n    transform: function transform(value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  deployedBytecode: {\n    sources: [\"deployedBytecode\", \"runtimeBytecode\", \"evm.deployedBytecode.object\"],\n    transform: function transform(value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  immutableReferences: {},\n  generatedSources: {},\n  deployedGeneratedSources: {},\n  sourceMap: {\n    transform: function transform(value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  deployedSourceMap: {\n    transform: function transform(value) {\n      if (typeof value === \"string\") {\n        try {\n          return JSON.parse(value);\n        } catch (_) {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    },\n    sources: [\"deployedSourceMap\", \"srcmapRuntime\", \"evm.deployedBytecode.sourceMap\"]\n  },\n  source: {},\n  sourcePath: {},\n  ast: {},\n  legacyAST: {\n    transform: function transform(value, obj) {\n      if (value) {\n        return value;\n      } else {\n        return obj.ast;\n      }\n    }\n  },\n  compiler: {},\n  networks: {\n    /**\n     * Normalize a networks object. Currently this makes sure `events` are\n     * always sanitized and `links` is extracted when copying from\n     * a TruffleContract context object.\n     *\n     * @param {object} value - the target object\n     * @param {object | TruffleContract} obj - the context, or source object.\n     * @return {object} The normalized Network object\n     */\n    transform: function transform() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var obj = arguments.length > 1 ? arguments[1] : undefined;\n      // Sanitize value's events for known networks\n      Object.keys(value).forEach(function (networkId) {\n        if (value[networkId].events) {\n          value[networkId].events = sanitizeAllEvents(value[networkId].events);\n        }\n      }); // Set and sanitize the current networks property from the\n      // TruffleContract. Note: obj is a TruffleContract if it has\n      // `network_id` attribute\n\n      var networkId = obj.network_id;\n\n      if (networkId && value.hasOwnProperty(networkId)) {\n        value[networkId].links = obj.links;\n        value[networkId].events = sanitizeAllEvents(obj.events);\n      }\n\n      return value;\n    }\n  },\n  schemaVersion: {\n    sources: [\"schemaVersion\", \"schema_version\"]\n  },\n  updatedAt: {\n    sources: [\"updatedAt\", \"updated_at\"],\n    transform: function transform(value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n\n      return value;\n    }\n  },\n  networkType: {},\n  devdoc: {},\n  userdoc: {},\n  db: {}\n};\n/**\n * Construct a getter for a given key, possibly applying some post-retrieve\n * transformation on the resulting value.\n *\n * @return {Function} Accepting dirty object and returning value || undefined\n */\n\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function transform(x) {\n      return x;\n    };\n  }\n\n  return function (obj) {\n    try {\n      return transform(obj[key]);\n    } catch (_) {\n      return undefined;\n    }\n  };\n}\n/**\n * Chains together a series of function(obj) -> value, passing resulting\n * returned value to next function in chain.\n *\n * Accepts any number of functions passed as arguments\n * @return {Function} Accepting initial object, returning end-of-chain value\n *\n * Assumes all intermediary values to be objects, with well-formed sequence\n * of operations.\n */\n\n\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function (obj) {\n    return getters.reduce(function (cur, get) {\n      return get(cur);\n    }, obj);\n  };\n} // Schema module\n//\n\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function validate(contractObj) {\n    var ajv = new Ajv({\n      verbose: true\n    });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      var message = \"Schema validation failed. Errors:\\n\\n\".concat(ajv.errors.map(function (_ref5) {\n        var keyword = _ref5.keyword,\n            dataPath = _ref5.dataPath,\n            schemaPath = _ref5.schemaPath,\n            params = _ref5.params,\n            message = _ref5.message,\n            data = _ref5.data,\n            parentSchema = _ref5.parentSchema;\n        return util.format(\"%s (%s):\\n%s\\n\", message, keyword, util.inspect({\n          dataPath: dataPath,\n          schemaPath: schemaPath,\n          params: params,\n          data: data,\n          parentSchema: parentSchema\n        }, {\n          depth: 5\n        }));\n      }).join(\"\\n\"));\n      var error = new Error(message);\n      error.errors = ajv.errors;\n      throw error;\n    }\n  },\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function normalize(objDirty, options) {\n    options = options || {};\n    var normalized = {}; // iterate over each property\n\n    Object.keys(properties).forEach(function (key) {\n      var property = properties[key];\n      var value; // normalized value || undefined\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n\n      var sources = property.sources || [key]; // iterate over sources until value is defined or end of list met\n\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i]; // string refers to path to value in objDirty, split and chain\n        // getters\n\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\").map(function (k) {\n            return getter(k);\n          });\n          source = chain.apply(null, traversals);\n        } // source should be a function that takes the objDirty and returns\n        // value or undefined\n\n\n        value = source(objDirty);\n      } // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n\n\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      } // add resulting (possibly undefined) to normalized obj\n\n\n      normalized[key] = value;\n    }); // Copy x- options\n\n    Object.keys(objDirty).forEach(function (key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    }); // update schema version\n\n    normalized.schemaVersion = pkgVersion;\n\n    if (options.validate) {\n      this.validate(normalized);\n    }\n\n    return normalized;\n  }\n};\nmodule.exports = TruffleContractSchema;","map":null,"metadata":{},"sourceType":"script"}